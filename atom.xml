<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余睿的博客</title>
  <icon>https://www.yurui.tech/icon.png</icon>
  <subtitle>浮生若梦，别多会少，不如莫遇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yurui.tech/"/>
  <updated>2020-12-21T16:09:46.000Z</updated>
  <id>https://www.yurui.tech/</id>
  
  <author>
    <name>余睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QWidget类</title>
    <link href="https://www.yurui.tech/2020/12/22/Qt6/3%E3%80%81QWidget%E7%B1%BB/"/>
    <id>https://www.yurui.tech/2020/12/22/Qt6/3%E3%80%81QWidget%E7%B1%BB/</id>
    <published>2020-12-21T16:09:46.000Z</published>
    <updated>2020-12-21T16:09:46.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;QWidget类&quot;&gt;&lt;a href=&quot;#QWidget类&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="Qt6" scheme="https://www.yurui.tech/categories/Qt6/"/>
    
    
      <category term="QWidget" scheme="https://www.yurui.tech/tags/QWidget/"/>
    
  </entry>
  
  <entry>
    <title>Qt信号槽</title>
    <link href="https://www.yurui.tech/2020/12/21/Qt6/2%E3%80%81Qt%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>https://www.yurui.tech/2020/12/21/Qt6/2%E3%80%81Qt%E4%BF%A1%E5%8F%B7%E6%A7%BD/</id>
    <published>2020-12-21T12:12:06.000Z</published>
    <updated>2020-12-21T12:12:06.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;信号槽原理&quot;&gt;&lt;a href=&quot;#信号槽原理&quot; class=&quot;headerlink&quot; title=&quot;信号槽原理&quot;&gt;&lt;/a&gt;信号槽原理&lt;/h1&gt;&lt;p&gt;在&lt;code&gt;Qt&lt;/code&gt;中，提供了信号槽来处理对象间的通信。信号槽机制是&lt;code&gt;Qt&lt;/code&gt;中的主要特征，同时也是&lt;code&gt;Qt&lt;/code&gt;不同于其它框架的最大特点。&lt;/p&gt;
&lt;p&gt;信号槽有些类似windows中的消息机制，通过回调函数来处理对象间的通信。但是回调函数是一种紧耦合的设计，调用者必须知道该在什么时候调用哪个回调函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Qt&lt;/code&gt;中的信号槽机制主要有以下两类函数实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号函数：只管发出信号，不需要知道信号的接收者。例如按钮点击事件。&lt;/li&gt;
&lt;li&gt;槽函数：只管接收，不管是谁发出的信号。例如响应一个点击事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号函数与槽函数之间的联系通过&lt;code&gt;QObject&lt;/code&gt;对象来绑定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt6" scheme="https://www.yurui.tech/categories/Qt6/"/>
    
    
      <category term="Qt6" scheme="https://www.yurui.tech/tags/Qt6/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="信号槽" scheme="https://www.yurui.tech/tags/%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>Qt6引入第三方opencv库</title>
    <link href="https://www.yurui.tech/2020/12/21/Qt6/1%E3%80%81Qt6%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://www.yurui.tech/2020/12/21/Qt6/1%E3%80%81Qt6%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</id>
    <published>2020-12-21T02:58:48.000Z</published>
    <updated>2020-12-21T02:58:48.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h1&gt;&lt;p&gt;首先创建一个新的Qt6项目，选择&lt;code&gt;Qt Widgets Application&lt;/code&gt;，然后一路默认，创建一个最基本的Qt5项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20201221172739602.png&quot; alt=&quot;创建qt项目&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt6" scheme="https://www.yurui.tech/categories/Qt6/"/>
    
    
      <category term="Qt6" scheme="https://www.yurui.tech/tags/Qt6/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="opencv" scheme="https://www.yurui.tech/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://www.yurui.tech/2020/10/21/%E6%8E%92%E5%BA%8F/2%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.yurui.tech/2020/10/21/%E6%8E%92%E5%BA%8F/2%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-10-21T07:00:10.000Z</published>
    <updated>2020-10-21T07:00:10.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;归并排序（MergeSort）&lt;/strong&gt;采用了&lt;strong&gt;分治的思想（Divide And Conquer）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总的来说，整个排序思想可分为如下几部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将待排序序列一分为二&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子序列递归排序&lt;code&gt;O(log n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;合并有序子序列&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="排序" scheme="https://www.yurui.tech/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://www.yurui.tech/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://www.yurui.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="mergesort" scheme="https://www.yurui.tech/tags/mergesort/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://www.yurui.tech/2020/10/21/%E6%8E%92%E5%BA%8F/1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.yurui.tech/2020/10/21/%E6%8E%92%E5%BA%8F/1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2020-10-21T06:59:23.000Z</published>
    <updated>2020-10-21T06:59:23.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构思&quot;&gt;&lt;a href=&quot;#构思&quot; class=&quot;headerlink&quot; title=&quot;构思&quot;&gt;&lt;/a&gt;构思&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;问题：给定任意一个数组，内含&lt;code&gt;n&lt;/code&gt;个可比较的元素，将它们按升序排列。&lt;/li&gt;
&lt;li&gt;观察：在该数组中，对于任意两个相邻的元素，其关系总为顺序/逆序。&lt;/li&gt;
&lt;li&gt;扫描交换：依次比较每一对相邻的元素，如有必要，将其交换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="排序" scheme="https://www.yurui.tech/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://www.yurui.tech/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://www.yurui.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="bubble sort" scheme="https://www.yurui.tech/tags/bubble-sort/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://www.yurui.tech/2020/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://www.yurui.tech/2020/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-09-22T13:09:35.000Z</published>
    <updated>2020-09-22T13:09:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;依赖倒置原则（Dependency-Inversion-Principle，DIP）&quot;&gt;&lt;a href=&quot;#依赖倒置原则（Dependency-Inversion-Principle，DIP）&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则（Dependency Inversion Principle，DIP）&quot;&gt;&lt;/a&gt;依赖倒置原则（Dependency Inversion Principle，DIP）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖抽象（稳定）。&lt;/li&gt;
&lt;li&gt;抽象（稳定）不应该依赖于抽象细节（变化），实现细节应该依赖于抽象（稳定）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.yurui.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="设计模式" scheme="https://www.yurui.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>c++ list容器的使用</title>
    <link href="https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/c-list%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/c-list%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-22T13:04:50.000Z</published>
    <updated>2020-09-22T13:04:50.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>STL剖析/c-array容器的使用</title>
    <link href="https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/c-array%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/c-array%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-22T13:04:41.000Z</published>
    <updated>2020-09-22T13:04:41.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;p&gt;&lt;code&gt;array&lt;/code&gt;的初始化使用聚合初始化（aggregate initialization），聚合初始内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;&amp;lt;T,&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;&amp;gt; arr_name&amp;#123;aggregate initialization&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;T&lt;/code&gt;为任意类型（含基本类型以外的自定义类型）；&lt;code&gt;size&lt;/code&gt;为指定容器的大小；&lt;code&gt;arr_name&lt;/code&gt;为&lt;code&gt;array&lt;/code&gt;对象名；&lt;code&gt;aggregate initialization&lt;/code&gt;采用聚合初始化，更多内容见 [聚合初始化] (&lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/aggregate_initialization/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.cppreference.com/w/cpp/language/aggregate_initialization/&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.yurui.tech/categories/STL/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="STL" scheme="https://www.yurui.tech/tags/STL/"/>
    
      <category term="array" scheme="https://www.yurui.tech/tags/array/"/>
    
      <category term="容器" scheme="https://www.yurui.tech/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>c++ vector容器的使用</title>
    <link href="https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/3%E3%80%81c-vector%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.yurui.tech/2020/09/22/STL%E5%89%96%E6%9E%90/3%E3%80%81c-vector%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-22T13:04:27.000Z</published>
    <updated>2020-09-22T13:04:27.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;的构造函数有以下几种重载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认无参构造函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;{}&lt;/code&gt;内的内容初始化&lt;/li&gt;
&lt;li&gt;使用一个以及存在的容器初始化&lt;/li&gt;
&lt;li&gt;初始化为指定个数指定的内容&lt;/li&gt;
&lt;li&gt;用数组进行初始化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.yurui.tech/categories/STL/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="vector" scheme="https://www.yurui.tech/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>STL容器的基本结构</title>
    <link href="https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/2%E3%80%81STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/2%E3%80%81STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-21T14:33:32.000Z</published>
    <updated>2020-09-21T14:33:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;容器被用来存储数据结构的数据，依据数据结构的不同特点，容器对于数据的组织形式也不同，大致可分为以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性结构容器（Sequence Containers）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;线性结构的容器是指在内存中的存储空间是连续编址的（如：&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;等），或是逻辑上是连续的（如：&lt;code&gt;list&lt;/code&gt;）。数据中的元素存在一对一的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.yurui.tech/categories/STL/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="STL" scheme="https://www.yurui.tech/tags/STL/"/>
    
      <category term="stl容器" scheme="https://www.yurui.tech/tags/stl%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL体系结构</title>
    <link href="https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/1%E3%80%81STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/1%E3%80%81STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-21T09:11:22.000Z</published>
    <updated>2020-09-21T09:11:22.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;STL六大部件-Components&quot;&gt;&lt;a href=&quot;#STL六大部件-Components&quot; class=&quot;headerlink&quot; title=&quot;STL六大部件(Components)&quot;&gt;&lt;/a&gt;STL六大部件(Components)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器(Containers)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;容器是用来存放数据的地方，如&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配器(Allocators)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;容器放置数据需要内存空间，分配器用来为容器分配内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.yurui.tech/categories/STL/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="STL" scheme="https://www.yurui.tech/tags/STL/"/>
    
      <category term="stl体系结构" scheme="https://www.yurui.tech/tags/stl%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++用流操作算子控制输入输出格式</title>
    <link href="https://www.yurui.tech/2020/08/05/C++/33%E3%80%81c-%E7%94%A8%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"/>
    <id>https://www.yurui.tech/2020/08/05/C++/33%E3%80%81c-%E7%94%A8%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-08-05T14:22:10.000Z</published>
    <updated>2020-08-05T14:22:10.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在实际的编程中，我们可能需要对输出格式进行控制，比如以某进制输出一个数，或者控制浮点数的精度，再或者控制输出的位宽。这是就需要用到流操纵算子进行格式控制。&lt;/p&gt;
&lt;p&gt;需要注意的是，使用流操纵算子需要&lt;strong&gt;包含头文件&lt;code&gt;#include&amp;lt;iomanip&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="流操作算子" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90/"/>
    
      <category term="输出格式控制" scheme="https://www.yurui.tech/tags/%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>c++输入输出流的相关类</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/33%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/33%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</id>
    <published>2020-08-04T15:05:44.000Z</published>
    <updated>2020-08-04T15:05:44.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入输出流类&quot;&gt;&lt;a href=&quot;#输入输出流类&quot; class=&quot;headerlink&quot; title=&quot;输入输出流类&quot;&gt;&lt;/a&gt;输入输出流类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200805164936480.png&quot; alt=&quot;输入输出流&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="输入输出" scheme="https://www.yurui.tech/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>c++纯虚函数和抽象类</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/32%E3%80%81c-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/32%E3%80%81c-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-08-04T15:05:35.000Z</published>
    <updated>2020-08-04T15:05:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;纯虚函数：没有函数体的虚函数&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//纯虚函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
      <category term="纯虚函数" scheme="https://www.yurui.tech/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="抽象类" scheme="https://www.yurui.tech/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++虚析构函数</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/31%E3%80%81c-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/31%E3%80%81c-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-04T15:05:15.000Z</published>
    <updated>2020-08-04T15:05:15.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;通过基类指针删除派生类对象时，通常情况下只调用基类的析构函数。&lt;/p&gt;
&lt;p&gt;但是，删除一个派生类对象时，应该先调用派生类对象的析构函数，然后再调用基类的析构函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
      <category term="纯虚析构函数" scheme="https://www.yurui.tech/tags/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++多态实现原理</title>
    <link href="https://www.yurui.tech/2020/08/01/C++/30%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.yurui.tech/2020/08/01/C++/30%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-01T05:21:17.000Z</published>
    <updated>2020-08-01T05:21:17.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用基类还是派生类的函数，运行时才能确定，这叫做&lt;strong&gt;动态联编&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="实现原理" scheme="https://www.yurui.tech/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c++多态实例</title>
    <link href="https://www.yurui.tech/2020/08/01/C++/29%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/"/>
    <id>https://www.yurui.tech/2020/08/01/C++/29%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-01T04:53:52.000Z</published>
    <updated>2020-08-01T04:53:52.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;假设我们需要实现一个绘图程序，能够绘制简单的图形，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200801132014970.png&quot; alt=&quot;简单图形&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="多态实例" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>c++虚函数和多态的基本概念</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-31T06:39:32.000Z</published>
    <updated>2020-07-31T06:39:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在类的定义中，前面由&lt;code&gt;virtual&lt;/code&gt;关键字的成员函数称为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt;关键字只用在类定义里的函数声明中，写函数体时不用。&lt;/li&gt;
&lt;li&gt;构造函数和静态成员函数不能是虚函数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数" scheme="https://www.yurui.tech/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
  </entry>
  
  <entry>
    <title>c++公有继承的赋值兼容规则</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</id>
    <published>2020-07-31T06:39:17.000Z</published>
    <updated>2020-07-31T06:39:17.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;赋值规则&quot;&gt;&lt;a href=&quot;#赋值规则&quot; class=&quot;headerlink&quot; title=&quot;赋值规则&quot;&gt;&lt;/a&gt;赋值规则&lt;/h1&gt;&lt;p&gt;假设有如下的类定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&amp;#123;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Base&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Base b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Derived d;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="公有继承" scheme="https://www.yurui.tech/tags/%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF/"/>
    
      <category term="public" scheme="https://www.yurui.tech/tags/public/"/>
    
  </entry>
  
  <entry>
    <title>c++派生类的构造函数与析构函数</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-31T06:38:50.000Z</published>
    <updated>2020-07-31T06:38:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;在创建派生类对象时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先执行基类的构造函数，用来初始化派生类对象中从基类继承的成员&lt;/li&gt;
&lt;li&gt;再执行成员对象类的构造函数，初始化派生类对象中的成员变量。&lt;/li&gt;
&lt;li&gt;最后执行派生类自己的构造函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="派生类" scheme="https://www.yurui.tech/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
    
  </entry>
  
</feed>
