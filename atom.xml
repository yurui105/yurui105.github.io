<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余睿的博客</title>
  <icon>https://www.yurui.tech/icon.png</icon>
  <subtitle>浮生若梦，别多会少，不如莫遇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yurui.tech/"/>
  <updated>2020-07-31T06:39:32.000Z</updated>
  <id>https://www.yurui.tech/</id>
  
  <author>
    <name>余睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++虚函数和多态的基本概念</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-31T06:39:32.000Z</published>
    <updated>2020-07-31T06:39:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在类的定义中，前面由&lt;code&gt;virtual&lt;/code&gt;关键字的成员函数称为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt;关键字只用在类定义里的函数声明中，写函数体时不用。&lt;/li&gt;
&lt;li&gt;构造函数和静态成员函数不能是虚函数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="虚函数" scheme="https://www.yurui.tech/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
  </entry>
  
  <entry>
    <title>c++公有继承的赋值兼容规则</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</id>
    <published>2020-07-31T06:39:17.000Z</published>
    <updated>2020-07-31T06:39:17.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;赋值规则&quot;&gt;&lt;a href=&quot;#赋值规则&quot; class=&quot;headerlink&quot; title=&quot;赋值规则&quot;&gt;&lt;/a&gt;赋值规则&lt;/h1&gt;&lt;p&gt;假设有如下的类定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&amp;#123;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Base&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Base b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Derived d;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="公有继承" scheme="https://www.yurui.tech/tags/%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF/"/>
    
      <category term="public" scheme="https://www.yurui.tech/tags/public/"/>
    
  </entry>
  
  <entry>
    <title>c++派生类的构造函数与析构函数</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-31T06:38:50.000Z</published>
    <updated>2020-07-31T06:38:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;在创建派生类对象时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先执行基类的构造函数，用来初始化派生类对象中从基类继承的成员&lt;/li&gt;
&lt;li&gt;再执行成员对象类的构造函数，初始化派生类对象中的成员变量。&lt;/li&gt;
&lt;li&gt;最后执行派生类自己的构造函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="派生类" scheme="https://www.yurui.tech/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++覆盖和保护成员</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/25%E3%80%81c-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/25%E3%80%81c-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</id>
    <published>2020-07-31T06:38:27.000Z</published>
    <updated>2020-07-31T06:38:27.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;派生类可以定义一个和基类成员同名的成员，这就叫&lt;strong&gt;覆盖&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号&lt;code&gt;::&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="保护成员" scheme="https://www.yurui.tech/tags/%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/"/>
    
      <category term="覆盖" scheme="https://www.yurui.tech/tags/%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>c++继承关系和复合关系</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/24%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/24%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</id>
    <published>2020-07-30T15:10:54.000Z</published>
    <updated>2020-07-30T15:10:54.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类之间的关系&quot;&gt;&lt;a href=&quot;#类之间的关系&quot; class=&quot;headerlink&quot; title=&quot;类之间的关系&quot;&gt;&lt;/a&gt;类之间的关系&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;继承关系：“是”关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基类为&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt;是基类&lt;code&gt;A&lt;/code&gt;的派生类。&lt;/li&gt;
&lt;li&gt;逻辑上要求：一个&lt;code&gt;B&lt;/code&gt;对象也是一个&lt;code&gt;A&lt;/code&gt;对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：从&lt;code&gt;学生类&lt;/code&gt;派生出一个&lt;code&gt;研究生类&lt;/code&gt;，原则上来说，一个&lt;code&gt;研究生类&lt;/code&gt;也是一个&lt;code&gt;学生类&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="继承关系" scheme="https://www.yurui.tech/tags/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
    
      <category term="复合关系" scheme="https://www.yurui.tech/tags/%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++继承及派生基本概念</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/23%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%B4%BE%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/23%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%B4%BE%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-30T15:09:56.000Z</published>
    <updated>2020-07-30T15:09:56.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;继承：在定义一个新的类&lt;code&gt;B&lt;/code&gt;时，如果该类与某个已有的类&lt;code&gt;A&lt;/code&gt;相似（&lt;code&gt;B&lt;/code&gt;拥有&lt;code&gt;A&lt;/code&gt;的全部特征），那么就可以把&lt;code&gt;A&lt;/code&gt;作为一个&lt;strong&gt;基类&lt;/strong&gt;，而把&lt;code&gt;B&lt;/code&gt;作为基类的一个&lt;strong&gt;派生类&lt;/strong&gt;（也成为子类）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量或成员函数。&lt;/li&gt;
&lt;li&gt;派生类一旦定义后，可以独立使用，不依赖于基类。&lt;/li&gt;
&lt;li&gt;派生类拥有基类的全部成员函数和成员变量。不论是&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;还是&lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在派生类的各个成员函数中，不能访问基类的&lt;code&gt;private&lt;/code&gt;成员&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="继承和派生" scheme="https://www.yurui.tech/tags/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>c++自增自减运算符重载</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/22%E3%80%81c-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/22%E3%80%81c-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-30T14:05:51.000Z</published>
    <updated>2020-07-30T14:05:51.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;自增运算符&lt;code&gt;++&lt;/code&gt;以及自减运算符&lt;code&gt;--&lt;/code&gt;有前置、后置之分，为了区分该运算符为前置还是后置，&lt;code&gt;c++&lt;/code&gt;有如下规定：&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="自增运算符" scheme="https://www.yurui.tech/tags/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="自减运算符" scheme="https://www.yurui.tech/tags/%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>c++重载强制类型转换运算符</title>
    <link href="https://www.yurui.tech/2020/07/23/C++/21%E3%80%81c-%E9%87%8D%E8%BD%BD%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://www.yurui.tech/2020/07/23/C++/21%E3%80%81c-%E9%87%8D%E8%BD%BD%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-07-23T14:11:00.000Z</published>
    <updated>2020-07-23T14:11:00.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;强制类型转换运算符是单目运算符，也可以被重载，但&lt;strong&gt;只能重载为成员函数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Complex(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) :real(r), imag(i) &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; real; &amp;#125;  &lt;span class=&quot;comment&quot;&gt;//重载强制类型转换运算符 double&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)c &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//输出 1.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + c;  &lt;span class=&quot;comment&quot;&gt;//等价于 double n = 2 + c. operator double()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;  &lt;span class=&quot;comment&quot;&gt;//输出 3.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="类型转换运算符重载" scheme="https://www.yurui.tech/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="()运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>c++流插入和流提取运算符的重载</title>
    <link href="https://www.yurui.tech/2020/07/19/C++/20%E3%80%81c-%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/19/C++/20%E3%80%81c-%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-19T06:48:26.000Z</published>
    <updated>2020-07-19T06:48:26.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;this&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面语句为什么可以成立？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cout&lt;/code&gt;是什么？&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;为什么可以作用在&lt;code&gt;cout&lt;/code&gt;上？&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="左移运算符重载" scheme="https://www.yurui.tech/tags/%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="右移运算符重载" scheme="https://www.yurui.tech/tags/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="流插入运算符" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="流提取运算符" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>c++运算符重载为友元函数</title>
    <link href="https://www.yurui.tech/2020/07/14/C++/19%E3%80%81c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83/"/>
    <id>https://www.yurui.tech/2020/07/14/C++/19%E3%80%81c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83/</id>
    <published>2020-07-14T14:53:52.000Z</published>
    <updated>2020-07-14T14:53:52.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，将运算符重载为成员函数是比较好的选择。&lt;/p&gt;
&lt;p&gt;但有时候，重载为成员函数又不能满足需求，重载为普通函数，又不能访问类的私有成员，这时我们就需要将运算符重载为友元。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="友元" scheme="https://www.yurui.tech/tags/%E5%8F%8B%E5%85%83/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>c++赋值运算符的重载</title>
    <link href="https://www.yurui.tech/2020/07/14/C++/18%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/14/C++/18%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-14T06:23:09.000Z</published>
    <updated>2020-07-14T06:23:09.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;赋值运算符重载需求&quot;&gt;&lt;a href=&quot;#赋值运算符重载需求&quot; class=&quot;headerlink&quot; title=&quot;赋值运算符重载需求&quot;&gt;&lt;/a&gt;赋值运算符重载需求&lt;/h1&gt;&lt;p&gt;有时候我们希望运算符两边的类型可以不匹配。比如，把一个&lt;code&gt;int&lt;/code&gt;类型的变量赋值给一个对象，或者把&lt;code&gt;char*&lt;/code&gt;类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="赋值运算符重载" scheme="https://www.yurui.tech/tags/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载基本概念</title>
    <link href="https://www.yurui.tech/2020/07/14/C++/17%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/14/C++/17%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-14T05:25:39.000Z</published>
    <updated>2020-07-14T05:25:39.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;运算符重载的需求&quot;&gt;&lt;a href=&quot;#运算符重载的需求&quot; class=&quot;headerlink&quot; title=&quot;运算符重载的需求&quot;&gt;&lt;/a&gt;运算符重载的需求&lt;/h1&gt;&lt;p&gt;在数学上，两个复数是允许直接进行加减运算的。在c++中，我们用类来实现复数的表达，但是直接将&lt;code&gt;+&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;用于复数对象是不允许的。&lt;/p&gt;
&lt;p&gt;有时候我们希望让对象也能通过运算符进行运算，这样代码更加简洁，容易理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>c++友元(friends)</title>
    <link href="https://www.yurui.tech/2020/07/13/C++/14%E3%80%81c-%E5%8F%8B%E5%85%83-friend/"/>
    <id>https://www.yurui.tech/2020/07/13/C++/14%E3%80%81c-%E5%8F%8B%E5%85%83-friend/</id>
    <published>2020-07-13T08:09:05.000Z</published>
    <updated>2020-07-13T08:09:05.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;友元可以分为友元函数和友元类&lt;/p&gt;
&lt;h1 id=&quot;友元函数&quot;&gt;&lt;a href=&quot;#友元函数&quot; class=&quot;headerlink&quot; title=&quot;友元函数&quot;&gt;&lt;/a&gt;友元函数&lt;/h1&gt;&lt;h2 id=&quot;普通友元函数&quot;&gt;&lt;a href=&quot;#普通友元函数&quot; class=&quot;headerlink&quot; title=&quot;普通友元函数&quot;&gt;&lt;/a&gt;普通友元函数&lt;/h2&gt;&lt;p&gt;在c++中，我们通过类对数据进行了封装，并设置了可访问范围。但有时候我们需要在类外通过函数访问类中的私有成员，这时我们就可以将该函数声明为类的友元函数。&lt;/p&gt;
&lt;p&gt;友元函数不是类的成员函数，只是一个普通的函数，在类中加上&lt;code&gt;friend&lt;/code&gt;声明后，变为这个类的友元函数。一个类的友元函数可以访问这个类的私有成员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="friends" scheme="https://www.yurui.tech/tags/friends/"/>
    
      <category term="友元" scheme="https://www.yurui.tech/tags/%E5%8F%8B%E5%85%83/"/>
    
      <category term="友元函数" scheme="https://www.yurui.tech/tags/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
    
      <category term="友元类" scheme="https://www.yurui.tech/tags/%E5%8F%8B%E5%85%83%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++常量对象、常量成员函数以及常引用</title>
    <link href="https://www.yurui.tech/2020/07/13/C++/15%E3%80%81%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E5%BC%95%E7%94%A8/"/>
    <id>https://www.yurui.tech/2020/07/13/C++/15%E3%80%81%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E5%BC%95%E7%94%A8/</id>
    <published>2020-07-13T06:59:29.000Z</published>
    <updated>2020-07-13T06:59:29.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常量对象&quot;&gt;&lt;a href=&quot;#常量对象&quot; class=&quot;headerlink&quot; title=&quot;常量对象&quot;&gt;&lt;/a&gt;常量对象&lt;/h1&gt;&lt;p&gt;如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加上&lt;code&gt;const&lt;/code&gt;关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		value = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="const" scheme="https://www.yurui.tech/tags/const/"/>
    
      <category term="常量对象" scheme="https://www.yurui.tech/tags/%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="常量成员函数" scheme="https://www.yurui.tech/tags/%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    
      <category term="常引用" scheme="https://www.yurui.tech/tags/%E5%B8%B8%E5%BC%95%E7%94%A8/"/>
    
      <category term="引用" scheme="https://www.yurui.tech/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>c++静态成员变量以及静态成员函数</title>
    <link href="https://www.yurui.tech/2020/07/12/C++/16%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/12/C++/16%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-12T06:49:02.000Z</published>
    <updated>2020-07-12T06:49:02.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;静态成员：在说明前加上&lt;code&gt;static&lt;/code&gt;关键字的成员为静态成员。&lt;/li&gt;
&lt;li&gt;静态函数：在函数声明前加上&lt;code&gt;static&lt;/code&gt;关键字的函数就是静态成员函数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="static" scheme="https://www.yurui.tech/tags/static/"/>
    
      <category term="静态成员" scheme="https://www.yurui.tech/tags/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    
      <category term="静态函数" scheme="https://www.yurui.tech/tags/%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++ this 指针</title>
    <link href="https://www.yurui.tech/2020/07/12/C++/13%E3%80%81this-%E6%8C%87%E9%92%88/"/>
    <id>https://www.yurui.tech/2020/07/12/C++/13%E3%80%81this-%E6%8C%87%E9%92%88/</id>
    <published>2020-07-12T06:20:46.000Z</published>
    <updated>2020-07-12T06:20:46.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt;指针是c++程序中的一个关键字，&lt;code&gt;this&lt;/code&gt;指向当前对象，通过&lt;code&gt;this&lt;/code&gt;指针可以访问当前对象的所有成员。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 只能用在类的内部，通过 &lt;code&gt;this&lt;/code&gt; 可以访问类的所有成员，包括 &lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;public&lt;/code&gt; 属性的成员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="this" scheme="https://www.yurui.tech/tags/this/"/>
    
      <category term="this指针" scheme="https://www.yurui.tech/tags/this%E6%8C%87%E9%92%88/"/>
    
      <category term="this关键字" scheme="https://www.yurui.tech/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>2.矩阵与线性方程组</title>
    <link href="https://www.yurui.tech/2020/07/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/2-%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>https://www.yurui.tech/2020/07/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/2-%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2020-07-11T14:20:11.000Z</published>
    <updated>2020-07-11T14:20:11.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;矩阵-matrix-与向量的乘积&quot;&gt;&lt;a href=&quot;#矩阵-matrix-与向量的乘积&quot; class=&quot;headerlink&quot; title=&quot;矩阵(matrix)与向量的乘积&quot;&gt;&lt;/a&gt;矩阵(matrix)与向量的乘积&lt;/h1&gt;&lt;p&gt;例，我们有如下的线性方程组：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left\{\begin{aligned}
&amp;x_{1}&amp;+x_{2}&amp;-x_{3} &amp;=1 \\
&amp;2 x_{1}&amp; &amp;+x_{3}&amp;=3 \\
&amp;&amp;2 x_{2}&amp;+x_{3} &amp;=3
\end{aligned}\right.&lt;/script&gt;
    
    </summary>
    
    
      <category term="线性代数" scheme="https://www.yurui.tech/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="矩阵" scheme="https://www.yurui.tech/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="线性方程组" scheme="https://www.yurui.tech/tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>c++类型转换构造函数以及析构函数</title>
    <link href="https://www.yurui.tech/2020/07/11/C++/12%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/11/C++/12%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-11T06:01:47.000Z</published>
    <updated>2020-07-11T06:01:47.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类型转换构造函数&quot;&gt;&lt;a href=&quot;#类型转换构造函数&quot; class=&quot;headerlink&quot; title=&quot;类型转换构造函数&quot;&gt;&lt;/a&gt;类型转换构造函数&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义类型转换构造函数的目的是实现类型的自动转化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="转换构造函数" scheme="https://www.yurui.tech/tags/%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="类型转换构造函数" scheme="https://www.yurui.tech/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="~运算符" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>c++复制构造函数</title>
    <link href="https://www.yurui.tech/2020/07/10/C++/11%E3%80%81c++%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/10/C++/11%E3%80%81c++%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-10T07:32:38.000Z</published>
    <updated>2020-07-10T07:32:38.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;复制构造函数&lt;/strong&gt;(&lt;strong&gt;Copy constructor&lt;/strong&gt;)是c++中的一个特殊构造函数，也称&lt;strong&gt;拷贝构造函数&lt;/strong&gt;，它只有一个参数，参数类型为同类对象的引用。&lt;/p&gt;
&lt;p&gt;如果没有定义复制构造函数，那么编译器将生成默认的复制构造函数。默认的复制构造函数完成复制的功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="复制构造函数" scheme="https://www.yurui.tech/tags/%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="拷贝构造函数" scheme="https://www.yurui.tech/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++构造函数</title>
    <link href="https://www.yurui.tech/2020/07/09/C++/10%E3%80%81C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/09/C++/10%E3%80%81C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-09T13:11:16.000Z</published>
    <updated>2020-07-09T13:11:16.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;在c++的类中，构造函数是一种特殊的成员函数，在每次创建创建一个类的时候会默认调用构造函数进行初始化工作。&lt;/p&gt;
&lt;p&gt;构造函数用来完成一些必要的初始化工作，有了构造函数之后，就无需再单独写初始化函数，并且也不必担心忘记调用初始化函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
  </entry>
  
</feed>
