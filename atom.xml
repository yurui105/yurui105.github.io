<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余睿的博客</title>
  <icon>https://www.yurui.tech/icon.png</icon>
  <subtitle>浮生若梦，别多会少，不如莫遇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yurui.tech/"/>
  <updated>2020-09-21T14:33:32.000Z</updated>
  <id>https://www.yurui.tech/</id>
  
  <author>
    <name>余睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL容器的基本结构</title>
    <link href="https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/2%E3%80%81STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/2%E3%80%81STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-21T14:33:32.000Z</published>
    <updated>2020-09-21T14:33:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;容器被用来存储数据结构的数据，依据数据结构的不同特点，容器对于数据的组织形式也不同，大致可分为以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性结构容器（Sequence Containers）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;线性结构的容器是指在内存中的存储空间是连续编址的（如：&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;等），或是逻辑上是连续的（如：&lt;code&gt;list&lt;/code&gt;）。数据中的元素存在一对一的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="STL" scheme="https://www.yurui.tech/tags/STL/"/>
    
      <category term="stl容器" scheme="https://www.yurui.tech/tags/stl%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL体系结构</title>
    <link href="https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/1%E3%80%81STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://www.yurui.tech/2020/09/21/STL%E5%89%96%E6%9E%90/1%E3%80%81STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-21T09:11:22.000Z</published>
    <updated>2020-09-21T09:11:22.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;STL六大部件-Components&quot;&gt;&lt;a href=&quot;#STL六大部件-Components&quot; class=&quot;headerlink&quot; title=&quot;STL六大部件(Components)&quot;&gt;&lt;/a&gt;STL六大部件(Components)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器(Containers)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;容器是用来存放数据的地方，如&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配器(Allocators)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;容器放置数据需要内存空间，分配器用来为容器分配内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="STL" scheme="https://www.yurui.tech/tags/STL/"/>
    
      <category term="stl体系结构" scheme="https://www.yurui.tech/tags/stl%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://www.yurui.tech/2020/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://www.yurui.tech/2020/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-09-20T02:09:35.000Z</published>
    <updated>2020-09-20T02:09:35.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.yurui.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="设计模式" scheme="https://www.yurui.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>c++用流操作算子控制输入输出格式</title>
    <link href="https://www.yurui.tech/2020/08/05/C++/33%E3%80%81c-%E7%94%A8%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"/>
    <id>https://www.yurui.tech/2020/08/05/C++/33%E3%80%81c-%E7%94%A8%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90%E6%8E%A7%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-08-05T14:22:10.000Z</published>
    <updated>2020-08-05T14:22:10.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在实际的编程中，我们可能需要对输出格式进行控制，比如以某进制输出一个数，或者控制浮点数的精度，再或者控制输出的位宽。这是就需要用到流操纵算子进行格式控制。&lt;/p&gt;
&lt;p&gt;需要注意的是，使用流操纵算子需要&lt;strong&gt;包含头文件&lt;code&gt;#include&amp;lt;iomanip&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="流操作算子" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90/"/>
    
      <category term="输出格式控制" scheme="https://www.yurui.tech/tags/%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>c++输入输出流的相关类</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/33%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/33%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</id>
    <published>2020-08-04T15:05:44.000Z</published>
    <updated>2020-08-04T15:05:44.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;输入输出流类&quot;&gt;&lt;a href=&quot;#输入输出流类&quot; class=&quot;headerlink&quot; title=&quot;输入输出流类&quot;&gt;&lt;/a&gt;输入输出流类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200805164936480.png&quot; alt=&quot;输入输出流&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="输入输出" scheme="https://www.yurui.tech/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>c++纯虚函数和抽象类</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/32%E3%80%81c-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/32%E3%80%81c-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-08-04T15:05:35.000Z</published>
    <updated>2020-08-04T15:05:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;纯虚函数：没有函数体的虚函数&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//纯虚函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
      <category term="纯虚函数" scheme="https://www.yurui.tech/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="抽象类" scheme="https://www.yurui.tech/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++虚析构函数</title>
    <link href="https://www.yurui.tech/2020/08/04/C++/31%E3%80%81c-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/08/04/C++/31%E3%80%81c-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-04T15:05:15.000Z</published>
    <updated>2020-08-04T15:05:15.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;通过基类指针删除派生类对象时，通常情况下只调用基类的析构函数。&lt;/p&gt;
&lt;p&gt;但是，删除一个派生类对象时，应该先调用派生类对象的析构函数，然后再调用基类的析构函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
      <category term="纯虚析构函数" scheme="https://www.yurui.tech/tags/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++多态实现原理</title>
    <link href="https://www.yurui.tech/2020/08/01/C++/30%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.yurui.tech/2020/08/01/C++/30%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-01T05:21:17.000Z</published>
    <updated>2020-08-01T05:21:17.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用基类还是派生类的函数，运行时才能确定，这叫做&lt;strong&gt;动态联编&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="实现原理" scheme="https://www.yurui.tech/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c++多态实例</title>
    <link href="https://www.yurui.tech/2020/08/01/C++/29%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/"/>
    <id>https://www.yurui.tech/2020/08/01/C++/29%E3%80%81c-%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-01T04:53:52.000Z</published>
    <updated>2020-08-01T04:53:52.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;假设我们需要实现一个绘图程序，能够绘制简单的图形，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200801132014970.png&quot; alt=&quot;简单图形&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="多态实例" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>c++虚函数和多态的基本概念</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-31T06:39:32.000Z</published>
    <updated>2020-07-31T06:39:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在类的定义中，前面由&lt;code&gt;virtual&lt;/code&gt;关键字的成员函数称为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt;关键字只用在类定义里的函数声明中，写函数体时不用。&lt;/li&gt;
&lt;li&gt;构造函数和静态成员函数不能是虚函数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="虚函数" scheme="https://www.yurui.tech/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="多态" scheme="https://www.yurui.tech/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="virtual" scheme="https://www.yurui.tech/tags/virtual/"/>
    
  </entry>
  
  <entry>
    <title>c++公有继承的赋值兼容规则</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</id>
    <published>2020-07-31T06:39:17.000Z</published>
    <updated>2020-07-31T06:39:17.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;赋值规则&quot;&gt;&lt;a href=&quot;#赋值规则&quot; class=&quot;headerlink&quot; title=&quot;赋值规则&quot;&gt;&lt;/a&gt;赋值规则&lt;/h1&gt;&lt;p&gt;假设有如下的类定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&amp;#123;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Base&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Base b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Derived d;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="公有继承" scheme="https://www.yurui.tech/tags/%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF/"/>
    
      <category term="public" scheme="https://www.yurui.tech/tags/public/"/>
    
  </entry>
  
  <entry>
    <title>c++派生类的构造函数与析构函数</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-31T06:38:50.000Z</published>
    <updated>2020-07-31T06:38:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;在创建派生类对象时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先执行基类的构造函数，用来初始化派生类对象中从基类继承的成员&lt;/li&gt;
&lt;li&gt;再执行成员对象类的构造函数，初始化派生类对象中的成员变量。&lt;/li&gt;
&lt;li&gt;最后执行派生类自己的构造函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="构造函数" scheme="https://www.yurui.tech/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://www.yurui.tech/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="派生类" scheme="https://www.yurui.tech/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++覆盖和保护成员</title>
    <link href="https://www.yurui.tech/2020/07/31/C++/25%E3%80%81c-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/"/>
    <id>https://www.yurui.tech/2020/07/31/C++/25%E3%80%81c-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</id>
    <published>2020-07-31T06:38:27.000Z</published>
    <updated>2020-07-31T06:38:27.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;派生类可以定义一个和基类成员同名的成员，这就叫&lt;strong&gt;覆盖&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号&lt;code&gt;::&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="保护成员" scheme="https://www.yurui.tech/tags/%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/"/>
    
      <category term="覆盖" scheme="https://www.yurui.tech/tags/%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>c++继承关系和复合关系</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/24%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/24%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</id>
    <published>2020-07-30T15:10:54.000Z</published>
    <updated>2020-07-30T15:10:54.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类之间的关系&quot;&gt;&lt;a href=&quot;#类之间的关系&quot; class=&quot;headerlink&quot; title=&quot;类之间的关系&quot;&gt;&lt;/a&gt;类之间的关系&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;继承关系：“是”关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基类为&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt;是基类&lt;code&gt;A&lt;/code&gt;的派生类。&lt;/li&gt;
&lt;li&gt;逻辑上要求：一个&lt;code&gt;B&lt;/code&gt;对象也是一个&lt;code&gt;A&lt;/code&gt;对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：从&lt;code&gt;学生类&lt;/code&gt;派生出一个&lt;code&gt;研究生类&lt;/code&gt;，原则上来说，一个&lt;code&gt;研究生类&lt;/code&gt;也是一个&lt;code&gt;学生类&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="继承关系" scheme="https://www.yurui.tech/tags/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
    
      <category term="复合关系" scheme="https://www.yurui.tech/tags/%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>c++继承及派生基本概念</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/23%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%B4%BE%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/23%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%B4%BE%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-30T15:09:56.000Z</published>
    <updated>2020-07-30T15:09:56.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;继承：在定义一个新的类&lt;code&gt;B&lt;/code&gt;时，如果该类与某个已有的类&lt;code&gt;A&lt;/code&gt;相似（&lt;code&gt;B&lt;/code&gt;拥有&lt;code&gt;A&lt;/code&gt;的全部特征），那么就可以把&lt;code&gt;A&lt;/code&gt;作为一个&lt;strong&gt;基类&lt;/strong&gt;，而把&lt;code&gt;B&lt;/code&gt;作为基类的一个&lt;strong&gt;派生类&lt;/strong&gt;（也成为子类）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量或成员函数。&lt;/li&gt;
&lt;li&gt;派生类一旦定义后，可以独立使用，不依赖于基类。&lt;/li&gt;
&lt;li&gt;派生类拥有基类的全部成员函数和成员变量。不论是&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;还是&lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在派生类的各个成员函数中，不能访问基类的&lt;code&gt;private&lt;/code&gt;成员&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="继承和派生" scheme="https://www.yurui.tech/tags/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/"/>
    
      <category term="面向对象" scheme="https://www.yurui.tech/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>c++自增自减运算符重载</title>
    <link href="https://www.yurui.tech/2020/07/30/C++/22%E3%80%81c-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/30/C++/22%E3%80%81c-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-30T14:05:51.000Z</published>
    <updated>2020-07-30T14:05:51.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;自增运算符&lt;code&gt;++&lt;/code&gt;以及自减运算符&lt;code&gt;--&lt;/code&gt;有前置、后置之分，为了区分该运算符为前置还是后置，&lt;code&gt;c++&lt;/code&gt;有如下规定：&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="自增运算符" scheme="https://www.yurui.tech/tags/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="自减运算符" scheme="https://www.yurui.tech/tags/%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>c++重载强制类型转换运算符</title>
    <link href="https://www.yurui.tech/2020/07/23/C++/21%E3%80%81c-%E9%87%8D%E8%BD%BD%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://www.yurui.tech/2020/07/23/C++/21%E3%80%81c-%E9%87%8D%E8%BD%BD%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-07-23T14:11:00.000Z</published>
    <updated>2020-07-23T14:11:00.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;强制类型转换运算符是单目运算符，也可以被重载，但&lt;strong&gt;只能重载为成员函数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Complex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; real, imag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Complex(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; r = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) :real(r), imag(i) &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; real; &amp;#125;  &lt;span class=&quot;comment&quot;&gt;//重载强制类型转换运算符 double&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Complex &lt;span class=&quot;title&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)c &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//输出 1.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + c;  &lt;span class=&quot;comment&quot;&gt;//等价于 double n = 2 + c. operator double()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n;  &lt;span class=&quot;comment&quot;&gt;//输出 3.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="类型转换运算符重载" scheme="https://www.yurui.tech/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="()运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>c++流插入和流提取运算符的重载</title>
    <link href="https://www.yurui.tech/2020/07/19/C++/20%E3%80%81c-%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/19/C++/20%E3%80%81c-%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-19T06:48:26.000Z</published>
    <updated>2020-07-19T06:48:26.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;this&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面语句为什么可以成立？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cout&lt;/code&gt;是什么？&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;为什么可以作用在&lt;code&gt;cout&lt;/code&gt;上？&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="左移运算符重载" scheme="https://www.yurui.tech/tags/%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="右移运算符重载" scheme="https://www.yurui.tech/tags/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="流插入运算符" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="流提取运算符" scheme="https://www.yurui.tech/tags/%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>c++运算符重载为友元函数</title>
    <link href="https://www.yurui.tech/2020/07/14/C++/19%E3%80%81c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83/"/>
    <id>https://www.yurui.tech/2020/07/14/C++/19%E3%80%81c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83/</id>
    <published>2020-07-14T14:53:52.000Z</published>
    <updated>2020-07-14T14:53:52.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，将运算符重载为成员函数是比较好的选择。&lt;/p&gt;
&lt;p&gt;但有时候，重载为成员函数又不能满足需求，重载为普通函数，又不能访问类的私有成员，这时我们就需要将运算符重载为友元。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="友元" scheme="https://www.yurui.tech/tags/%E5%8F%8B%E5%85%83/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>c++赋值运算符的重载</title>
    <link href="https://www.yurui.tech/2020/07/14/C++/18%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.yurui.tech/2020/07/14/C++/18%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2020-07-14T06:23:09.000Z</published>
    <updated>2020-07-14T06:23:09.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;赋值运算符重载需求&quot;&gt;&lt;a href=&quot;#赋值运算符重载需求&quot; class=&quot;headerlink&quot; title=&quot;赋值运算符重载需求&quot;&gt;&lt;/a&gt;赋值运算符重载需求&lt;/h1&gt;&lt;p&gt;有时候我们希望运算符两边的类型可以不匹配。比如，把一个&lt;code&gt;int&lt;/code&gt;类型的变量赋值给一个对象，或者把&lt;code&gt;char*&lt;/code&gt;类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://www.yurui.tech/categories/c/"/>
    
    
      <category term="c++" scheme="https://www.yurui.tech/tags/c/"/>
    
      <category term="赋值运算符重载" scheme="https://www.yurui.tech/tags/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="运算符重载" scheme="https://www.yurui.tech/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
</feed>
