<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++位运算</title>
    <url>/2020/02/26/C++/C-C-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据在计算机中是按二进制的形式存在的，通过普通的四则运算我们能对这些数据做一些简单的运算。但当我们想修改某个数据中的某一位，我们就需要用到位运算。</p>
<p>例如：<code>666</code>的二进制为<code>‭0001101000001010‬</code>，如果我们需要知道或者修改最高位，此时我们就无法通过一般的方法来对其进行操作，就需要用到位运算符。</p>
<a id="more"></a>
<p>在许多古老的微处理器上，位运算比加减运算略快，通常位运算比乘除法运算要快很多。在现代架构中，情况并非如此：位运算的运算速度通常与加法运算相同（仍然快于乘法运算）。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p> 用于对程序变量(int、char、long)中的某一位(bit)或多位进行操作,位运算有两种常用的方式如下：</p>
<ol>
<li>判断某一位是否为0/1</li>
<li><p>只改变其中某一位或多位，而其他位不变</p>
<p><code>c/c++</code>提供了六种位运算符来进行位操作：</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">运算方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与(双目运算符)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>按位或</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">按位非(取反)</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">右移</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c语言位运算</tag>
        <tag>c++位运算</tag>
        <tag>按位运算</tag>
        <tag>按位与</tag>
        <tag>按位或</tag>
        <tag>按位异或</tag>
        <tag>移位运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++函数指针</title>
    <url>/2020/02/25/C++/C-C-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>指针</strong>是用来在程序中指向某一个变量的，实际上指针内存放的就是一个变量的相对内存地址（实际的物理地址还要加上一个偏移值）。</p>
<p>在程序运行期间，每个函数都会占用一段连续的内存空间，而函数名就是该函数所占内存空间的起始地址（入口地址），我们可以将一个函数的起始地址赋值给一个指针，进而通过该指针来调用函数，这就是函数指针。</p>
<a id="more"></a>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。在如 <code>C</code>这样的语言中，通过提供一个简单的选取、执行函数的方法，函数指针可以简化代码。函数指针只能指向具有特定特征的函数。因而所有被同一指针运用的函数必须具有<strong>相同的参数和返回类型</strong>。</p>
<p>C语言标准规定，函数指示符（function designator，即函数名字）既不是左值，也不是右值。但C++语言标准规定函数指示符属于左值，因此函数指示符转换为函数指针的右值属于左值转换为右值。</p>
<p>除了作为<code>sizeof</code>或取地址&amp;的操作数，函数指示符在表达式中自动转换为函数指针类型右值。因此通过一个函数指针调用所指的函数，不需要在函数指针前加取值或反引用（*）运算符。</p>
<h1 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h1><p>对于一个函数指针，我们采用如下的定义方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值 (* 指针变量名)(参数类型1，参数类型2，······)</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (* pf)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><br>其中，</p>
<p><strong>返回值</strong>：函数返回的数据类型</p>
<p><strong>指针变量名</strong>:函数指针变量名</p>
<p><strong>参数类型</strong>：函数的参数类型</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//返回两个数中的最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个函数指针pf</span></span><br><span class="line">	<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">//让pf指向min函数</span></span><br><span class="line">	pf = <span class="built_in">min</span>;</span><br><span class="line">	<span class="comment">//通过函数名调用min函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"min=%d\n"</span>, <span class="built_in">min</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//通过函数指针pf调用min函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pf=%d\n"</span>, pf(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行上面的程序，我们得到了以下结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min=10</span><br><span class="line">pf=10</span><br></pre></td></tr></table></figure><br>从结果中我们可以看出两种调用方式得到了一样的结果。接下来我们进而修改一下上面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//返回两个数中的最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个函数指针pf</span></span><br><span class="line">	<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">//让pf指向min函数</span></span><br><span class="line">	pf = <span class="built_in">min</span>;</span><br><span class="line">	<span class="comment">//获取min函数的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"min=  %p\n"</span>, &amp;<span class="built_in">min</span>);</span><br><span class="line">	<span class="comment">//查看函数指针pf内的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pf=   %p\n"</span>, pf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，我们得到下面的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min&#x3D;  001C1221</span><br><span class="line">pf&#x3D;   001C1221</span><br></pre></td></tr></table></figure><br>从结果我们可以明显的看出<code>pf</code>函数中存放的确实是<code>min</code>的地址。</p>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>在<strong>C语言</strong>中，有一个常用的快速排序库函数，能够对任意的数组以任意规则进行排序，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nitems, <span class="keyword">size_t</span> <span class="built_in">size</span>, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span>*))</span></span></span><br></pre></td></tr></table></figure>
<p>其中，</p>
<p><code>base</code>为将要排序的数组的首地址</p>
<p><code>nitems</code>为由<code>base</code>指向的数组的元素个数</p>
<p><code>size</code>为该数组中每个元素的大小</p>
<p><code>compar</code>为排序规则函数，其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 函数名(const void *elem1,const void *elem2);</span><br></pre></td></tr></table></figure>
<p>该函数的返回值有三种情况：</p>
<p>1.返回<code>负整数</code>：<code>*elem1</code>排在<code>*elem2</code>前面</p>
<p>2.返回<code>0</code>： <code>*elem1</code>和<code>*elem2</code>谁在前面都可以</p>
<p>3.返回<code>正整数</code>：<code>*elem1</code>排在<code>*elem2</code>后面</p>
<p>下面我们来考察一个实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCompar</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;<span class="comment">//排序规则函数</span></span><br><span class="line">    <span class="comment">//由于*a和*b是两个无类型的地址，</span></span><br><span class="line">    <span class="comment">//在使用之前我们先将其强制类型转换为int*，</span></span><br><span class="line">    <span class="comment">//然后再取其值进行比较</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123; <span class="number">23</span>, <span class="number">6</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序之前的列表：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用qsort进行排序</span></span><br><span class="line">    qsort(values, <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), myCompar);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n排序之后的列表：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上程序，我们得到下面所示结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序之前的列表：</span><br><span class="line">23 6 100 2 25</span><br><span class="line">排序之后的列表：</span><br><span class="line">2 6 23 25 100</span><br></pre></td></tr></table></figure><br>经过qsort调用mycompar函数后成功升序地将数组进行了排序</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
        <tag>c语言函数指针</tag>
        <tag>c++函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ const关键字使用</title>
    <url>/2020/05/31/C++/C-const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="const定义常量"><a href="#const定义常量" class="headerlink" title="const定义常量"></a><code>const</code>定义常量</h1><p>在c语言中，我们学习过可以使用<code>#define</code>来定义常量。但是<code>#define</code>的原理是简单的替换，因此对于<code>#define</code>来说没有类型检查这回事。</p>
<p>c++中提供了<code>const</code>关键字，用<code>const</code>关键字修饰的变量其值是不能修改的，因此可以使用<code>const</code>关键字来替换<code>#define</code>，这有益于编译器进行类型检查。</p>
<a id="more"></a>
<p><code>const</code>关键字定义变量如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> NAME[] = <span class="string">"yurui"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MAX = PI;<span class="comment">//报错</span></span><br><span class="line">	<span class="keyword">int</span> a = PI;<span class="comment">//警告</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序所示，使用<code>const</code>关键字定义了<code>MAX</code>、<code>PI</code>、<code>NAME</code>三个全局变量。</p>
<p>通过<code>MAX = PI;</code>对const修饰的变量进行赋值时会报错；通过<code>int a = PI;</code>进行赋值时编译系统会给出警告，提示类型不符合。</p>
<p>通过上面的例子，我们可以看出，通过使用<code>const</code>关键字修饰常量，在使用时编译系统会进行类型检查。</p>
<h1 id="const定义常量指针"><a href="#const定义常量指针" class="headerlink" title="const定义常量指针"></a><code>const</code>定义常量指针</h1><p>通过<code>const</code>关键字定义常量指针，这样就不能通过指针修改变量的值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	*p = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">    a = <span class="number">100</span>;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的程序，定义常指针<code>p</code>,当我们通过<code>p</code>去修改其所指向的值时，编译器就会对其报错。</p>
<p>但通过变量名还是可以修改其值，如<code>a = 100;</code>。</p>
<p>另外，观察下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* a;</span><br><span class="line">	<span class="keyword">int</span>* b;</span><br><span class="line">	a = b;<span class="comment">//正确</span></span><br><span class="line">	b = a;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于常指针，我们可以直接对其赋值，如<code>a = b;</code>；对于非常量指针，我们不能使用常量指针对其进行赋值，如<code>b = a;</code>。</p>
<h1 id="const修饰引用对象"><a href="#const修饰引用对象" class="headerlink" title="const修饰引用对象"></a><code>const</code>修饰引用对象</h1><p>引用也可以用<code>const</code>关键字修饰，这样就不能通过引用名来修改变量值了。</p>
<p>如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; r = a;</span><br><span class="line">    a = <span class="number">10</span>;<span class="comment">//正常</span></span><br><span class="line">	r = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>r=10;</code>这条语句时编译器会报错，提示<strong>表达式必须是可修改的左值</strong>，因为我们再初始化引用时将其加上了了<code>const</code>关键字，我们就不能通过引用名来修改变量的值了。</p>
<p>对于<code>a = 10;</code>这条语句则执行正常，因为a没有<code>const</code>关键字修饰。</p>
<p>再考量下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;<span class="comment">//错误</span></span><br><span class="line">	r = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	a = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于用<code>const</code>关键字修饰的变量，我们在为其创建引用对象时，任然需要创建<code>const</code>类型的引用对象，且无法通过变量名或引用名来修改变量的值。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>const</tag>
        <tag>const关键字</tag>
        <tag>常引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态内存分类(new/delete)</title>
    <url>/2020/05/31/C++/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB-new-delete/</url>
    <content><![CDATA[<h1 id="使用new运算符分配一个变量"><a href="#使用new运算符分配一个变量" class="headerlink" title="使用new运算符分配一个变量"></a>使用<code>new</code>运算符分配一个变量</h1><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T;</span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>是任意类型名，<code>P</code>是类型为<code>T*</code>的指针。</p>
<p>使用该表达式动态分配出一片大小为<code>sizeof(T)</code>字节的内存空间。并且将该内存空间的其实地址赋值给<code>P</code>。<br><a id="more"></a><br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*p = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，为<code>p</code>动态分配了<code>sizeof(int)</code>大小的空间，并将起始地址赋值给了<code>p</code>。</p>
<h1 id="使用new运算符分配一个数组"><a href="#使用new运算符分配一个数组" class="headerlink" title="使用new运算符分配一个数组"></a>使用<code>new</code>运算符分配一个数组</h1><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>是任意类型名，<code>P</code>是类型为<code>T*</code>的指针，<code>N</code>是要分配的数组元素的个数，<code>N</code>可以是表达式。</p>
<p>使用该表达式动态分配出<code>N*sizeof(T)</code>字节的内存空间，并将起始地址渎职给<code>P</code>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">9</span>] = <span class="number">10</span>;</span><br><span class="line">	p[<span class="number">10</span>] = <span class="number">10</span>;<span class="comment">//越界</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，为<code>p</code>动态分配了<code>10 * sizeof(int)</code>大小的空间，并将起始地址赋值给了<code>p</code>。</p>
<p>为数组分配完空间后就可以像访问数组一样访问该指针。但是需要注意的是在执行<code>p[10] = 10;</code>时会导致数组越界，编译器又可能不会报错。</p>
<h1 id="使用delete运算符释放动态分配的内存"><a href="#使用delete运算符释放动态分配的内存" class="headerlink" title="使用delete运算符释放动态分配的内存"></a>使用<code>delete</code>运算符释放动态分配的内存</h1><p>使用<code>new</code>运算符动态分配的内存空间，一定要使用<code>delete</code>运算符进行释放。</p>
<h2 id="delete变量"><a href="#delete变量" class="headerlink" title="delete变量"></a><code>delete</code>变量</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> 指针;<span class="comment">//该指针必须指向new出来的空间</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//报错，只能delete一次</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>delete</code>时只能对同一片空间使用一次<code>delete</code>，否则将会报错，如上程序所示。</p>
<h2 id="delete数组"><a href="#delete数组" class="headerlink" title="delete数组"></a><code>delete</code>数组</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []指针;<span class="comment">//该指针必须指向new出来的空间</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>delete</code>释放动态分配的数组时，要添加<code>[]</code>。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">delete</span> []p;</span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//错误,只会释放第一个元素的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>delete []p;</code>来正确释放动态分配的内存空间，指针前有<code>[]</code>符；当使用<code>delete p;</code>时，将导致该数组的首元素空间被释放，而其余空间未被释放，形成“野指针”。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>内存分配</tag>
        <tag>new关键字</tag>
        <tag>delete关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内联函数inline</title>
    <url>/2020/06/01/C++/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline/</url>
    <content><![CDATA[<h1 id="inline概念"><a href="#inline概念" class="headerlink" title="inline概念"></a><code>inline</code>概念</h1><p>在<code>c++</code>中，函数调用是会产生额外的时间开销的，如果函数本身代码很短，执行很快，并且该函数被反复调用。相比之下调用函数所产生的开销就会很大，甚至超过执行代码所产生的开销。</p>
<p>为了减少函数调用的开销，<code>c++</code>引入了<code>内联函数</code>的机制。编译器在处理内联函数的调用语句时，直接将整个内联函数代码插入到调用语句处，从而减少函数调用产生的开销。<br><a id="more"></a></p>
<h1 id="inline定义"><a href="#inline定义" class="headerlink" title="inline定义"></a><code>inline</code>定义</h1><p><code>inline</code>关键字的使用比较简单，只需要在函数的定义头部加上<code>inline</code>关键字即可，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> 返回值类型 函数名(参数)&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数的具体使用如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//返回两数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，定义一个内联函数<code>max</code>，该函数返回两个数中的最大值，只需要在函数定义时加入<code>inline</code>关键字即可，在对<code>max</code>函数进行调用时，编译器直接将<code>max</code>的函数代码嵌入到调用的地方，以此来节省函数调用产生的额外开销。</p>
<h1 id="inline函数注意事项"><a href="#inline函数注意事项" class="headerlink" title="inline函数注意事项"></a><code>inline</code>函数注意事项</h1><p>通过上面的例子，我们了解了<code>inline</code>关键字的基本使用方法，内联函数虽然节省了函数调用产生的开销，但并不是所有的地方都能使用内联函数定义。</p>
<p>当函数代码过长时，使用内联函数会使得程序变得臃肿。此时就不应该使用内联函数。</p>
<p>另外，当函数中包含循环控制语句时，也不应该使用内联函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>inline函数</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++引用</title>
    <url>/2020/05/31/C++/C-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h1><p>引用是变量的一个别名，相当于已经存在的变量的另一个名字。引用名与被引用的变量名都指向同一个内存地址。</p>
<h1 id="引用的创建"><a href="#引用的创建" class="headerlink" title="引用的创建"></a>引用的创建</h1><p>引用创建的语法格式如下，其中<code>T</code>为任意类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T &amp;引用名 = 变量名;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//定义r引用a</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//修改a的值</span></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//修改r的值</span></span><br><span class="line">	r = <span class="number">1000</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//用已知变量对r赋值</span></span><br><span class="line">	r = b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//输出a和r的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a的地址为："</span> &lt;&lt; (<span class="keyword">void</span>*)a &lt;&lt; <span class="string">"\tb的地址为："</span> &lt;&lt; (<span class="keyword">void</span>*)b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序，可以得到如下所示的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10    r=10</span><br><span class="line">a=100   r=100</span><br><span class="line">a=1000  r=1000</span><br><span class="line">a=20    r=20</span><br><span class="line">a的地址为：0000000000000014     b的地址为：0000000000000014</span><br></pre></td></tr></table></figure>
<p>通过观察上面的结果，我们可以得知</p>
<ol>
<li>引用必须在定义的时候初始化</li>
<li>引用是始终如一的，即引用了一个变量后就不能再引用其它变量</li>
<li>引用和被引用的变量都指向同一个内存地址</li>
<li>引用只能引用同一种类型的变量，不能引用常量。<code>int a=10;double &amp;b=a;</code>这种引用是非法的，以及<code>int &amp;a=10;</code>也是非法的。</li>
</ol>
<h1 id="常引用（const-amp-）"><a href="#常引用（const-amp-）" class="headerlink" title="常引用（const &amp;）"></a>常引用（const &amp;）</h1><p>引用也可以用<code>const</code>关键字修饰，这样就不能通过引用名来修改变量值了。</p>
<p>如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; r = a;</span><br><span class="line">    a = <span class="number">10</span>;<span class="comment">//正常</span></span><br><span class="line">	r = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>r=10;</code>这条语句时编译器会报错，提示<strong>表达式必须是可修改的左值</strong>，因为我们再初始化引用时将其加上了了<code>const</code>关键字，我们就不能通过引用名来修改变量的值了。</p>
<p>对于<code>a = 10;</code>这条语句则执行正常，因为a没有<code>const</code>关键字修饰。</p>
<p>再考量下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;<span class="comment">//错误</span></span><br><span class="line">	r = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	a = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于用<code>const</code>关键字修饰的变量，我们在为其创建引用对象时，任然需要创建<code>const</code>类型的引用对象，且无法通过变量名或引用名来修改变量的值。</p>
<h1 id="引用的简单实例："><a href="#引用的简单实例：" class="headerlink" title="引用的简单实例："></a>引用的简单实例：</h1><p>在学习<code>C/C++</code>的过程中，我们难免会遇到交换两个变量值的题目。在没有学习引用之前，我们只能通过指针的方式来修改两个变量的值，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写显得很复杂，而且在调用的地方还要通过<code>&amp;</code>符号来对变量进行取地址操作。其实我们可以将函数的两个参数改写为引用，这样就可以简化我们的代码，增强可读性了，改写如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型 &amp;函数名（形参列表）&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>观察如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	setValue() = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后得到如下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n=4</span><br><span class="line">n=10</span><br></pre></td></tr></table></figure>
<p>函数<code>setValue()</code>返回一个全局变量<code>n</code>的引用，然后将函数名作为左值修改n的值。</p>
<p>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></p>
<p>对于引用作为函数返回值，在这里我们可以先不明觉厉。以后会说到。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>c++引用</tag>
        <tag>函数返回值引用</tag>
        <tag>变量引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中cin.getline和cin.get函数的使用</title>
    <url>/2019/09/16/C++/C-%E4%B8%ADgetline%E5%92%8Cget%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在C++中，我们通常使用<code>cin</code>作为输入函数来读取用户键盘输入的数据，由于不能通过键盘来输入空字符，因此<code>cin</code>需要用别的方法来确定字符串结尾位置。<code>cin</code>使用空白、空格、制表符和换行符来确定字符串的结束位置，这意味着<code>cin</code>在读入数据的时候只能截取上述结束符前的数据，对于结束符后的数据讲不能读入程序中。我们来考一个<code>cin</code>读入字符串的实例。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面的程序，当我们输入<code>woody allen</code>时，程序会得到下面的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">您的名字是：woody</span><br></pre></td></tr></table></figure>
<p>我们发现<code>cin</code>函数读入的数据并不完整，在上述样例中输入的名字被空格键截断了，所以cin只读入了一个单词就结束了读入操作。再来考察一个类似实例看看输入缓冲区内发生了什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的地址："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的地址为："</span> &lt;&lt; addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，我们发现，还没对地址输入提示做出反应，程序就把他显示出来了。然后立即显示最后一行。运行结果如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">请输入您的地址：您的名字是：woody</span><br><span class="line">您的地址为：allen</span><br></pre></td></tr></table></figure>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="面向行输入：getline"><a href="#面向行输入：getline" class="headerlink" title="面向行输入：getline()"></a>面向行输入：getline()</h2><p><code>getline()</code>函数读取输入的整行，它使用通过回车键输入的换行符来作为结束符。要调用这种方法可以使用<code>cin.getline()</code>，该函数有两个参数，第一个参数是用来存储输入行的数组名称，另一个参数是要读取的字符串长度，如果参数为30，则最多读取29各字符，最后一个用来存储在字符串末尾的空字符。<br>例如，假设要使用<code>cin.getline()</code>将姓名读入到一个包含30各元素的<code>name</code>数组中，可使用下面这样的函数调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(name,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>这样就可以将一行读入到数组中————如果这一行不超过29个字符(<code>getline()</code>成员函数还可以接受第三个可选参数，在此不做讨论)。现在对上述样例进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(name,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的地址："</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(addr,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的地址为："</span> &lt;&lt; addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中将<code>cin</code>换成了<code>cin.getline()</code>，我们得到了正确的输入如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">请输入您的地址：Guizhou China</span><br><span class="line">您的名字是：woody allen</span><br><span class="line">您的地址为：Guizhou China</span><br></pre></td></tr></table></figure>
<p><code>getline()</code>函数每次读取一行，它通过回车键输入的换行符来确定行尾，但是不保存换行符。相反，在存储字符串时，它用空字符来替换换行符。</p>
<h2 id="面向行的输入get"><a href="#面向行的输入get" class="headerlink" title="面向行的输入get()"></a>面向行的输入get()</h2><p>另外还有一种方法。<code>istream</code>类有另一个名为<code>get()</code>的成员函数，该函数有几种变体，其中一种与<code>getline()</code>类似，他们接受相同的参数，解释参数的方式也相同，都读取到行尾。单<code>get()</code>不再读取并丢弃换行符，而是将其留在输入队列中，假设我们连续两次调用<code>get()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,arrSize);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(addr,arrSize);</span><br></pre></td></tr></table></figure>
<p>运行上诉代码，我们会发现第二行代码并没有读入数据，原因是当第二行代码在读取数据时，把第一行读取的回车符当成了第二个字符串的结束标志，所以接下来的数据都没有读入，一个解决办法是将上诉代码改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,arrSize);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(addr,arrSize);</span><br></pre></td></tr></table></figure>
<p>通过新增的<code>cin.get();</code>先读取上一行留下来的换行符，然后再读取下一个字符串。</p>
<p>另一种使用<code>get()</code>的方法是将两个类成员函数拼接起来使用，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,addr).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>之所以这样做，是由于<code>cin.get(name,addr)</code>返回一个<code>cin</code>对象，该对象随后将被用来调用<code>get()</code>函数，同样，下面语句也能将输入的两行分别读到数组<code>name</code>和<code>addr</code>中，其效果与两次调用<code>cin.getline()</code>相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(name,ArSize).getline(addr,ArSize);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cin.get函数</tag>
        <tag>cin.getline函数</tag>
        <tag>cin.get()</tag>
        <tag>cin.getline()</tag>
        <tag>字符串输入</tag>
      </tags>
  </entry>
  <entry>
    <title>c++函数的缺省参数</title>
    <url>/2020/06/01/C++/c-%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>c++中，定义函数的时候可以让<strong>最右边的连续若干个</strong>参数有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">1</span>, <span class="keyword">int</span> c = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在调用时，如果参数<code>b</code>和<code>c</code>的参数没有给出，则默认为缺省值。</p>
<p>函数缺省参数的作用在于提高程序的<strong>可扩充性</strong>。比如某个以及写好的函数需要添加新的参数，而原先调用函数的的那些语句未必需要新增加的参数，为了避免对原来所有调用该函数的地方进行修改，就可以使用函数缺省参数了。</p>
<h1 id="全缺省"><a href="#全缺省" class="headerlink" title="全缺省"></a>全缺省</h1><p>顾名思义，全缺省就是参数的所有值都为缺省参数，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">2</span>, <span class="keyword">int</span> c = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fun();</span><br><span class="line">    fun(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该程序，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1     b=2     c=3</span><br><span class="line">a=4     b=5     c=6</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们在调用函数时，只能缺省<strong>最右边的若干个参数</strong>，形如：<code>fun(4, , 6);</code>这种调用是错误的调用方法。</p>
<h1 id="半缺省"><a href="#半缺省" class="headerlink" title="半缺省"></a>半缺省</h1><p>半缺省指的是参数中有一部分为缺省参数，有一部分为非缺省参数。</p>
<p>值得注意的是，缺省参数只能为<strong>最右边的若干个</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">2</span>, <span class="keyword">int</span> c = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fun(<span class="number">1</span>);</span><br><span class="line">	fun(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	fun(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面程序，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1     b=2     c=3</span><br><span class="line">a=1     b=4     c=3</span><br><span class="line">a=4     b=5     c=6</span><br></pre></td></tr></table></figure>
<p>形如：<code>void fun(int a=1, int b, int c = 3) { }</code>这样的语句是错误的用法。</p>
<p>形如：<code>fun(1, ,3)</code>这种调用也是错误的。</p>
<p>总之记住，缺省参数只能为最右边的若干个参数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>参数缺省</tag>
        <tag>函数参数缺省</tag>
      </tags>
  </entry>
  <entry>
    <title>c++函数重载</title>
    <url>/2020/06/01/C++/c-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>假设如下函数来比较两个<code>int</code>型数据的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当我们需要再增加一个比较两个<code>double</code>或<code>char</code>类型的数据时，我们的函数名会变得臃肿，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_double</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_char</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要比较更多类型数据的大小时，我们的<code>max_xxx</code>函数会变得越来越多。在进行调用时会越来越麻烦。</p>
<h1 id="函数重载定义"><a href="#函数重载定义" class="headerlink" title="函数重载定义"></a>函数重载定义</h1><p>函数重载指的是一个或多个函数，名字相同，然而参数个数以及参数类型不同，我们就称之为函数重载。</p>
<p>将上面的代码改写为如下形势：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们在调用函数时就不需要用函数名去区分该调用哪个函数，此时程序会根据我们的参数个数以及参数类型去选择调用的函数。</p>
<p>如下函数调用代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">//调用 1</span></span><br><span class="line">	<span class="built_in">max</span>(<span class="string">'a'</span>, <span class="string">'b'</span>);<span class="comment">//调用 3</span></span><br><span class="line">	<span class="built_in">max</span>(<span class="number">2.3</span>, <span class="number">3.2</span>);<span class="comment">//调用 2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序，在执行<code>max(2, 3);</code>时，参数为两个<code>int</code>类型的，所以自动匹配到调用第1个<code>max</code>函数。其他两次调用类似。</p>
<p>函数重载使得函数的命名变得简单，调用过程也变得简洁。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>考察如下函数调用语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.1</span>);</span><br></pre></td></tr></table></figure>
<p>当我们进行上述的函数调用时，就会产生二义性。</p>
<p>此时编译器不知道是将<code>3.1</code>转换为<code>int</code>去调用<code>max(int a, int b)</code> ，还是将<code>2</code>转化为<code>double</code>去调用 <code>max(double a, double b)</code>。</p>
<p>因此，在调用重载函数时要注意去避免产生二义性。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客next主题插入图片问题</title>
    <url>/2019/07/12/hexo%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>最近在使用hexo博客next主题的时候发现kramed渲染器在处理插入的图片时不显示标题描述，仅仅显示图片。例如我通过<code>![描述](url连接)</code>的形式插入一张图片，kramed渲染器将其渲染为下面这样：</p>
<a id="more"></a>
<figure><img src="https://raw.githubusercontent.com/yurui105/image/master/blogs_image/%E6%9C%AA%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0.jpg" alt="未显示图片描述.jpg"><figcaption>"未显示图片描述"</figcaption></figure>

<p>并未将图片的描述显示在下方，这对于在文中想要引用插入的图片变得尤为困难，搜索引擎也没有找到相关的问题以及解决办法（也许是我搜索引擎用的不是很好^^）。<br>在查看了渲染出来的网页后，发现kramed在渲染图片时将<code>[]</code>中的的图片描述渲染为了 <code>alt</code>属性，这是图片加载错误时显示的替补文字，按照 <a href="https://github.com/iissnan/hexo-theme-next/issues/436" target="_blank" rel="noopener">hexo-theme-next #436</a>中的方法找到<code>var imageTitle = $image.attr(&#39;title&#39;);</code>，将其中的<code>title</code>改为<code>alt</code>，但是任然无法解决问题。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>查看其它网站的图片对于的<code>html</code>源码发现，在插入图片之后，图片的部分代码为：<br><code>&lt;figure&gt;&lt;img src=&quot;URL&quot; alt=&quot;未正常显示图片描述&quot;&gt;&lt;figcaption&gt;&quot;图片描述&quot;&lt;/figcaption&gt;&lt;figure&gt;</code>而kramed渲染出来的格式为：<br><code>&lt;img src=&quot;URL&quot; alt=&quot;未显示图片描述&quot;&gt;</code><br>发现少了一对<code>&lt;figure&gt;</code>和一对<code>&lt;figcaption&gt;</code>标签，从这个思路出发，Google后发现，<code>&lt;figure&gt;</code> 标签是 <code>HTML5</code> 中的新标签，用作文档中插图的图形，其基本用法为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> <span class="attr">alt</span>=<span class="string">"未显示图片描述"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>src</code>为图片的地址。</li>
<li><code>width</code>为图片显示宽度。</li>
<li><code>height</code>为图片显示高度。</li>
<li><code>alt</code>为未正常显示图片时的描述</li>
</ul>
<p><code>width</code>和<code>height</code>参数可以不写，这样会保持图片原有比例，进一步查看后了解到，<code>&lt;figcaption&gt;</code> 标签也是 <code>HTML5</code> 中的新标签，是与其相关联的图片的说明/标题，用于描述其父节点 <code>&lt;figure&gt;</code> 元素里的其他数据。基本用法为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> <span class="attr">alt</span>=<span class="string">"未显示图片描述"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图片描述/说明<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="更改图片插入格式"><a href="#更改图片插入格式" class="headerlink" title="更改图片插入格式"></a>更改图片插入格式</h2><p>有了这些概念后，既然markdown支持<code>html</code>语法，通过改变图片的插入方式以及增加适当的标签，就可以正常地渲染出图片描述了，通过这个构思，开始着手改进。我用的编辑器是<code>visual studio code</code>，markdown文件也是在里面编辑，图片通过PicGo上传至GitHub图床。<br>首先设置PicGo的输出格式，先来看PicGo的说明</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Picgo:</span> <span class="string">Custom</span> <span class="string">Output</span> <span class="string">Format</span></span><br><span class="line"><span class="string">Customize</span> <span class="string">the</span> <span class="string">output</span> <span class="string">format</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image.</span></span><br><span class="line"><span class="string">$&#123;url&#125;:</span> <span class="string">the</span> <span class="string">url</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image.</span></span><br><span class="line"><span class="string">$&#123;uploadedName&#125;:</span> <span class="string">the</span> <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image,</span> <span class="attr">see Picgo:</span> <span class="string">Custom</span> <span class="string">Upload</span> <span class="string">Name.</span></span><br><span class="line"><span class="attr">Examples:</span></span><br><span class="line"><span class="string">![$&#123;uploadedName&#125;]($&#123;url&#125;)</span> <span class="string">-&gt;</span> <span class="string">![picName-2016-07-25](https://example.com/xxx.jpg)</span></span><br><span class="line"><span class="string">&lt;img</span> <span class="string">src="$&#123;url&#125;"</span> <span class="string">alt="$&#123;uploadedName&#125;"&gt;</span> <span class="string">-&gt;</span> <span class="string">&lt;img</span> <span class="string">src="https://example.com/xxx.jpg"</span> <span class="string">alt="picName-2016-07-25"&gt;</span></span><br></pre></td></tr></table></figure>
<p>有几个参数要注意，<code>url</code>是图片的地址，<code>uploadedName</code>是图片上传时的图片标题，上面给出了基本使用样例。我们想得到的一个格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片URL"</span> <span class="attr">alt</span>=<span class="string">"未显示图片时的描述"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图片描述/说明<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们需要一个这样的基本格式，于是将输出格式改为下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;url&#125;"</span> <span class="attr">alt</span>=<span class="string">"$&#123;uploadedName&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>"$&#123;uploadedName&#125;"<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加一对<code>&lt;figure&gt;</code>标签和一对<code>&lt;figcaption&gt;</code>标签，将图片名用作描述/说明文字，这样就解决了插入格式问题，只要通过PicGo上传图片，就自动导出连接格式。</p>
<h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><p>但是还有一个问题是，图片增加了两队标签，看似可以解决问题，然而hexo是通过渲染器（我用的是kramed）将markdown文件渲染为html文件。在渲染的时候渲染器将无法通过CSS渲染<code>&lt;figcaption&gt;</code>标签，这样最终显示出来的图片虽然显示了描述/说明，但是描述和普通文本并没有什么区别，不会在图片下方居中，看不出和图片有啥联系。这时候通过修改<code>themes\next\source\css\_common\components\post\post.styl</code>文件，往里面增加<code>&lt;figcaption&gt;</code>的css样式为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">figcaption</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#808080;</span></span><br><span class="line">    <span class="attr">font:</span> <span class="string">italic</span> <span class="string">16px</span> <span class="string">arial</span> <span class="string">smaller</span> <span class="string">sans-serif;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="string">0px;</span></span><br><span class="line">    <span class="attr">text-align:</span> <span class="string">center;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>color</code>为描述文字的颜色</li>
<li><code>font</code>为字体属性</li>
<li><code>padding</code>为离图片的距离</li>
<li><code>text-align</code>为文字对齐方式，<code>center</code>为居中显示</li>
</ul>
<p>保存之后执行<code>hexo clean</code>清除，然后执行<code>hexo g</code>重新渲染，就可以看到图片的描述正常显示了。如下图：</p>
<figure><img src="https://raw.githubusercontent.com/yurui105/image/master/blogs_image/%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0.jpg" alt="正常显示图片描述.jpg"><figcaption>"正常显示图片描述"</figcaption></figure>

<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>[1]  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure" target="_blank" rel="noopener">figure：可附标题内容元素</a></p>
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>next主题</tag>
        <tag>图片问题</tag>
        <tag>markdown插入图片</tag>
        <tag>hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装基本工具及基本命令的使用</title>
    <url>/2019/12/25/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/3%E3%80%81%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在上期文章中，我们完成了Ubuntu的硬盘安装，本期文章将说明基本linux的命令使用以及基本基本工具的安装使用。如果你有过相关linux的使用经验，那么本文纯属在浪费你的时间，你可以选择跳过此篇文章。</p>
<p>就这样，请拥有，并享受。<br><a id="more"></a></p>
<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>安装完成后开启电脑，会进入到ubuntu的桌面，我们在屏幕任意位置点击右键，选择Open Terminal来打开一个终端，以后我们的所有工作将在这个终端内完成。</p>
<p>本系列文章不探讨相关实现原理，仅为演示，如何关注的话可以去看linux系统的相关知识。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20214716.jpg" alt="terminal"></p>
<p>更改软件源<br>step1.在终端中敲入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>
<p>然后输入密码，将权限切换到root权限。（输入的密码不会显示，该密码为用户密码）</p>
<p>完成后你会发现前面的提示符由用户名变为了root，这样就可以了。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20215409.jpg" alt="切换权限"></p>
<p>然后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>然后将打开的文本替换为网站<a href="https://developer.aliyun.com/mirror中ubuntu" target="_blank" rel="noopener">https://developer.aliyun.com/mirror中ubuntu</a> 18.04(bionic) 配置的内容，注意选择对应的版本。然后保存。</p>
<p>（注！！在ubuntu中粘贴快捷键为Shift+Insert）<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E9%98%BF%E9%87%8C%E4%BA%91%E8%BD%AF%E4%BB%B6%E5%9B%AD.jpg" alt="阿里云软件源"></p>
<h2 id="基本工具安装"><a href="#基本工具安装" class="headerlink" title="基本工具安装"></a>基本工具安装</h2><p>完成后回到终端，依次执行以下语句，在此对语句做简要说明，如不关注可忽略，直接执行即可。</p>
<p>(注意语句之间的空格不可忽略)</p>
<p>apt是ubuntu中的包管理工具，通过apt命令来管理软件。</p>
<p>step1.更新软件源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>step2.升级软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt -y upgrade</span><br></pre></td></tr></table></figure>
<p>step3.安装vim文本编辑器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y vim</span><br></pre></td></tr></table></figure>
<p>step4.安装ssh远程连接工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y openssh-server</span><br></pre></td></tr></table></figure>
<p>step5.安装网络工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y net-tools</span><br></pre></td></tr></table></figure>
<p>step6.查看IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20222141.jpg" alt="查看ip"></p>
<p>我的网卡在这里为ens33，记住后面的IP地址，不同的机器会有不同的IP。</p>
<p>到这里你就可以扔掉nas的显示器了，接下来的所有操作将会用远程主机连接nas进行操作。</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p>ubuntu不同于windows操作系统，需要具有一定的动手能力，毕竟鼠标那一套在这不好使，在这里我们将介绍相关的一些基本命令使用。</p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><p>在这里不想展开详述linux的相关知识，我也没法把详细的内容说清楚，毕竟那是一个厚几百到几千页的书，如果关注的话可以自行进一步了解。</p>
<p>首先需要知道根目录，也就是<code>/</code></p>
<p>这是linux最为重要的东西，没有之一。所有目录都是由根目录衍生出来的；根目录与系统的开机、修复、还原密切相关；</p>
<p>下面这些内容并不需要你去记住，你只需要知道有这么个东西即可</p>
<p><code>/bin/</code>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</p>
<p><code>/boot/</code>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</p>
<p><code>/dev/</code>设备文件保存位置</p>
<p><code>/etc/</code>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</p>
<p><code>/home/</code>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</p>
<p><code>/lib/</code>系统调用的函数库保存位置</p>
<p><code>/mnt/</code>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</p>
<p><code>/opt/</code>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件</p>
<p><code>/root/</code> root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下/sbin/保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</p>
<p><code>/tmp/</code>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</p>
<h2 id="基本命令使用"><a href="#基本命令使用" class="headerlink" title="基本命令使用"></a>基本命令使用</h2><ol>
<li><p>cd命令<br>cd命令用来在上面这些目录之间切换，用法为cd+路径，例如要到/mnt目录中<code>cd /mnt</code></p>
</li>
<li><p>ls命令<br>ls是显示当前路径中的文件和文件夹的，直接输入ls即可</p>
</li>
<li><p>vim编辑器使用<br>参考：点击这里<br>知道<strong>-i插入</strong>、<strong>:wq保存退出</strong>即可</p>
</li>
</ol>
<p>专栏目录<br>注！[✔]表示已更新，[✖] 表示未更新</p>
<p>[✔] 前言</p>
<p>[✔] Ubuntu18.04的安装</p>
<p>[✔] Ubuntu18.04基本软件安装及使用</p>
<p>[✖] Docker安装</p>
<p>[✖] 控制面板</p>
<p>[✖] jellyfin影音服务</p>
<p>[✖] 网盘服务</p>
<p>[✖] 下载工具</p>
<p>[✖] 笔记管理</p>
<p>[✖] 手机开关机</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04配置</tag>
        <tag>Ubuntu配置</tag>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04安装</title>
    <url>/2019/12/24/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/2%E3%80%81Ubuntu18.04%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文为系列文章的第二篇，关于本专栏相关文章可以到文末专栏目录查看。</p>
<p>就这样，请拥有，并享受。<br><a id="more"></a></p>
<h1 id="制作安装镜像"><a href="#制作安装镜像" class="headerlink" title="制作安装镜像"></a>制作安装镜像</h1><h2 id="下载操作系统镜像"><a href="#下载操作系统镜像" class="headerlink" title="下载操作系统镜像"></a>下载操作系统镜像</h2><p>首先到Ubuntu中国官网下载最新版本的Ubuntu18.04桌面版</p>
<p>下载传送门：点击这里</p>
<p>step1.点击桌面系统<br><img src="https://raw.githubusercontent.com/yurui105/image/master/0.jpg" alt="ubuntu首页"></p>
<p>step2.点击下载Ubuntu<br><img src="https://raw.githubusercontent.com/yurui105/image/master/1.jpg" alt="桌面系统主页"></p>
<p>step3.点击Ubuntu18.04.3 LTS后面的直接下载<br><img src="https://raw.githubusercontent.com/yurui105/image/master/2.jpg" alt="下载界面"></p>
<p>在写文章时的官方最新版本为18.04.3，具体可能会有变化。</p>
<p>LTS为官方长期支持版本，你也可以选择下载最新的试用版本，具体看个人怎么选择，官方也对各版本有详细的说明。个人建议选择LTS版本。</p>
<p>注！可以选择BT下载，这样下载速度会比较快。</p>
<h2 id="下载启动盘制作工具"><a href="#下载启动盘制作工具" class="headerlink" title="下载启动盘制作工具"></a>下载启动盘制作工具</h2><p>制作启动盘的工具市面上有很多，可以参考网络上其他同类文章，这里选择用UltraISO作为制作工具。</p>
<p>UltraISO传送门：点击这里</p>
<p>step1.点击导航栏<strong>下载</strong><br><img src="https://raw.githubusercontent.com/yurui105/image/master/4%E3%80%81ultraiso.jpg" alt="UltraISO官网主页"></p>
<p>step2.点击<strong>免费下载试用</strong><br><img src="https://raw.githubusercontent.com/yurui105/image/master/5.jpg" alt="下载界面"></p>
<p>step3.安装</p>
<p>这里就部展开详述了，安装完成后打开，会跳出窗口订购，在这里点击下方的试用即可。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20115307.jpg" alt="UltraISO订阅界面"></p>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>重要！！！制作U盘安装工具会擦除U盘所有数据，请提前备份好U盘数据！！！</p>
<p>step1.打开刚才下载的Ubuntu安装镜像<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20115730.jpg" alt="UltraISO软件界面"><br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20115759.jpg" alt="加载安装镜像后"></p>
<p>step2.安装镜像文件到U盘</p>
<p>注：一下操作会擦除U盘数据，请做好备份。</p>
<p>点击菜单栏启动—&gt;写入硬盘镜像</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20115816.jpg" alt="制作镜像启动"></p>
<p>之后会跳出一个窗口，磁盘驱动器处选择要作为启动盘的U盘，其它选项默认，然后点击写入，整个过程会持续几分钟，待进度条跑完后及完成（注意错误提示，并在网上寻求解决方案）。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20115857.jpg" alt="镜像写入"></p>
<p>到此不出意外的话整个启动U盘就制作好了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>接下来你需要设置主板从U盘启动，不同的主板设置不一样，在此不做任何操作说明，具体你可以百度主板型号+U盘启动来寻找你主板对应的设置方法。</p>
<p>从U盘启动后，会看到下图的界面，全部默认，点击install ubuntu（安装ubuntu）</p>
<p>（你也可以选择其他语言，但是建议选择英文，中文安装后在后续的操作目录切换中特别麻烦，你还需要安装一个中文编译器，但是相信我，作为nas的操作系统，你需要中文输入的地方很少，尤其是对于linux，只会增加一些没用且繁琐的折腾，所以选择英文就好）<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20170625.jpg" alt="Welcome界面"></p>
<p>之后选择键盘和布局，这里默认就好，然后点击continue（继续）。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20170644.jpg" alt="​选择键盘和布局"></p>
<p>之后跳转到​下图界面，选择Minimal installation（最小化安装）即可，Normal installation（正常安装）提供了较为完整的软件，但那些都是我们用不到的东西。</p>
<p>Download updates while installing Ubuntu（安装过程中更新软件）选上这个会在安装的过程中更新软件包，会增加安装时间。可以在后续安装完成后更新。</p>
<p>install third-party software······这个选项勾上，会为你安装硬件驱动等，减少后期工作量。</p>
<p>完成后点击continue</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20170709.jpg" alt="​更新以及第三方软件"></p>
<p>之后选择安装类型，如果你懒得折腾，选择默认的即可，你也可以选择Something else来自定义安装，如果你没有相关linux基础，建议选择默认，如果你有相关基础，相信你会自己做出选择。</p>
<p>然后点击continue<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20170730.jpg" alt="​安装类型"></p>
<p>这里提示你会擦除硬盘内容，叫你确认。</p>
<p>没有其他任何问题的话这里选择continue<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20171232.jpg" alt="​确认框"></p>
<p>之后选择时区，选择shanghai即可，然后continue。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20171313.jpg" alt="选择时区"></p>
<p>下面进行用户配置</p>
<p>your name：用户名</p>
<p>your computer name：计算机名</p>
<p>pick a username：登录用户名（不要为中文）</p>
<p>choose a password：密码</p>
<p>confirm your password：确认密码</p>
<p>然后勾选下面的log in automatically，点击continue<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20171349.jpg" alt="用户信息​"></p>
<p>之后进入到漫长的安装过程，只需等待即可，整个过程看你的网络情况，从几十分到几小时不等，ubuntu服务器在国外，访问会比较慢，可以使用梯子。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20171407.jpg" alt="安装过程"></p>
<p>安装完成后会跳出一个弹窗，这里选择restart now（重启）</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-23%20175101.jpg" alt="重启界面"></p>
<p>好了，到这里这个安装过程就结束了，而折腾的真个nas过程也就完成了60%了。</p>
<p>是不是很兴奋。</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1><p>注！[✔]表示已更新，[✖] 表示未更新</p>
<p>[✔] 前言</p>
<p>[✔] Ubuntu18.04的安装</p>
<p>[✖] Linux的基本操作</p>
<p>[✖] 基本工具安装及使用</p>
<p>[✖] Docker安装</p>
<p>[✖] 控制面板</p>
<p>[✖] jellyfin影音服务</p>
<p>[✖] 网盘服务</p>
<p>[✖] 下载工具</p>
<p>[✖] 笔记管理</p>
<p>[✖] 手机开关机</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>Ubuntu18.04安装</tag>
        <tag>Ubuntu安装</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH工具Xshell的安装以及使用</title>
    <url>/2019/12/26/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/4%E3%80%81SSH%E5%B7%A5%E5%85%B7Xshell%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在原本的计划中并没有准备专门写一篇关于SSH远程连接的教程，但想了想，该专栏文章应该致力于让所有读者都能看懂，即使你是从未使用过Linux操作系统的小白。</p>
<p>当然，本文仅介绍了XShell的试用，你也可以选择其他软件，这都一样，并不影响你的使用。</p>
<p>如果你已经有相关的使用经验，那么你可以直接跳过本章，毕竟下面的内容会浪费你宝贵生命中的几分钟。</p>
<p>就这样，请拥有，并享受。<br><a id="more"></a></p>
<h1 id="下载Xshell"><a href="#下载Xshell" class="headerlink" title="下载Xshell"></a>下载Xshell</h1><p>首先到XShell的官网：<a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">点击这里</a>点击<strong>下载</strong>按钮，之后会跳转到一个信息填写页面，可以申请30天的免费试用。作为学校和家庭用户，点击右边的<a href="https://www.netsarang.com/zh/free-for-home-school/" target="_blank" rel="noopener"><strong>免费授权页面</strong></a>可以申请免费使用。</p>
<p>填写完信息后下载链接会发送到你所填写的邮箱中，点击里面的下载链接即可下载。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20060647.jpg" alt="Xshell主页"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20060720.jpg" alt="信息填写"></p>
<h1 id="使用Xshell"><a href="#使用Xshell" class="headerlink" title="使用Xshell"></a>使用Xshell</h1><p>下载完成安装后，打开软件可以看到下图所示的页面。<br>（我这里以及添加有很多连接，可以忽略）</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/Xshell%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2.jpg" alt="XShell软件启动"></p>
<p>然后点击对话框左上角添加按钮，在弹出的对话框<strong>名称</strong>处输入你想要的名称，<strong>主机</strong>一栏输入你在<strong>第一篇文章中</strong>所查看的主机<strong>IP</strong></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA.jpg" alt="IP输入"></p>
<p>然后点击界面左边的<strong>用户身份验证</strong>，进入后输入<strong>用户名</strong>和<strong>密码</strong>，该用户名和密码为你在安装Ubuntu时设置的用户名以及密码。</p>
<p>然后点击连接，中途会跳出是否保存用户名密码，自己根据情况选择；在跳出密钥接收保存询问框的时候选择接收并保存。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.jpg" alt="用户名密码输入"></p>
<p>然后看到下如所示的提示信息即说明连接成功。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20062918.jpg" alt="连接成功"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>整个NAS的前期准备工作到此就结束了，在接下来的文章中我们将一同探讨大家比较关心的影音服务、管理面板、网盘工具等内容的搭建了。</p>
<p>前面的文章看起来多少有些无趣，但这却是整个系统管理中不可获缺的。如上面提到的基本命令，这将是你使用频率非常高的命令，甚至可以说这些是你进行接下来的工作不可少的东西，如果你还没有掌握它的话，应该利用闲余的几分钟去了解一下它。</p>
<p>使用Ubuntu的过程中，你或多或少会在搜索引擎中查找相应技术文章，再次过程中你将会感受到计算机专业的开源精神。</p>
<p>但是，在寻求解决方案的时候<strong>请不要轻易尝试别人给你的命令，除非你想把之前的工作从头再来一遍</strong>。执行任何含有<strong>rm</strong>的命令你都应当十分小心地确认你的操作，尤其是在你的数据盘中。</p>
<p>请牢记好上面的内容，<strong>必要的时候请先在虚拟机中验证它的正确性</strong>。</p>
<h1 id="专栏导航"><a href="#专栏导航" class="headerlink" title="专栏导航"></a>专栏导航</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>xshell配置</tag>
        <tag>ssh安装及使用</tag>
        <tag>xshell安装</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB-UI管理面板webmin（轻量级较全面）安装及使用</title>
    <url>/2019/12/27/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/5%E3%80%81WEB-UI%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFwebmin%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BE%83%E5%85%A8%E9%9D%A2%EF%BC%89%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>相信很多人选择黑群晖的原因之一是因为群晖有很好的图形化管理面板，其实Ubuntu，或者说linux也可以很好的图形化管理面板。</p>
<p>本系列文章将介绍两种轻量级的管理面板<strong>Webmin(功能较全面)</strong>和<strong>Cockpit(功能简单)</strong>，对于那些功能全面的重量级面板，再次不做介绍，尽管那些工具开发得很完善，但是在家用nas上使用却显得有些臃肿了。</p>
<p>就这样，请拥有，并享受。<br><a id="more"></a></p>
<h1 id="Webmin安装"><a href="#Webmin安装" class="headerlink" title="Webmin安装"></a>Webmin安装</h1><p>对于Webmin的安装以及使用在它的官网中有详细的介绍，大家可以参考官网。</p>
<p>传送门：<a href="http://www.webmin.com/" target="_blank" rel="noopener">点击这里</a></p>
<ol>
<li>打开xshell并连接到主机，然后切换到<strong>root</strong>用户，执行一下命令下载软件包<br>（我在写文章安装时的版本为1.930，安装时可到官网查看最新版本）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;prdownloads.sourceforge.net&#x2F;webadmin&#x2F;webmin_1.930_all.deb</span><br></pre></td></tr></table></figure>
执行dpkg命令进行安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg --install webmin_1.930_all.deb</span><br></pre></td></tr></table></figure>
提示：在输入时可以使用Tab键进行命令补全。</li>
</ol>
<p>在执行上面的语句时，你可能会得到下面的报错：</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20072855.jpg" alt="缺少编译环境"></p>
<p>这是由于缺少编译环境导致的，输入以下命令安装相关相关工具<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install perl libnet-ssleay-perl openssl libauthen-pam-perl libpam-runtime libio-pty-perl apt-show-versions python</span><br></pre></td></tr></table></figure><br>在输入完上述命令后，可能还会出现一个错误如下：</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20073439.jpg" alt="错误提示"></p>
<p>此时我们按照提示运行输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt --fix-broken install</span><br></pre></td></tr></table></figure><br>然后再运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg --install webmin_1.930_all.deb</span><br></pre></td></tr></table></figure><br>即可安装成功，安装完成后如下图</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20073838.jpg" alt="安装完成"></p>
<p>Webmin默认安装到<code>/usr/share/webmin</code>目录下，我们可以通过<code>https://服务器ip:10000/</code>来登录管理面板；登录密码为<code>root</code>密码或者可以运行<code>sudo su</code>的管理者用户名密码来登录。</p>
<p>（因为Ubuntu不允许使用<code>root</code>来作为默认登录用户，你可以使用其它可以执行<code>sudo su</code>切换到管理员权限的用户名密码来作为登录用户）</p>
<h1 id="Webmin配置"><a href="#Webmin配置" class="headerlink" title="Webmin配置"></a>Webmin配置</h1><p>完成安装后我们用浏览器打开<code>https://服务器ip:10000/</code>来进入管理面板，打开后会跳出一个错误页面，点击提示中的URL链接即可正常进入。<br>（如果浏览器有安全警告，直接跳过继续前往即可）</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20084600.jpg" alt="打开跳转提示"></p>
<p>之后便是登录界面，输入上面提到的用户名密码进行登录</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20084629.jpg" alt="登录"></p>
<p>完成登录后就进入到管理面板的界面了</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20085032.jpg" alt="管理面板界面"></p>
<p>现在界面显示的英文，我们可以到<code>Webmin -&gt; Webmin Configuration -&gt; Language and Locale</code>将语言改为中文，记得保存。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20085522.jpg" alt="更改语言"></p>
<p>我们可以在面板中很直观地查看到系统的相关信息以及进行相关配置。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20085758.jpg" alt="系统监视"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20085945.jpg" alt="网络管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20090041.jpg" alt="磁盘管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20090156.jpg" alt="开关机管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-25%20090317.jpg" alt="进程管理"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Webmin的功能还是比较全面的，可以通过安装模块来扩展功能，支持集群管理等。</p>
<p>到这里本篇文章就结束了，以后就可以通过浏览器来查看以及管理nas了。</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>WEB-UI管理面板</tag>
        <tag>webmin</tag>
        <tag>linux管理面板</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu挂载硬盘</title>
    <url>/2019/12/29/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/7%E3%80%81Ubuntu%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>在开始下篇文章之前我觉得有必要讲解一下在linux中的硬盘挂载。这和Windows不同，Windows会自动扫描本地硬盘并为你自动挂载，但是linux不会值么做，它需要你自己去挂载硬盘到系统中。</p>
<a id="more"></a>
<p>如果你是新硬盘，你需要对硬盘进行格式化才能正常使用，linux支持ext4、NTFS等文件系统，在此建议将硬盘格式化为NTFS格式，这样就算你把硬盘从linux移动Windows环境下也可以正常使用，Windows不知EXT4文件系统。</p>
<p>但是格式化NTFS也会带来一个弊端，就是你无法对文件进行权限操作，这样你在使用的时候应该小心一些，避免误操作删除硬盘数据。</p>
<h1 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h1><p>如果你的硬盘已经格式化过存有数据的话，你应该跳过这一小节的内容，直接跳转到下一小节参考硬盘挂载操作。</p>
<p>首先你需要查看设备位置，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>然后找到你需要挂载的硬盘，例如我在这里要挂载<strong>Disk /dev/sdb: 7.3 TiB</strong>这块磁盘，记下它的位置，这里为/dev/sdb</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20160129.jpg" alt="查看硬盘设备"></p>
<h2 id="格式化为EXT4格式"><a href="#格式化为EXT4格式" class="headerlink" title="格式化为EXT4格式"></a>格式化为EXT4格式</h2><p>如果需要格式化为EXT4格式，只需要执行下面语句即可，将/dev/sdb换成你需要进行格式化操作的设备路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4  &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure></p>
<h2 id="格式化为NTFS"><a href="#格式化为NTFS" class="headerlink" title="格式化为NTFS"></a>格式化为NTFS</h2><p>NTFS是windows的文件系统，在进行格式化操作之前需要安装一个工具，输入下面命令进行安装。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt -y install ntfsprogs</span><br></pre></td></tr></table></figure><br>安装完成后执行格式化语句，这里同样将/dev/sdb更改为你要执行格式化操作的设备路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkntfs -f &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><br>到此就将硬盘格式化完成了，接下来进行挂载操作</p>
<h1 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h1><p>在进行挂载操作之前需要先查看硬盘的UUID值，输入sudo blkid进行查看</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20162314.jpg" alt="UUID值"></p>
<p>这里假设我们要挂载/dev/sdb1: LABEL=”mybook” UUID=”21B724CC1FE1D190” TYPE=”ntfs” ···这块硬盘，我们选中UUID后面的值（不要双引号），在xshell中可以右键复制下来。</p>
<p>然后创建一个挂载点，这个挂载点就是你以后打开查看硬盘内容的地方，这里假设我们需要将硬盘挂载到/mnt/sdb这个路径。你可以选择其他任何一个你觉得可以的地方进行挂载。<br>首先执行<strong>cd /mnt</strong>进入到mnt目录。<br>然后执行<strong>mkdir sdb</strong>创建一个名为sdb的文件夹，这个文件夹为我们需要挂载硬盘的地方。</p>
<p>然后编辑系统挂载配置文件/etc/fstab</p>
<p>执行<strong>vim /etc/fstab</strong>打开配置文件，可以看到下图所示的内容<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20163118.jpg" alt="fstab文件"></p>
<p>这里的格式为<strong>设备名称 挂载点 分区类型 挂载选项 dump选项 fsck选项</strong><br>dump为0表示不进行备份<br>fsck为启动时检查顺序，0为不检查，/更目录为1，其他只能从2开始</p>
<p>添加要挂载的内容到末行，这里我们以刚才的为例<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20163801.jpg" alt="挂载设置"><br>挂载点为我们刚才设置的挂载路径/mnt/sdb，格式为NTFS（如果你格式化为ext4，这里就填ext4），挂载选项默认defaults，不进行备份，开机不检查。</p>
<p>挂载完成后执行<code>reboot</code>命令重启电脑，重启后我们就可以到/mnt/sdb目录下查看硬盘内容了</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20164125.jpg" alt="查看硬盘数据"></p>
<h1 id="查看硬盘使用状态"><a href="#查看硬盘使用状态" class="headerlink" title="查看硬盘使用状态"></a>查看硬盘使用状态</h1><p>除了在WEB-UI管理界面中查看硬盘使用状态，我们也可以在命令行中输入<strong>df -h</strong>查看硬盘使用状态<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20164727.jpg" alt="硬盘使用状态"><br>Size为总分区大小<br>Used为已使用<br>Avail为可用容量<br>Use%为使用百分比<br>Mounted on为挂载点</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>linux硬盘挂载</tag>
        <tag>ubuntu挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB-UI管理面板Cockpit(轻量简单)安装与使用</title>
    <url>/2019/12/28/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/6%E3%80%81WEB-UI%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFCockpit(%E8%BD%BB%E9%87%8F%E7%AE%80%E5%8D%95)%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在前面我们介绍了管理面板Webmin的安装与使用，这次我们来看Cockpit的安装与使用，Webmin与Cockoit都属于轻量级的管理面板，但是Cockpit的功能较Webmin有了更多的减少，提供了更多的图表可视化功能，对中文的支持也比Webmin要好得多。</p>
<p>cockpit提供了几乎所有Linux发行版本的安装包，对各个Linux平台支持都很好，这在官方的宣传里可以看到。该软件为开源软件，并在官网提供了详细的开发者文档。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20141709.jpg" alt="cockpit"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>cockpit的官网提供了各平台的安装方法以及相关的的使用文档，并且在Ubuntu17.04以及之后的Ubuntu版本中加入了官方的软件源中，这意味这我们可以很容易地安装Cockpit。</p>
<p>只需要在终端中执行以下命令即可安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt -y install cockpit</span><br></pre></td></tr></table></figure><br>安装完成后没有给出任何地提示信息，我们只需要用浏览器打开<code>https://服务器IP:9090</code>即可打开监控界面，然后输入ubuntu的用户名密码就可以登录它。<br>（打开过程中浏览器可能会拦截该页面，允许访问即可）</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>在浏览器中打开<code>https://服务器IP:9090</code>后我们可以看到如下画面，输入用户名、密码登录即可。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20141314.jpg" alt="cockpit登录界面"></p>
<p>登录成功后我们就进入道路cockpit的管理界面，在这里可以直观的看到NAS的运行状态，包括CPU使用率、内存使用率、硬盘使用率等。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20141354.jpg" alt="cockpit仪表盘"></p>
<p>下面我们来看看cockpit中有那些功能。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97.jpg" alt="系统日志"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.jpg" alt="存储管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86.jpg" alt="网络管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1.jpg" alt="系统服务"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E4%BB%AA%E8%A1%A8%E7%9B%98.jpg" alt="仪表盘"></p>
<h1 id="cockpit使用"><a href="#cockpit使用" class="headerlink" title="cockpit使用"></a>cockpit使用</h1><p>在cockpit中我们可以很方便的管理各系统服务，下面将介绍一些基本的管理功能</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>在磁盘管理中，为我们提供了图形化创建RAID设备，可支持RAID0、1、4、5、6、10。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20143552.jpg" alt="创建RAID设备"></p>
<p>可以图形化创建磁盘分区表，格式化磁盘。可支持GPT以及MBR分区方式。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20143743.jpg" alt="创建磁盘分区表"></p>
<p>更改磁盘挂载点等</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144009.jpg" alt="磁盘挂载点"></p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>可以添加绑定、添加网桥、划分vlan的网络操作。</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%B7%BB%E5%8A%A0%E7%BB%91%E5%AE%9A.jpg" alt="添加绑定"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144216.jpg" alt="添加网桥"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144227.jpg" alt="VLAN划分"></p>
<p>还可以进行ipv4、ipv6等设置，支持管理连接状态，实时日志查看等</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/ipv4.jpg" alt="IPV4设置"></p>
<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><p>支持查看相关系统服务进程，并支持启用、禁用相关进程。支持定时任务管理等</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144606.jpg" alt="系统服务管理"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144730.jpg" alt="定时任务"></p>
<p>除此之外，还提供了一个终端的功能，可直接在网页中打开终端</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-26%20144908.jpg" alt="终端"></p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>cockpit比webmin要精简很多，去除了很多感觉不要的东西，在我看来是最适合做NAS管理面板的软件，其使用起来也很方便，不需要很复杂的操作就可以管理系统相关服务。对各种数据监控提供了很好的图形可视化支持，能很好的查看系统使用状态</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>linux管理面板</tag>
        <tag>Cockpit</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下Docker的安装与使用</title>
    <url>/2019/12/30/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/8%E3%80%81Ubuntu%E4%B8%8BDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>经过前面那么多期的铺垫，今天我们终于可以来安装使用我么的docker了。这是一个非常好用的工具，我们的NAS服务百分之九十都会部署在docker上运行。</p>
<p>有了docker以后，你不再需要小心翼翼地担心把系统配置搞乱无法恢复，在这里你可以通过几个简单地命令就可以将相关服务重新部署回来。</p>
<p>就这样，请拥有，并享受<br><a id="more"></a></p>
<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>如你并不想了解Docker是什么，只需要能简单的用就行地话你可以跳过本小节，直接进入Docker的安装部分。</p>
<p>关于Docker的详细信息我们可以去Docker的官网查看，<a href="https://docs.docker.com/" target="_blank" rel="noopener">点击这里</a>可以跳转。</p>
<blockquote>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
</blockquote>
<p>这是百科对Docker的解释，看到这里是不是很懵，不要紧，我来为你解释。</p>
<p>Docker是一个容器引擎，容器就是用来放东西的，Docker容器里面放的就是操作系统，一个容器对应一个操作系统，你可以把Docker想象成虚拟机，但是和虚拟机不同的是，得益于Docker的机制，在Docker中运行虚拟机往往不需要很多内存以及处理器资源，相比VMWare动则几个G的大小，在Docker中运行一个虚拟机仅需几十兆到几百兆的空间，你可以运行几十甚至上百个虚拟机在Docker中，这是VMWare所不能比的。</p>
<p>在开始搭建之前，你需要了解docker的几个基本概念</p>
<p>镜像：镜像就是实际就类似于一个安装镜像，比如你需要安装Windows，那么你需要去微软的官网下载windows的镜像，你才能进行安装。</p>
<p>DockerHub：DockerHub就是一个存放以及分享镜像的地方，你可以将你自己制作的镜像上传到DockerHub与别人分享，你也可以到DockerHub下载别人分享的镜像进行使用。</p>
<p>容器：当你启动了一个镜像之后，对应着就会有一个容器生成，容器是用来存储镜像运行时的状态的，这就相当于你通过镜像创建了一个虚拟机，那么创建完成后你的虚拟机就跑在了容器中。镜像是静态的，而容器是动态的。</p>
<p>有了对Docker的一个简单了解后，我们就可以进行接下来的操作了。</p>
<h1 id="Docker安装与卸载"><a href="#Docker安装与卸载" class="headerlink" title="Docker安装与卸载"></a>Docker安装与卸载</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>在apt的官方源中已经加入了Docker，但是这往往不是最新的版本，要安装最新的版本，我们需要进行一些简单的配置。</p>
<p>Docker提供了<code>Enterprise</code>以及<code>Community</code>两个版本可供安装，我们只需要安装<code>Community</code>版即可，这是一个社区版，可以免费使用。</p>
<p>如果你以及安装了一个老的版本的Docker，那么你需要先卸载它，老版本的Docker软件名字为<code>docker</code>、<code>docker.io</code>或者是<code>docker-engine</code>，你可以通过下面语句卸载它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<ol>
<li>首先更新<code>apt</code>包的索引：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li><p>安装软件包以允许<code>apt</code>通过<code>HTTPS</code>使用存储库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加Docker的官方GPG密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p><code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure>
<p>执行后出现以下内容即添加成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下命令来设置稳定的存储库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>apt</code>包索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装最新版本的Docker Engine-Community和containerd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
<p>如果出现如下的版本号，即为安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker version 19.03.5, build 633a0ea838</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Docker卸载"><a href="#Docker卸载" class="headerlink" title="Docker卸载"></a>Docker卸载</h2><ol>
<li>卸载Docker Engine-社区软件包：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt purge docker-ce</span><br></pre></td></tr></table></figure></li>
<li>主机上的映像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Docker配置及基本使用"><a href="#Docker配置及基本使用" class="headerlink" title="Docker配置及基本使用"></a>Docker配置及基本使用</h1><p>在完成docker的安装后，我们就可以开始使用docker来部署服务了，在此之前，我们先来学习一下docker的基本使用方法。</p>
<p>在docker中你首先需要有镜像文件（images），你才可以通过镜像来部署相关服务，镜像的话你可以到DockerHub获取，也可以自己写dockerfile来构建镜像（本专栏不涉及）。</p>
<h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><ol>
<li>修改镜像源<br>docker服务器在国外，在国内访问速度很慢，我们可以通过修改镜像源为阿里云来启用加速</li>
</ol>
<p>首先到阿里云<a href="https://www.aliyun.com/product/acr" target="_blank" rel="noopener">镜像服务中心</a>，你需要登录阿里云。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20202216.jpg" alt="镜像服务中心"></p>
<p>然后进入<strong>管理控制台</strong>，然后选择<code>镜像中心 -&gt; 镜像加速器</code></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20202344.jpg" alt="镜像加速器"><br>如果你没有的话会提示你进行申请，完成后会看到上图的信息，会提示你进行配置，配置的话你只需要将配置镜像加速器下方的代码复制到终端执行即可（如果你分不清命令的话一次性全部复制完，粘贴后按下回车键）。<br>这样当以后下载镜像的时候就会快很多。</p>
<h2 id="Docker基本使用"><a href="#Docker基本使用" class="headerlink" title="Docker基本使用"></a>Docker基本使用</h2><ol>
<li>获取镜像文件<br>首先到docker官网：<a href="https://hub.docker.com/" target="_blank" rel="noopener">点击这里</a>进行注册注册完成后登录<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20203405.jpg" alt="Docker官网"><br>然后点击左上角的搜索框输入需要搜索的东西可进行搜索，这里以搜索Ubuntu为例<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20203714.jpg" alt="镜像搜索"><br>完成搜索后我们可以看到列出了很多的项目，我们根据自己的需要点开一个镜像<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20203937.jpg" alt="镜像页面"><br>在这里我们我们可以看到相关的镜像描述以及基本的信息，右边有一栏黑色的代码框，通过输入代码框的命令我们即可获取相关的镜像。<br>在这里我们输入一下命令来获取镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20205329.jpg" alt="获取镜像"></li>
</ol>
<p>下载完成后我们可以通过以下命令查看本地的镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20205540.jpg" alt="查看本地镜像"></p>
<p><strong>REPOSITORY</strong>：镜像名<br><strong>TAG</strong>：标签：latest为最新版本<br><strong>IMAGE ID</strong>：镜像ID，镜像唯一标识符<br><strong>CREATED</strong>：构建时间<br><strong>SIZE</strong>:镜像大小</p>
<ol>
<li>构建容器<br>在有了本地镜像之后，我们就可以来构建容器了，我们先通过一个简单的例子来讲解<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9999:8096 \</span><br><span class="line">--name&#x3D;ubuntu \</span><br><span class="line">-v &#x2F;mnt&#x2F;sda:&#x2F;mnt \</span><br><span class="line">--restart&#x3D;always \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;renderD128:&#x2F;dev&#x2F;dri&#x2F;renderD128 \</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>
出现下图所示内容即创建成功</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-27%20210815.jpg" alt="创建成功"></p>
<p>上面命令你也可以将\符去掉写成一行，这里来讲解一下各个参数的作用</p>
<p>-d：表示运行容器后台运行<br>-p：端口映射，格式为<strong>主机端口：容器内端口</strong>，即通过主机的该端口既可以访问到容器内的端口内容<br>—name：命名容器，默认生成的容器名字是随机的，可以通过该命令指定<br>-v：绑定文件卷，格式为<strong>主机目录：容器内目录</strong>，在主机上的某一目录映射到容器内，即通过容器内指定的目录即可访问到主机对应的目录中的文件。<br>—restart：开机重启，always为开机重启<br>—device：绑定硬件到容器内部，在后面章节做详细讲解。</p>
<h2 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h2><p>创建成功后我们可以通过如下命令查看正在运行的容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><br>通过一下命令查看所用容器，包括未运行的容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><br>停止容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>这里容器id只需要输入前几位就可以，只要能和其他的区别开来就行</p>
<p>启动容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>删除容器（删除前需要先停止容器）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>删除镜像（删除前需先删除用该镜像构建的容器）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id</span><br></pre></td></tr></table></figure></p>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><ol>
<li><code>docker pull</code>：拉取镜像</li>
<li><code>docker images</code>：查看本地镜像</li>
<li><code>docker run</code>：通过镜像构建容器</li>
<li><code>docker ps</code>：查看正在运行的容器</li>
<li><code>docker ps -a</code>：查看所有容器</li>
<li><code>docker start</code>:启动容器</li>
<li><code>docker stop</code>：停止容器运行</li>
<li><code>docker rm</code>：查出容器</li>
<li><code>docker rmi</code>：删除镜像</li>
</ol>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>容器相对来说使用还是比较简单的，通过简单的学习就可以使用。如果你对其还不是很熟悉，你应该多去实际使用上面的命令，在这里你不用担心出错，大不了使用<code>docker rm</code>删除了再来一次，而不用担心物理机环境遭到破坏。</p>
<h1 id="目录专栏"><a href="#目录专栏" class="headerlink" title="目录专栏"></a>目录专栏</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>docker</tag>
        <tag>ubuntu安装docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数列极限的定义及应用</title>
    <url>/2020/06/04/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="数列极限的定义"><a href="#数列极限的定义" class="headerlink" title="数列极限的定义"></a>数列极限的定义</h1><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>我们先来看一个数列$x_n=\frac{1}{n}$</p>
<p>当$n=1$时，$x_1=\frac{1}{1}=1$</p>
<p>当$n=2$时，$x_2=\frac{1}{2}$</p>
<a id="more"></a>
<p>$\cdots$</p>
<p>当$n=1000$时，$x_{1000}=\frac{1}{1000}$</p>
<p>$\cdots$</p>
<p>当$n\to\infty$时，数列$x_n$的值无限接近$0$。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200604165314460.png" alt="image-20200604165314460"></p>
<p>此时我们就可以说$\underset{n\to \infty }{\text{lim}}\frac{1}{n}=0$。这样我们就可以给出数列极限的一个直观定义：</p>
<script type="math/tex; mode=display">
\underset{n\to \infty }{\text{lim}}x_n=A\Longleftrightarrow n\to \infty ,x_n\rightarrow A</script><blockquote>
<p>当$n$趋近于无穷大时，数列极限$x_n$<strong>无限接近</strong>于一个值$A$。</p>
</blockquote>
<p>用<strong>无限接近</strong>来描述这个定义是不严谨的，我们需要找到一种更加精确的语言来描述这段话。那么如何用数学语言来描述这一变化呢？？</p>
<h2 id="数列极限定义"><a href="#数列极限定义" class="headerlink" title="数列极限定义"></a>数列极限定义</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>分析数列$a_n=\frac{(-1)^n }{n}\sin \left(\frac{1}{n}\right)$的变化趋势</p>
<p>我们任意给定一个$\varepsilon&gt;0$，$\varepsilon$为一个任意小的值，总存在一个$N$(这里的$N$指数列的第$N$项)，当$n&gt;N$时，总存在$|a_n-0|&lt;\frac{1}{n}$，如下</p>
<ul>
<li>取$\varepsilon=\frac{1}{2}$，当$n&gt;2$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_1=2,|a_n-0|&lt;\frac{1}{2}$。</li>
<li>取$\varepsilon=\frac{1}{2^2}$，当$n&gt;2^2$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_2=2^2,|a_n-0|&lt;\frac{1}{2^2}$。</li>
<li>取$\varepsilon=\frac{1}{2^k}$，当$n&gt;2^k$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_k=2^k,|a_n-0|&lt;\frac{1}{2^k}$。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定数列$\left \{a_n \right\}$，$a$为常数，如果对于任意的$\varepsilon&gt;0$，都存在一个自然数$N$，使得当$n&gt;N$时，成立</p>
<script type="math/tex; mode=display">
|a_n-a|<\varepsilon</script><p>则称数列$\left \{a_n \right\}$以$a$为极限，记作$\underset{n\to \infty }{\text{lim}}a_n=a$</p>
<p>如果该数列没有极限，则称该数列是<strong>发散</strong>的。</p>
<p>需要注意</p>
<ul>
<li>定义中的$\varepsilon$刻画了$x_n$与$a$的逼近程度，定义中的$\varepsilon$可以限制$\varepsilon &lt; a$</li>
<li>定义中的$N$和$\varepsilon$有关，仅要求存在，一般$\varepsilon$越小，$N$越大。</li>
</ul>
<h3 id="数学符号描述"><a href="#数学符号描述" class="headerlink" title="数学符号描述"></a>数学符号描述</h3><script type="math/tex; mode=display">
\forall \varepsilon > 0,\exists N(\varepsilon)\in N^*,\forall n>N:|x_n-a|<\varepsilon</script><p>其中“$\forall$”表示任意的，“$\exists$”表示存在，“$:$”表示满足</p>
<h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>推论$\underset{n\to \infty }{\text{lim}}a_n=a\Longleftrightarrow$当$n&gt;N$时，所有的点$x_n$都落在$(a-\varepsilon,a+\varepsilon)$内，只有有限个(最多$N$个落在其外)。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200605001400184.png" alt="image-20200605001400184"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200605001429236.png" alt="image-20200605001429236"></p>
]]></content>
      <categories>
        <category>数学分析</category>
      </categories>
      <tags>
        <tag>数列极限</tag>
        <tag>数列极限定义</tag>
        <tag>数列极限应用</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机浮点数表示</title>
    <url>/2019/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%9B%B8%E5%85%B3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h1><p>想要理解浮点数，首先要考虑小数的二进制表示。首先来考虑十进制的的表示方法，对于任意含有小数部分的十进制，我们都可以用形如：</p>
<script type="math/tex; mode=display">d_m d_{m-1} ···d_1 d_0  .  d_{-1} d_{-2} ··· d_{-n}</script><p>其中对于任意的$ d_i $的取值范围为$d_i\in[0,9]$,这个表达描述的数值$d$的定义如下：</p>
<script type="math/tex; mode=display">d=\sum_{i=-n}^m10^i \times d_i \tag{1.1}</script><a id="more"></a>
<p>数字的权的定义与十进制小数点符号$’.’$有关，相当于小数点左边的数字的权是$10$的正幂，得到整数值，小数点右边的数字的权是$10$的负幂，得到小数值。例如，十进制数$12.34$可以表示为：</p>
<script type="math/tex; mode=display">1 \times 10^1+2 \times 10^0 + 3 \times 10^{-1}+4 \times 10^{-2}= 12 \frac{34}{100}</script><p>类似，考虑一个形如</p>
<script type="math/tex; mode=display">b_m b_{m-1} ···b_1 b_0  .  b_{-1} b_{-2} ··· b_{-n}</script><p>的表示法，其中每个二进制（位）$b_i$的取值范围为$0或1$，这种表示方法表示的数$b$定义如下：</p>
<script type="math/tex; mode=display">b=\sum_{i=-n}^m2^i \times b_i \tag{1.2}</script><p>此时，数字的权的定义与二进制小数点符号$’.’$有关，小数点左边的数字的权是$2$的正幂，得到整数值，小数点右边的数字的权是$2$的负幂，得到小数值。例如，二进制数$101.11$可以表示为：</p>
<script type="math/tex; mode=display">1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1 \times 2^{-1}+1 \times 2^{-2}=5 \frac{3}{4}</script><p>从$(1.2)$式中可以看出，将二进制小数点向左移动一位相当于除$2$，例如，$101.11$表示数$5 \frac{3}{4}$，而$10.111$表示数$2 \frac{7}{8}$，类似的，向右移动小数点一位相当于乘$2$，例如，$1011.1$表示数$11 \frac{1}{2}$。</p>
<p>注意，形如$(0.11···1)_2$表示的数是刚好小于$1$的数，例如$(0.111111)_2$表示$\frac{63}{64}$,在此将用$1-\epsilon$来表示此类数值。</p>
<p>如果我们仅考虑有限长度的编码，那么十进制符号是不能准确表达像$\frac{1}{3}$和$\frac{1}{5}$这样的无理数的。类似地，小数的二进制表示法只能表示那些能够被写成$x+2^y$的数。其它的值只能够近似地表示。例如，虽然加长的二进制能够提高表示数$\frac{1}{5}$的精度，但是我们并不能准确的把它表示为一个二进制数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制</th>
<th style="text-align:center">值</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">值</th>
<th style="text-align:center">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">0.00110</td>
<td style="text-align:center">$\frac{6}{32}$</td>
<td style="text-align:center">0.1875</td>
</tr>
<tr>
<td style="text-align:center">0.01</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">0.25</td>
<td style="text-align:center">0.001101</td>
<td style="text-align:center">$\frac{13}{64}$</td>
<td style="text-align:center">0.203125</td>
</tr>
<tr>
<td style="text-align:center">0.010</td>
<td style="text-align:center">$\frac{2}{8}$</td>
<td style="text-align:center">0.25</td>
<td style="text-align:center">0.0011010</td>
<td style="text-align:center">$\frac{26}{128}$</td>
<td style="text-align:center">0.203125</td>
</tr>
<tr>
<td style="text-align:center">0.0011</td>
<td style="text-align:center">$\frac{3}{16}$</td>
<td style="text-align:center">0.1875</td>
<td style="text-align:center">0.00110011</td>
<td style="text-align:center">$\frac{51}{256}$</td>
<td style="text-align:center">0.19921875</td>
</tr>
</tbody>
</table>
</div>
<h1 id="IEEE754浮点表示"><a href="#IEEE754浮点表示" class="headerlink" title="IEEE754浮点表示"></a>IEEE754浮点表示</h1><p>像前一节中谈到的位置表示法不能很有效地表示很大地数字。例如。$5 \times 2^{100}$的表示是由$101$后跟$100$的位模式组成。相反的，我们希望通过给定$x$和$y$的值来表示形如$x \times 2^y$的数。<br>IEEE（读作“eye-Triple-ee”）浮点标准用</p>
<p><script type="math/tex">V=(-1)^s \times M \times 2^E \tag{2.1}</script>来表示一个数。对于$(2.1)$式，有如下解释：</p>
<ul>
<li><strong> 符号$s$（sign）决定该数是正数（$s=0$）还是负数（$s=1$），对于数值$0$的符号位解释作为特殊情况处理。 </strong></li>
</ul>
<ul>
<li><strong> 有效数$M$（significand）是一个二进制小数，它的范围在$1 \sim 2-\epsilon$之间，或者在$0\sim 1-\epsilon$之间。 </strong></li>
</ul>
<ul>
<li><strong> 指数$E$（exponent）是$2$的幂（可能为负数），它的作用是对浮点数加权。</strong></li>
</ul>
<p>浮点数的位表示被划分为三个部分，以编码这些值：</p>
<ul>
<li><strong> 一个单独的符号位$s$直接编码符号$s$。 </strong></li>
<li><strong> $k$位的指数部分$exp=e_{k-1}···e_1e_0$编码指数E。 </strong></li>
<li><strong> $n$位的小数部分$frac=f_{n-1}···f_1f_0$编码有效数M，但是被编码的值也依赖于指数部分的值是否等于$0$。 </strong></li>
</ul>
<p>在单精度浮点格式（$C$语言中的$float$）中，$s$、$exp$、$frac$部分分别为$1$位，$k=8$位和$n=23$位，产生一个32位的表示。在双精度浮点格式（$C$语言中的$double$）中，$s$、$exp$、$frac$部分分别为$1$位、$k=11$位和$n=52$位，产生一个64位的表示。如下示意图所示：</p>
<center>32位浮点格式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">s</th>
<th style="text-align:center">exp</th>
<th style="text-align:center">frac</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">$e_7e_6···e_1e_0$</td>
<td style="text-align:center">$ f_{31}f_{30}···f_1f_0 $</td>
</tr>
</tbody>
</table>
</div>
<center>64位浮点格式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">s</th>
<th style="text-align:center">exp</th>
<th style="text-align:center">frac</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">$e_{10}e_9···e_1e_0$</td>
<td style="text-align:center">$f_{51}f_{50}···f_1f_0$</td>
</tr>
</tbody>
</table>
</div>
<p>根据$esp$的值，被编码的值可以划分为三种情况：<br>1.规格化的值<br>2.非规格化的值<br>3.特殊值</p>
<h2 id="规格化值"><a href="#规格化值" class="headerlink" title="规格化值"></a>规格化值</h2><p>这是最为普通的一种情况，当$exp$的值不全为$1$（对应数值0），和不全为$1$（32单精度中为255，64位双精度中为2047）时，都属于规格化的值。<br>在这种时候，阶码字段被解释为以偏置（biased）形式表示的有符号整数，此时阶码$E=e-Bias$，其中$e$为无符号数，表示形式为$exp=e_{k-1}···e_1e_0$，而$Bias$是一个等于$2_{k-1}-1$（单精度下为127，双精度下为1023）的偏置值。由此可以得到指数的取值范围，单精度为$-126 \sim +127$，而双精度为$-1022 \sim +1023$。<br>小数字段$frac$被解释为描述的小数值$f$，其中$0 \leq f&lt;1$，其二进制表示为$0.frac=f_{n-1}···f_1f_0$，尾数定义为$M=1+f$。</p>
<h2 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h2><p>非规格化的值就是当阶码全为$0$时所表示的数。此时，阶码值是$E=1-Bias$，而尾数的值是$M=f$，注意，此时不隐含开头的$1$，仅表示小数字段。<br>非规格化的数有两个用途，一是用来表示数值$0$（在规格化的数中，我们总有$M \geq 1$，因此就不能表示$0$）。当阶码为全$0$且小数字段也全为$0$，就得到了$M=f=0$，如果此时符号位为$0$，则得到值$+0.0$，反之当符号位为$1$，则得到值$-0.0$。在IEEE浮点数中，两个值在某些方面被认为是不同的。<br>另一个功能是表示非常接近$0.0$的值，它们提供了一种称为<strong>逐渐溢出</strong>（gradual underflow）的属性。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>最后一种情况是阶码全为1时出现的，当数小数部分$f$全为0时，得到的值表示无穷，$s=0$表示$+ \infty$，当$s=1$时表示$- \infty$。<br>当我们把两个非常大的数相乘或者除以零时，无穷大能够表示溢出的结果。当小数部分为非零时，结果值称为“NaN”（Not a Number），一些运算的结果不能是实数或无穷，就会返回这样的NaN值。</p>
<h1 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h1><p>下图展示了假定的8位浮点格式的示例，其中$k=4$的阶码位和$n=3的小数位$，偏置量是$2^{4-1}-1=7$。图分为三个区域来来描述三类数字。不同的列给出了阶码字段是如何编码阶码$E$的，小数字段是如何编码尾数$M$的，以及它们是如何形成要表示的值$V=(-1)^s \times M \times 2^E \tag{2.1}$的。<br>从0开始，靠近0的是非规格化数，这种格式的非规格化数的$E=1-7=-6$，得到权$2^E= \frac{1}{64}$。小数f的值的范围是$0, \frac{1}{8},···, \frac{7}{8}$，从而得到数V的范围为$0 \sim \frac{1}{64}  \times \frac{1}{8}= \frac{7}{512}$。</p>
<figure><img src="https://raw.githubusercontent.com/yurui105/image/master/blogs_image/8%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E9%9D%9E%E8%B4%9F%E5%80%BC%E7%A4%BA%E4%BE%8B.png" alt="8位浮点数的非负值示例.png"><figcaption>8位浮点数的非负值示例</figcaption></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]（美）布莱恩特,（美）奥哈拉伦著.深入理解计算机系统  原书第2版.机械工业出版社,2010.Print.</p>
<p>[2]对IEEE 450-1995(ANSI/IEEE)标准的解释:IEEE 450-1995/INT-2001[S].2001.</p>
]]></content>
      <categories>
        <category>计算机组成相关</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
        <tag>IEEE754</tag>
        <tag>IEEE浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title>1、向量及其运算</title>
    <url>/2020/06/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/1%E3%80%81%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>线性代数的中心问题是求解线性方程组。</p>
<p>假设给定一个线性方程组：</p>
<script type="math/tex; mode=display">
x_1+2x_2=4\\
2x_1-3x_2=-2</script><a id="more"></a>
<p>我们将$x_1$、$x_2$的系数以及结果单独提取出来，它能表示为：</p>
<script type="math/tex; mode=display">
x_1\binom{1}{2}+x_2\binom{2}{-3}=\binom{4}{-2}</script><p>由此可得此方程可解$\Longleftrightarrow$$\binom{4}{-2}$可表示为$\binom{1}{2}$和$\binom{2}{-3}$的线性组合。</p>
<p>线性代数是建立在向量的加法和数乘这两种所谓<strong>线性运算</strong>上的.</p>
<h1 id="n-维空间中的点"><a href="#n-维空间中的点" class="headerlink" title="$n$维空间中的点"></a>$n$维空间中的点</h1><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>在一条直线上取定坐标原点后，每个实数一一对应表示直线上的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601225945203.png" alt="image-20200601225945203"></p>
<p>一个二元的有序数组$(x_1,x_2)$一一对应表示平面上的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601230654410.png" alt="image-20200601230654410"></p>
<p>一个三维有序数组$(x_1,x_2,x_3)$一一对应表示三维空间中的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601231634293.png" alt="image-20200601231634293"></p>
<p>同理，定义$n$维空间的点为一个$n$元有序数组$x=(x_1,\dots,x_n)$，称$x_i$为点$x$的第$i$个坐标.</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p><strong>相等</strong></p>
<p>对于$n$维空间的两个点$x=(x_1,\dots,x_n)$与$y=(y_1,\dots,y_n)$，若</p>
<script type="math/tex; mode=display">
x_i=y_i, \forall1\leq i \leq n.</script><p>则称$x$与$y$相等。</p>
</li>
</ol>
<ol>
<li><p><strong>相加</strong></p>
<p>对于$n$维空间的两个点$x=(x_1,\dots,x_n)$与$y=(y_1,\dots,y_n)$，其<strong>加法</strong>规则为：</p>
<script type="math/tex; mode=display">
x+y:=(x_1+y_1,\dots,x_n+y_n)</script></li>
<li><p><strong>数乘运算</strong></p>
<p>对于$n$维空间的点$x=(x_1,\dots,x_n)$，以及$c\in R$其<strong>数乘运算</strong>规则为：</p>
<script type="math/tex; mode=display">
cx:=(cx_1,\dots,cx_n)</script></li>
</ol>
<p>这样定义的加法及数乘运算对于任意$n$维空间中的点$x,y,z$满足以下8条性质:</p>
<ol>
<li>$(x+y)+z=x+(y+z)$</li>
<li>$x+y=y+x$</li>
<li>若令$0=(0,\dots,0)$为一个点，则$0+x=x+0=x$</li>
<li>若以$-x$表示$(-1)x$，则$x+(-x)=0$</li>
<li>$1·x=x$</li>
<li>$(c_1·c_2)x=c_1(c_2x)$</li>
<li>$(c_1+c_2)x=c_1x+c_2x$</li>
<li>$c(x+y)=cx+xy$</li>
</ol>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>向量指空间中具有一定<strong>长度</strong>及<strong>方向</strong>的直线段。通常记起点为$A$，终点为$B$的向量为$\overrightarrow{AB}$。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602000139541.png" alt="image-20200602000139541"></p>
<p>力、位移、速度、加速度等都是物理学中常出现的向量.</p>
<p><strong>两个向量相等$\Longleftrightarrow$二者长度相等，方向相同。</strong></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602000520092.png" alt="image-20200602000520092"></p>
<h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><h3 id="向量的加法-addition"><a href="#向量的加法-addition" class="headerlink" title="向量的加法(addition):"></a>向量的加法(addition):</h3><p>对于两个向量$\vec{a}=\overrightarrow{OA}$以及$b=\overrightarrow{OB}$，$\vec{a}+\vec{b}$的和为以向量$\vec{a}，\vec{b}$为邻边的平行四边形的对角线$\overrightarrow{OC}$代表的向量（平行四边形法则）。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602001500849.png" alt="image-20200602001500849"></p>
<p>向量的加法又满足三角形法则：</p>
<script type="math/tex; mode=display">
\overrightarrow{OA}+\overrightarrow{AC}=\overrightarrow{OC}</script><h3 id="向量的数乘-scalar-multiplication-："><a href="#向量的数乘-scalar-multiplication-：" class="headerlink" title="向量的数乘(scalar multiplication)："></a>向量的数乘(scalar multiplication)：</h3><p>向量的数乘即向量的方向不变，大小变为原来的$c(c\in R)$倍。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602090359154.png" alt="image-20200602090359154"></p>
<h3 id="向量的性质"><a href="#向量的性质" class="headerlink" title="向量的性质"></a>向量的性质</h3><ol>
<li><p>向量的加法满足结合律，即对于任意的向量$\vec{a},\vec{b},\vec{c}$</p>
<script type="math/tex; mode=display">
\vec{a}+(\vec{b}+\vec{c})=(\vec{a}+\vec{b})+\vec{c}</script></li>
<li><p>向量的加法满足交换律，即对于任意的向量$\vec{a},\vec{b}$</p>
<script type="math/tex; mode=display">
\vec{a}+\vec{b}=\vec{b}+\vec{a}</script></li>
<li><p>当$A=B$时，称向量$\overrightarrow{AB}$为零向量，记作$\vec{0}$，则</p>
<script type="math/tex; mode=display">
\overrightarrow{AA}+\overrightarrow{AB}=\overrightarrow{AB}可表示为0+\vec{a}=\vec{a}对于任意向量\vec{a}成立</script></li>
<li><p>对向量$a=\overrightarrow{AB}$，记向量$\overrightarrow{BA}=-a$，则$\overrightarrow{AB}+\overrightarrow{BA}=\overrightarrow{AA}$，即</p>
<script type="math/tex; mode=display">
\vec{a}+(-\vec{a})=0,\forall \vec{a}</script></li>
<li><p>$1·\vec{a}=\vec{a}$</p>
</li>
<li><p>$(c_1·c_2)\vec{a}=c_1(c_2)\vec{a}$</p>
</li>
<li><p>$(c_1+c_2)\vec{a}=c_1\vec{a}+c_2\vec{a}$</p>
</li>
<li><p>$c(\vec{a}+\vec{b})=c\vec{a}+c\vec{b}$</p>
</li>
</ol>
<h2 id="向量的表示"><a href="#向量的表示" class="headerlink" title="向量的表示"></a>向量的表示</h2><p>如果固定向量的起点，如记之为原点，则向量由其终点唯一确定，于是我们可以等同：</p>
<ol>
<li>$n$维空间中的点</li>
<li>$n$元有序数组</li>
<li>$n$维空间中由原点出发的向量</li>
</ol>
<p>我们将不加区分地使用向量的这三个身份。</p>
<p>记$\vec{a}=\begin{pmatrix}a_1\\\vdots \\a_n \end{pmatrix}$为列向量，其中$a_i$为向量$\vec{a}$的第$i$个分量。</p>
<p>则有向量的加法：</p>
<script type="math/tex; mode=display">
\vec{a}+\vec{b}:=\begin{pmatrix}a_1+b_! \\\vdots \\a_n+b_n\end{pmatrix}.</script><p>数乘：</p>
<script type="math/tex; mode=display">
c\vec{a}:=\begin{pmatrix}c\vec{a_1} \\\vdots \\c\vec{a_n}\end{pmatrix}.</script><h1 id="向量的空间定义"><a href="#向量的空间定义" class="headerlink" title="向量的空间定义"></a>向量的空间定义</h1><p>在由称为”向量“的元素构成的非空集合$V$中，若定义了加法和数乘运算，且对任意向量$\vec{a},\vec{b},\vec{c}$及数$k,l\in F$满足以下8条性质：</p>
<ol>
<li>$\vec{a}+(\vec{b}+\vec{c})=(\vec{a}+\vec{b})+\vec{c}$</li>
<li>$\vec{a}+\vec{b}=\vec{b}+\vec{a}$</li>
<li>存在$\vec{0}$，$\vec{a}+\vec{0}=\vec{a}$</li>
<li>对于任意向量$\vec{a}$，存在唯一相反向量$-\vec{a}$，使得$\vec{a}+(-\vec{a})=\vec{0}$</li>
<li>$1·\vec{a}=\vec{a}$</li>
<li>$(kl)\vec{a}=k(l\vec{a})$</li>
<li>$k(\vec{a}+\vec{b})=k\vec{a}+k\vec{b}$</li>
<li>$(k+l)\vec{a}=k\vec{a}+l\vec{a}$</li>
</ol>
<p>则称$V$为定义在数域$F$上的向量空间(vector space).</p>
<h1 id="向量的线性组合"><a href="#向量的线性组合" class="headerlink" title="向量的线性组合"></a>向量的线性组合</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>设$\vec{v_1},\cdots,\vec{v_m}$为$m$个$n$维向量，$c_1,\cdots,c_m \in R$，则称$c_1v_1,\cdots,c_mv_m$为向量$\vec{v_1},\cdots,\vec{v_m}$的一个线性组合。</p>
<p>例：给定$\vec{i}=\begin{pmatrix}1 \\0 \\0\end{pmatrix}\vec{j}=\begin{pmatrix}0 \\1 \\0\end{pmatrix},\vec{k}=\begin{pmatrix}0 \\0 \\1\end{pmatrix}$，</p>
<p>则$\vec{u}=\begin{pmatrix}1 \-1 \\1\end{pmatrix}=\vec{i}-\vec{j}+\vec{k}$是向量$\vec{i},\vec{j},\vec{k}$的一个线性组合。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>Q：给定一组向量$\vec{v_1},\cdots,\vec{v_m}$，则$\vec{v_1},\cdots,\vec{v_m}$的全部线性组合是怎样的集合？</p>
<p>例1：向量$\vec{u}=\begin{pmatrix}1 \\1 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}|c\in R\right\}$为以$\vec{u}$为方向的一条直线。</p>
<p>例2：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$和$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$的全部线性组合为$c\vec{u}+d\vec{v}=\begin{pmatrix}c \\c+d \\d\end{pmatrix}$，其中$c,d$为任意实数，这是平面$x-y+z=0$。</p>
<p>例3：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$和$\vec{v}=\begin{pmatrix}\sqrt{2} \\\sqrt{2} \\0\end{pmatrix}$的全部线性组合为$c\vec{u}+d\vec{v}=\begin{pmatrix}c+\sqrt{2}d \\c+\sqrt{2}d\\0\end{pmatrix}$，其中$c,d$为任意实数，这是直线$\left\{\begin{aligned}x = y \\z = 0\end{aligned}\right.$</p>
<p>例4：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$，$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$，$\vec{w}=\begin{pmatrix}1 \\0 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}+d\vec{v}+e\vec{w}|c,d,e \in R\right\}$为整个三维空间.</p>
<p>这是因为，任意三维向量$\begin{pmatrix}x \\y \\z\end{pmatrix}$都可以表示为$\vec{u},\vec{v},\vec{w}$的下列线性组合：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}x \\y \\z\end{pmatrix}=\frac{x+y-z}{2}\vec{u}+\frac{y+z-x}{2}\vec{v}+\frac{z+x-y}{2}\vec{w}.</script><p>例5：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$，$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$，$\vec{w}=\begin{pmatrix}1 \\2 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}+d\vec{v}+e\vec{w}=(c+e)\vec{u}+(d+e)\vec{v}|c,d,e \in R\right\}$为向量$\vec{u},\vec{w}$张成的平面$x-y+z=0$，这是因为$\vec{w}=\vec{u}|\vec{v}$在$\vec{u},\vec{v}$所张成的这张平面上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在3维空间中， 一般而言，向量$\vec{u},\vec{u}和\vec{v},或\vec{u}、\vec{v}和\vec{w}$的所有线性组合分别是一条直线、一张平面或整个3维空间。</p>
<h1 id="向量的点积、长度"><a href="#向量的点积、长度" class="headerlink" title="向量的点积、长度"></a>向量的点积、长度</h1><h2 id="向量长度"><a href="#向量长度" class="headerlink" title="向量长度"></a>向量长度</h2><p>向量$\vec{v}$的长度(length)或模(norm)定义为</p>
<script type="math/tex; mode=display">
|\vec{v}|=\sqrt{\vec{v}·\vec{v}}</script><p>若$\vec{v}=(v_1,\cdots,v_n)$，则$|\vec{v}|=\sqrt{v_1^2+\cdots+v_n^2}$。</p>
<p>例：$\vec{v}=(1，2，3)$，则$|\vec{v}|=\sqrt{1+4+9}=\sqrt{14}$。</p>
<h2 id="向量点积"><a href="#向量点积" class="headerlink" title="向量点积"></a>向量点积</h2><p>定义：若$|\vec{v}|=1$，则称$\vec{v}$为单位向量(unit vector)。</p>
<p>单位化：任给一非零向量$\vec{v}$，则$\frac{\vec{v}}{|\vec{v}|}$是沿$\vec{v}$方向的单位向量。</p>
<p>例1：$\vec{v}=(\cos\theta,\sin\theta)$，则$|\vec{v}|=1$。</p>
<p>例2：$\vec{v}=(1，2，3)$，则沿$\vec{v}$方向的单位向量为$\frac{\vec{v}}{|\vec{v}|}=\frac{1}{\sqrt{14}}(1,2,3)$.</p>
<p>向量点积的性质：</p>
<ol>
<li>$\vec{v}\cdot\vec{w}=\vec{w}\cdot\vec{v}$（对称性）</li>
<li>$\vec{u}\cdot(c\vec{v}+d\vec{w})=c\vec{u}\cdot\vec{v}+d\vec{u}\cdot\vec{w}$（线性性）</li>
<li>$\vec{v}\cdot\vec{v}=|\vec{v}|^2\ge0$，且等号成立当且仅当$\vec{v}=0$（正定性）</li>
</ol>
<h1 id="向量的夹角"><a href="#向量的夹角" class="headerlink" title="向量的夹角"></a>向量的夹角</h1><h2 id="向量垂直"><a href="#向量垂直" class="headerlink" title="向量垂直"></a>向量垂直</h2><p>若$\vec{v}\cdot\vec{w}=0$，则称向量$\vec{v}$和$\vec{w}$垂直(perpendicular)(或者称为正交(orthogonal))。记作$\vec{v}\perp\vec{w}$或$\vec{w}\perp\vec{v}$。</p>
<p>在此规定，$\vec{0}$和任意向量垂直。</p>
<p>这样定义的垂直的概念与几何直观是一致的，即</p>
<script type="math/tex; mode=display">
\vec{v}\perp\vec{w}\Longleftrightarrow\vec{v}\cdot\vec{w}=0</script><p>证明：设$\vec{v}\perp\vec{w}$，则$\vec{v},\vec{w},\vec{v}-\vec{w}$构成直角三角形的三条边，如下如所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602144024402.png" alt="image-20200602144024402"></p>
<p>于是由勾股定理可得：$|\vec{v}-\vec{w}|^2=|\vec{v}|^2+|\vec{w}|^2$，将式子左边展开得：</p>
<script type="math/tex; mode=display">
|\vec{v}-\vec{w}|^2=(\vec{v}-\vec{w})\cdot(\vec{v}-\vec{w})=|\vec{v}|^2-\vec{v}\cdot\vec{w}-\vec{w}\cdot\vec{v}+|\vec{w}|^2</script><p>故得 $\vec{v}\cdot\vec{w}=0$，反之亦然。</p>
<h2 id="向量的夹角-1"><a href="#向量的夹角-1" class="headerlink" title="向量的夹角"></a>向量的夹角</h2><p>命题：两非零向量$\vec{v},\vec{w}$的夹角$\theta$满足$\cos\theta=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}$。</p>
<p>证明：一般的，向量$\vec{v},\vec{w},\vec{v}-\vec{w}$构成三角形的三条边，由<strong>余弦定理</strong>得</p>
<script type="math/tex; mode=display">
|\vec{v}-\vec{w}|^2=|\vec{v}|^2+|\vec{w}|^2-2|\vec{v}||\vec{w}|\cos\theta</script><p>故有：</p>
<script type="math/tex; mode=display">
\cos\theta=\frac{|\vec{v}|^2+|\vec{w}|^2-|\vec{v}-\vec{w}|^2}{2|\vec{v}||\vec{w}|}=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}</script><ul>
<li>若$\vec{v}\cdot\vec{w}&gt;0$，则$\cos\theta&gt;0$，取$0\leq\theta\leq\frac{\pi}{2}$</li>
<li>若$\vec{v}\cdot\vec{w}&lt;0$，则$\cos\theta&lt;0$，取$\frac{\pi}{2}\leq\theta\leq\pi$</li>
</ul>
<p>例题：$\vec{v}=(1,1),\vec{w}=(-1,0)$，则$\cos\theta=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}=-\frac{1}{\sqrt{2}}$，则$\vec{v},\vec{w}$夹角$\theta=\frac{3}{4}\pi$</p>
<h1 id="两个不等式"><a href="#两个不等式" class="headerlink" title="两个不等式"></a>两个不等式</h1><h2 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h2><p>Cauchy-Schwarz不等式首先由法国数学家Augustin-LouisCauchy(1789-1857)于1821年发现,再由俄国数学家Viktor YakovychBunyakovsky(1804-1889)于1859年重新发现, 后由德国数学家HermanSchwarz(1843-1921)于1886年再次重新发现.</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602151346208.png" alt="image-20200602151346208"></p>
<p>该不等式为：</p>
<script type="math/tex; mode=display">
|\vec{v}\cdot\vec{w}|\leq|\vec{v}||\vec{w}|</script><p>等号成立当且仅当一个向量是另一个向量得倍数。</p>
<h2 id="三角不等式-Triangle-inequality"><a href="#三角不等式-Triangle-inequality" class="headerlink" title="三角不等式(Triangle inequality)"></a>三角不等式(Triangle inequality)</h2><script type="math/tex; mode=display">
|\vec{v}+\vec{w}|\leq|\vec{v}|+|\vec{w}|</script><p>等号成立当且仅当$\vec{v},\vec{w}$之一为另一向量得非负倍数</p>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
|\vec{v}+\vec{w}|&=(\vec{v}+\vec{w})\cdot(\vec{v}+\vec{w})=|\vec{v}|^2+2\vec{v}\cdot\vec{w}+|\vec{w}|^2 \\
&\leq|\vec{v}|^2+|\vec{w}|^2+2|\vec{v}\cdot\vec{w}| \\
&\leq|\vec{v}|^2+|\vec{w}|^2+2|\vec{v}|\cdot|\vec{w}| \\
&=(|\vec{v}|+|\vec{w}|)^2
\end{aligned}</script><p>等号成立当且仅当$\vec{v}\cdot\vec{w}=|\vec{v}|\cdot|\vec{w}|$，这等价于$\vec{v},\vec{w}$之一为另一个向量得非负倍数。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><p>设$\vec{v}=(a,b),\vec{w}=(b,a)$,则由Cauchy-Schwarz不等式得</p>
<script type="math/tex; mode=display">
\vec{v}\cdot\vec{w}=2ab\leq a^2+b^2=|\vec{v}||\vec{w}|</script><p>若令$x=a^2,y=b^2$，则得到<strong>几何平均不大于算术平均</strong>：</p>
<script type="math/tex; mode=display">
\sqrt{xy}\leq\frac{x+y}{2}</script></li>
<li><p>设$|\vec{v}|=5,|\vec{w}=3|$，求$|\vec{v}-\vec{w}|$的最小和最大可能长度</p>
<p>解：首先，$|\vec{v}-\vec{w}|^2=|\vec{v}|^2-2\vec{v}\cdot\vec{w}+|\vec{w}|^2$,由Cauchy-Schwarz不等式得$-|\vec{v}||\vec{w}|\leq\vec{v}\cdot\vec{w}\leq|\vec{v}||\vec{w}|$，</p>
<p>故$(|\vec{v}|-|\vec{w}|)^2\leq|\vec{v}-\vec{w}|^2\leq(|\vec{v}+\vec{w}|)^2$</p>
<p>所以，$2\leq|\vec{v}-\vec{w}|\leq8$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
  </entry>
  <entry>
    <title>影音服务jellyfin安装与使用</title>
    <url>/2020/01/01/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/9%E3%80%81%E5%BD%B1%E9%9F%B3%E6%9C%8D%E5%8A%A1jellyfin%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>关于的jellyfin影音服务，已经有很多人对其做过介绍了，但在这里我任然要为其写一篇相关安装与使用的文章，因为在别的贴子里，很多人容易忽视掉设置硬件加速的一些必要步骤。</p>
<p>本篇文章将会从本机安装以及docker安装两种安装方式来向大家介绍jellyfin的安装以及基本使用方法。</p>
<a id="more"></a>
<p>注意：你应该在看完文章后再决定你选用的安装方式</p>
<p>就这样，请拥有，并享受</p>
<h1 id="jellyfin介绍"><a href="#jellyfin介绍" class="headerlink" title="jellyfin介绍"></a>jellyfin介绍</h1><p>jellyfin是一个免费的媒体系统软件，可以让你控制媒体的管理和流式传输，是emby和plex的替代产品，可以通过多个应用程序将媒体从专用服务器提供给最终用户设备。Jellyfin是Emby 3.5.2发行版的衍生版本，并移植到.NET Core框架以实现全面的跨平台支持。</p>
<p>jellyfin目前支持的平台有：Android、Android TV、Amazon Fire TV、UWP、 Apple iOS（目前正在测试阶段）等等平台，你可以参见<a href="http://jellyfin.org/docs/general/clients/index.html" target="_blank" rel="noopener">jellyfin支持平台</a>获得更多的信息。</p>
<h1 id="查看是设备是否支持硬件加速"><a href="#查看是设备是否支持硬件加速" class="headerlink" title="查看是设备是否支持硬件加速"></a>查看是设备是否支持硬件加速</h1><p>Jellyfin支持使用<code>FFMpeg</code>的视频编码/解码的硬件加速。<code>FFMpeg</code>可通过视频加速<code>API（VAAPI）</code>支持多种硬件加速实现，例如<code>Intel Quicksync（QSV）</code>，<code>AMD AMF</code>，<code>OpenMax OMX</code>，<code>nVidia NVENC / NVDEC</code>等。<br>|操作系统|推荐的硬件加速|<br>|-|-|<br>|Linux / GNU|VAAPI（推荐），NVENC，QSV，AMF|<br>|Windows|QSV，NVENC，AMF，VAAPI|<br>|MacOS|None (videotoolbox support coming)|<br>|Android|MediaCodec, OMX|<br>|RPi|OMX|<br><a href="https://developer.nvidia.com/ffmpeg" target="_blank" rel="noopener">NVIDIA使用ffmpeg官方名单</a>，建议将这些<a href="https://github.com/keylase/nvidia-patch" target="_blank" rel="noopener">驱动程序</a>用于<code>Linux / GNU</code>和<code>Windows</code>。这是支持的编解码器的<a href="https://developer.nvidia.com/video-encode-decode-gpu-support-matrix" target="_blank" rel="noopener">NVIDIA图形卡</a>的官方列表。</p>
<p>VAAPI支持的编解码器列表：<a href="http://jellyfin.org/docs/general/administration/hardware-acceleration.html" target="_blank" rel="noopener">点击这里查看</a><br>支持QSV的Intel处理器列表。<a href="https://ark.intel.com/content/www/us/en/ark.html#@Processors" target="_blank" rel="noopener">点击这里查看</a><br>FFmpeg硬件加速支持列表。<a href="https://trac.ffmpeg.org/wiki/HWAccelIntro" target="_blank" rel="noopener">点击这里查看</a><br>Ubuntu使用NVENC的示例。<a href="https://www.reddit.com/r/jellyfin/comments/amuyba/nvenc_nvdec_working_in_jellyfin_on_ubuntu_server/" target="_blank" rel="noopener">点击这里查看</a></p>
<h2 id="启用硬件加速"><a href="#启用硬件加速" class="headerlink" title="启用硬件加速"></a>启用硬件加速</h2><p>硬件加速选项可在“管理仪表板”的“ 转码”部分下找到。从下拉菜单中选择有效的硬件加速选项，指示设备（如果适用），并检查enable hardware encoding以启用编码以及解码（如果您的硬件支持）。</p>
<p>硬件加速可立即用于媒体播放。无需重新启动服务器。</p>
<p>每种硬件加速类型以及每种Jellyfin安装类型在使用前都需要不同的设置选项。始终最好参考您选择的加速度类型的FFMpeg文档以获取最新信息。</p>
<h3 id="Debian-Ubuntu上配置VAAPI加速"><a href="#Debian-Ubuntu上配置VAAPI加速" class="headerlink" title="Debian / Ubuntu上配置VAAPI加速"></a>Debian / Ubuntu上配置VAAPI加速</h3><p>在Debian / Ubuntu上配置VAAPI需要进行一些其他配置，以确保权限正确。</p>
<ol>
<li>验证render设备现在在中/dev/dri，并记下可写入该设备的权限和组，在这种情况下render：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;dev&#x2F;dri</span><br></pre></td></tr></table></figure>
查看是否有如下输出：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 100 Apr 13 16:37 by-path</span><br><span class="line">crw-rw---- 1 root video 226, 0 Apr 13 16:37 card0</span><br><span class="line">crw-rw---- 1 root video 226, 1 Apr 13 16:37 card1</span><br><span class="line">crw-rw---- 1 root render 226, 128 Apr 13 16:37 renderD128</span><br></pre></td></tr></table></figure>
如果没有，在确保你的设备支持硬件加速的情况下通过<a href="http://jellyfin.org/docs/general/administration/hardware-acceleration.html" target="_blank" rel="noopener">指导文件</a>来进行相关设备的配置以及验证。不同的硬件平台配置方法不一样，在此不展开详述。</li>
</ol>
<ol>
<li>将Jellyfin服务用户添加到上述组中，以允许Jellyfin的FFMpeg进程访问该设备，然后重新启动Jellyfin：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG render jellyfin</span><br><span class="line">sudo systemctl restart jellyfin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：在这里执行完第一条语句后可能会出现报错，这是因为在某些发行版本中，该组可能为video而不是render，将其更改过来即可。<br>在看了很多相关文章后，发现大家都没有配置这一步，这可能导致硬件转码没有办法正常工作。</p>
<p>注意：以下两点请在安装完成jellyfin后在来看</p>
<ol>
<li><p>在管理控制台的“代码转换”页面中配置VAAPI加速。输入/dev/dri/renderD128上面的设备作为VA API Device值。</p>
</li>
<li><p>观看电影，并通过使用或类似工具观看ffmpeg-transcode-*.txt日志来验证是否正在进行转码。</p>
</li>
</ol>
<h1 id="Ubuntu安装jellyfin"><a href="#Ubuntu安装jellyfin" class="headerlink" title="Ubuntu安装jellyfin"></a>Ubuntu安装jellyfin</h1><p>文章存在时效性，具体可参考<a href="http://jellyfin.org/docs/general/administration/installing.html#ubuntu" target="_blank" rel="noopener">官方指南</a></p>
<h2 id="迁移至新仓库"><a href="#迁移至新仓库" class="headerlink" title="迁移至新仓库"></a>迁移至新仓库</h2><p>早期的jellyfin在ubuntu的官方<code>apt-get</code>源中，现在已将其拆分成自己的存储库，以更好地处理单独的二进制程序包。如果遇到ubuntu找不到该发行版的错误，并且以前配置了<code>ubuntu jellyfin.list</code>文件，请按照以下步骤操作。</p>
<ol>
<li>删除旧的<code>/etc/apt/sources.list.d/jellyfin.list</code>文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jellyfin.list</span><br></pre></td></tr></table></figure></li>
<li>按照下面的方法步骤继续操作</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Jellyfin团队提供了一个Ubuntu存储库，可以在<code>Ubuntu Xenial/Bionic/Cosmic/Disco</code>上进行安装。支持的架构<code>amd64、arm64</code>和<code>armhf</code>。<code>Ubuntu Xenial</code> 仅支持 <code>amd64</code>。</p>
<p>注意：Microsoft不为32位x86 Linux系统提供.NET，因此<code>i386</code>体系结构不支持Jellyfin 。</p>
<ol>
<li><p>如果尚未安装APT的HTTPS传输，请执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-transport-https</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用Universe存储库以获取所有FFMpeg依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入GPG签名密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - https:&#x2F;&#x2F;repo.jellyfin.org&#x2F;ubuntu&#x2F;jellyfin_team.gpg.key | sudo apt-key add -</span><br></pre></td></tr></table></figure>
</li>
<li><p>在以下位置添加存储库配置<code>/etc/apt/sources.list.d/jellyfin.list</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch&#x3D;$( dpkg --print-architecture )] https:&#x2F;&#x2F;repo.jellyfin.org&#x2F;ubuntu $( lsb_release -c -s ) main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jellyfin.list</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：支持的版本是：<code>xenial</code>，<code>bionic</code>，<code>cosmic</code>，和<code>disco</code>。</p>
<ol>
<li>更新APT存储库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装Jellyfin：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install jellyfin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用您选择的工具管理Jellyfin系统服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart jellyfin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Docker安装jellyfin"><a href="#Docker安装jellyfin" class="headerlink" title="Docker安装jellyfin"></a>Docker安装jellyfin</h1><p>你可以到<a href="https://registry.hub.docker.com/r/jellyfin/jellyfin" target="_blank" rel="noopener">jellyfin官方docker hub</a>查看该项目的最新动态以及获得相关支持。</p>
<ol>
<li>获取docker镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull jellyfin&#x2F;jellyfin</span><br></pre></td></tr></table></figure></li>
<li>运行jellyfin<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8096:8096 \</span><br><span class="line">--name jellyfin \</span><br><span class="line">--restart always \</span><br><span class="line">-v 配置文件路径:&#x2F;config \</span><br><span class="line">-v 缓存文件路径:&#x2F;cache \</span><br><span class="line">-v 媒体路径1:&#x2F;media \</span><br><span class="line">-v 媒体路径2:&#x2F;media \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;renderD128:&#x2F;dev&#x2F;dri&#x2F;renderD128 \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;card0:&#x2F;dev&#x2F;dri&#x2F;card0 \</span><br><span class="line">--privileged&#x3D;true \</span><br><span class="line">--env GIDLIST&#x3D;44 \</span><br><span class="line">jellyfin&#x2F;jellyfin:latest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此，jellyfin的安装工作就算完成了。接下来进行相关的配置工作。</p>
<h1 id="jellyfin配置与使用"><a href="#jellyfin配置与使用" class="headerlink" title="jellyfin配置与使用"></a>jellyfin配置与使用</h1><h2 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h2><p>在浏览器中输入<code>服务器IP:8096</code>即可进入到jellyfin的web端。</p>
<ol>
<li><p>选择语言<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174755.jpg" alt="选择语言"></p>
</li>
<li><p>用户设置<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174819.jpg" alt="添加用户"></p>
</li>
<li><p>设置媒体库<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174832.jpg" alt="媒体库设置"></p>
</li>
<li><p>选择地区与语言<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174851.jpg" alt="选择地区与语言"></p>
</li>
<li><p>远程访问（默认即可）<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174902.jpg" alt="远程访问权限"></p>
</li>
<li><p>完成配置<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174912.jpg" alt="完成配置"></p>
</li>
<li><p>登录<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174925.jpg" alt="用户登录"></p>
</li>
<li><p>进入界面<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20174936.jpg" alt="主页面"></p>
</li>
</ol>
<h2 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h2><p>点击右上角小人，进入如下界面</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20181402.jpg" alt="个人设置"></p>
<p>选择显示菜单</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20181423.jpg" alt="显示配置"></p>
<p>这里选择自己喜欢的主题可以进行配置在上个页面中你也可以进行更多配置</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>选择左上角的<strong>三横图标</strong> —&gt; <strong>控制台</strong> —&gt; <strong>往下找到插件</strong> 来到下图所示的界面<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20182002.jpg" alt="插件"></p>
<p>我这里以及安装了很多插件了，如果你没有安装过，这里将显示空白。点击上方的目录可进入到插件目录</p>
<h3 id="字幕插件"><a href="#字幕插件" class="headerlink" title="字幕插件"></a>字幕插件</h3><p>在元素据中找到Open Subtitles，进去点击安装</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20182159.jpg" alt="字幕插件"></p>
<p>然后回到我的插件，点开Open Subtitles进入配置页面</p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20182318.jpg" alt="Open Subtitles配置"><br>输入用户名密码登录，没有的话可以到<a href="http://www.opensubtitles.org/" target="_blank" rel="noopener">opensubtitles官网</a>进行注册。</p>
<h3 id="KODI串流"><a href="#KODI串流" class="headerlink" title="KODI串流"></a>KODI串流</h3><p>在插件目录的常规栏目找到Kodi Sync Queue进行安装<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20182711.jpg" alt="KODI"></p>
<p>然后回到我的插件，进入KODI配置，全勾选上即可<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20182644.jpg" alt="KODI"></p>
<p>关于kodi的使用将在后期文章中进行介绍</p>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>其他插件可以根据自己的需要进行安装，可以参考其他同类文章，在此不进行详述。</p>
<h2 id="添加媒体库"><a href="#添加媒体库" class="headerlink" title="添加媒体库"></a>添加媒体库</h2><p>在控制台中进入到媒体库，可以看到添加媒体库的按钮，如下图<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20183340.jpg" alt="媒体库管理"><br>然后点击添加媒体库<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20183444.jpg" alt="添加媒体库"><br>选择对应的类型与名称，在文件夹处选择刚才对应的媒体库，docker安装的话媒体目录被映射到/media目录下。</p>
<p>点击左上角的显示高级设置<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20183808.jpg" alt="设置"></p>
<p>把除了上图没勾选的之外的全面勾选上。然后确认。之后会自动扫描和下载字幕，该过程有些漫长。<br>然后在主页就可以看到添加的媒体了<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20184026.jpg" alt="媒体"></p>
<p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20184239.jpg" alt="电影"></p>
<p>对于某些电影，会识别失败，这时我们需要手动识别，进入电影详情页面。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20184406.jpg" alt="电影详情"></p>
<p>然后点击播放 预告片后面的更多<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20184517.jpg" alt="更多"><br>然后选择对应的菜单进入操作即可。</p>
<h1 id="jellyfin播放设置"><a href="#jellyfin播放设置" class="headerlink" title="jellyfin播放设置"></a>jellyfin播放设置</h1><h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>硬件播放可以到控制台 —&gt; 播放进行设置<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20202112.jpg" alt="硬件加速"></p>
<p>可以参考上面的平台推荐加速器进行相关设置，我这里设置为VAAPI<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20202312.jpg" alt="加速方式"></p>
<p>VAAPI选择对应的硬件设备，确保你已依照上面的过程进行了相关的驱动设置。<br><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20202427.jpg" alt="加速设备"></p>
<p>其他参数可依照说明按需进行更改</p>
<h2 id="流媒体传输设置"><a href="#流媒体传输设置" class="headerlink" title="流媒体传输设置"></a>流媒体传输设置</h2><p><img src="https://raw.githubusercontent.com/yurui105/image/master/%E6%89%B9%E6%B3%A8%202019-12-31%20202647.jpg" alt="流媒体传输设置"><br>可依据自己的网络情况进行传输设置，这对于防止设备请求比 internet 连接所能处理的更高的比特率非常有用。这可能会导致服务器上的 CPU 负载增加, 以便将视频转码到较低的比特率。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本来想在一篇文章中对jellyfin做个详细的说明，但是发现那样文章就显得太过于长了。<br>下篇文章将对jellyfin的其他使用技巧做一个介绍，比如电影命名规范，格式选择等。<br>除此之外还会对jellyfin的使用过程中遇到的一些问题进行介绍，以及如何获取解决方案。</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>jellyfin</tag>
        <tag>影音服务</tag>
      </tags>
  </entry>
</search>
