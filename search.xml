<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++构造函数</title>
    <url>/2020/07/09/C++/10%E3%80%81C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在c++的类中，构造函数是一种特殊的成员函数，在每次创建创建一个类的时候会默认调用构造函数进行初始化工作。</p>
<p>构造函数用来完成一些必要的初始化工作，有了构造函数之后，就无需再单独写初始化函数，并且也不必担心忘记调用初始化函数。</p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>构造函数具有如下几个特点</p>
<ul>
<li>名字与类名相同，可以有参数，<strong>但是不能有返回值（void也不行）</strong></li>
<li>作用是对对象进行初始化工作，如给成员变量赋值等。</li>
<li>如果定义类时没有写构造函数，系统会生成一个<strong>默认的无参构造函数</strong>，默认构造函数没有参数，不做任何工作。</li>
<li>如果定义了构造函数，系统不再生成默认的无参构造函数</li>
<li>对象生成时构造函数自动调用，对象一旦生成，不能在其上再次执行构造函数</li>
<li>一个类可以有多个构造函数，为重载关系</li>
</ul>
<h1 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="默认无参构造函数"><a href="#默认无参构造函数" class="headerlink" title="默认无参构造函数"></a>默认无参构造函数</h2><p>下面来看一个简单的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> i)</span> </span>&#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的复数类，<code>real</code>表示实部，<code>imag</code>表示虚部，<code>set(set(double r, double i))</code>函数为初始化函数，我们并没有为其编写构造函数，此时编译系统将生成一个默认的无参构造函数。</p>
<p>假设有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Complex c1;<span class="comment">//默认构造函数被调用</span></span><br><span class="line">	Complex* c2 = <span class="keyword">new</span> Complex;<span class="comment">//默认构造函数被调用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象生成的时候，编译系统自动调用默认的无参构造函数对其进行初始化工作（什么都没做），此时我们必须自己调用<code>set(double r, double i)</code>函数才能对其进行初始化操作。</p>
<h2 id="编写构造函数"><a href="#编写构造函数" class="headerlink" title="编写构造函数"></a>编写构造函数</h2><p>接下来我们为上面的类编写一个构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Complex c1;<span class="comment">//错误，参数不匹配</span></span><br><span class="line">	Complex* c2 = <span class="keyword">new</span> Complex;<span class="comment">//错误，参数不匹配</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在调用上面的代码生成对象<code>c1</code>、<code>c2</code>时，编译系统会给我们报错。原因是我们编写的构造函数需要接收至少一个参数，而我们在初始化的时候没有给出任何的参数。</p>
<p>对上面的代码进行如下的改动：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">	Complex* c2 = <span class="keyword">new</span> Complex(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//OK</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<code>c1</code>、<code>c2</code>就可以正常地生成。</p>
<ul>
<li>对于<code>c1</code>对象，用<code>1</code>来初始化实部，用缺省的<code>0</code>初始化虚部。</li>
<li>对于<code>c2</code>对象，用<code>2</code>来初始化实部，用<code>5</code>初始化虚部。</li>
</ul>
<h1 id="构造函数重载"><a href="#构造函数重载" class="headerlink" title="构造函数重载"></a>构造函数重载</h1><p>对于同一个类，可以有多个构造函数，只要参数个数或类型不同就可，他们之间为重载的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	Complex();</span><br><span class="line">	Complex(<span class="keyword">double</span> r);</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i);</span><br><span class="line">	Complex(Complex c1, Complex c2);</span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex() &#123;</span><br><span class="line">	real = <span class="number">0</span>;</span><br><span class="line">	imag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r) &#123;</span><br><span class="line">	real = r;</span><br><span class="line">	imag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;</span><br><span class="line">	real = r;</span><br><span class="line">	imag = i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(Complex c1, Complex c2) &#123;</span><br><span class="line">	real = c1.real + c2.real;</span><br><span class="line">	imag = c1.imag + c2.imag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的类中，分别写了四个构造函数</p>
<ul>
<li><code>Complex()</code>无参构造函数，<code>real</code>和<code>imag</code>都初始化为<code>0</code></li>
<li><code>Complex(double r)</code>将<code>real</code>初始化为<code>r</code>，<code>imag</code>初始化为<code>0</code></li>
<li><code>Complex(double r, double i)</code>将<code>real</code>初始化为<code>r</code>，<code>imag</code>初始化为<code>i</code></li>
<li><code>Complex(Complex c1, Complex c2)</code>将<code>real</code>初始化为<code>c1.real + c2.real</code>，<code>imag</code>初始化为<code>c1.imag + c2.imag</code></li>
</ul>
<p>对于上面的类，假设我们有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Complex c1;<span class="comment">//调用Complex()构造函数</span></span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//调用Complex(double r)构造函数</span></span><br><span class="line">	<span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;<span class="comment">//调用Complex(double r, double i)构造函数</span></span><br><span class="line">	<span class="function">Complex <span class="title">c4</span><span class="params">(c1, c2)</span></span>;<span class="comment">//Complex(Complex c1, Complex c2)构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>c1</code>对象，调用<code>Complex()</code>无参构造函数，将<code>real</code>和<code>imag</code>都初始化为<code>0</code></li>
<li>对于<code>c2</code>对象，调用<code>Complex(double r)</code>构造函数，将<code>real</code>初始化为<code>2</code>，<code>imag</code>初始化为<code>0</code></li>
<li>对于<code>c3</code>对象，调用<code>Complex(double r, double i)</code>构造函数，将<code>real</code>初始化为<code>2</code>，<code>imag</code>初始化为<code>3</code></li>
<li>对于<code>c4</code>对象，调用<code>Complex(Complex c1, Complex c2)</code>将<code>real</code>初始化为<code>c1.real + c2.real=2</code>，<code>imag</code>初始化为<code>c1.imag + c2.imag=0</code></li>
</ul>
<h1 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h1><p>下面我们通过一个实例来查看对与对象数组是如何调用构造函数进行初始化的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	Complex() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"无参构造函数初始化"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(<span class="keyword">double</span> r) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数的构造函数初始化"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数的构造函数初始化"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们为上面的类写了三个构造函数，在调用无参构造函数时输出<code>无参构造函数初始化</code>，调用一个参数的构造函数时输出<code>一个参数的构造函数初始化</code>，调用两个构造函数初始化时输出<code>两个参数的构造函数初始化</code>。</p>
<p>假设我们有如下的对象生成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"array1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Complex array1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"array2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Complex array2[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"array3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Complex array3[<span class="number">3</span>] = &#123; <span class="number">1</span>,Complex(<span class="number">1</span>,<span class="number">2</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"array4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Complex* array4 = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"array5"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Complex* array5[<span class="number">3</span>] = &#123; <span class="keyword">new</span> Complex(<span class="number">1</span>),<span class="keyword">new</span> Complex(<span class="number">2</span>,<span class="number">3</span>) &#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">delete</span>[]array4;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>array1</code>生成的三个对象，我们没有为其指定参数，所以都调用无参构造函数进行初始化。</li>
<li>对于<code>array2</code>生成的三个对象，我们指定了前两个的参数表为<code>1</code>和<code>2</code>，所以调用一个参数的构造函数进行初始化，第三个对象没有指定参数，所以调用无参构造函数进行初始。</li>
<li>对于<code>array3</code>生成的三个对象，第一个对象参数为<code>1</code>，所以调用无参构造函数初始化，第二个对象参数为<code>(1,2)</code>，所以调用两个参数的构造函数初始化，对于第三个对象，我们没有指定参数，所以调用无参构造函数初始化。</li>
<li><code>array4</code>为一个<code>Complex</code>类的指针，通过<code>new</code>运算符动态分配三个对象，并将其首地址返回给<code>array4</code>，在此我们并没有为<code>new</code>出来的三个对象指定初始化参数，所以三个对象都调用无参构造函数初始化。</li>
<li><code>array5</code>为一个<code>Complex</code>类的指针数组，包含三个指针对象。第一个<code>new Complex(1)</code>生成了一个对象，且参数为<code>1</code>，所以调用一个参数的构造函数；第二个元素通过<code>new Complex(2,3)</code>生成一个对象，且参数为<code>(2,3)</code>，所以调用两个参数的构造函数；第三个我们没有为其动态分配内存空间，所以不会导致对象的生成，仅存在一个对象指针。所以<strong><code>array5</code>仅生成了两个对象</strong>。</li>
</ul>
<p>对于上面的程序，我们可以得到如下的运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array1</span><br><span class="line">无参构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">array2</span><br><span class="line">一个参数的构造函数初始化</span><br><span class="line">一个参数的构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">array3</span><br><span class="line">一个参数的构造函数初始化</span><br><span class="line">两个参数的构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">array4</span><br><span class="line">无参构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">无参构造函数初始化</span><br><span class="line">array5</span><br><span class="line">一个参数的构造函数初始化</span><br><span class="line">两个参数的构造函数初始化</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++类型转换构造函数以及析构函数</title>
    <url>/2020/07/11/C++/12%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>定义类型转换构造函数的目的是实现类型的自动转化</p>
</li>
<li><p>只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(<span class="keyword">int</span> r) &#123;<span class="comment">//类型转化构造函数</span></span><br><span class="line">		real = r;</span><br><span class="line">		imag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"int 类型转换构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(<span class="keyword">const</span> Complex&amp; c) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用复制构造函数！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的类，假设有如下实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	Complex c2 = <span class="number">3</span>;</span><br><span class="line">	c1 = <span class="number">9</span>;<span class="comment">//9被转换为一个临时complex对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化<code>c2</code>的时候，参数只有一个<code>3</code>，为<code>int</code>类型，所以类型转换构造函数被调用。</p>
<p>在执行<code>c1 = 9</code>的时候，由于<code>c1</code>已经存在，赋值号两边的类型不匹配，此时将调用类型转换构造函数将<code>9</code>转换为一个临时的<code>Complex</code>对象，在实现赋值。</p>
<p>所以以上的程序执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int 类型转换构造函数被调用</span><br><span class="line">int 类型转换构造函数被调用</span><br></pre></td></tr></table></figure>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>构造函数是在对象生成的时候起作用的，而<strong>析构函数(Destructor)</strong>正好与之相反，析构函数在对象消亡的时候起作用。</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li>名字与类名相同，在前面加上<code>~</code>，没有参数和返回值，一个类最多只能有一个析构函数。</li>
<li>析构函数在对象消亡时自动被调用，析构函数在对象消亡后做善后工作，比如释放内存空间。</li>
<li>如果没写析构函数，那么编译器将自动生成一个缺省的析构函数，缺省的析构函数什么也不做。</li>
<li>如果定义了析构函数，则编译器不再生成析构函数。</li>
</ul>
<p><a name="demo"></p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>有如下的<code>Demo</code>类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">	Demo() &#123;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	~Demo()&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]p;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>Demo</code>类生成时，动态申请了<code>char[20]</code>大小的空间。在对象消亡时，将释放这一部分空间并向屏幕输出：<code>析构函数被调用</code></p>
<p>对于上面的类，有如下的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Demo demo;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行可以得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>
<h2 id="析构函数和数组"><a href="#析构函数和数组" class="headerlink" title="析构函数和数组"></a>析构函数和数组</h2><p>如上面的<a href="#demo">Demo</a>类所示，假设我们如下所示生成一个对象数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Demo <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main end!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象数组<code>array</code>的声明周期结束的时候，三个数组对象会依次执行析构函数，输出如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">main end!</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>
<h2 id="析构函数和delete运算符"><a href="#析构函数和delete运算符" class="headerlink" title="析构函数和delete运算符"></a>析构函数和delete运算符</h2><p><code>delete</code>运算符会导致析构函数被调用，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">	Demo() &#123;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	~Demo()&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]p;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Demo* demo;</span><br><span class="line">	demo = <span class="keyword">new</span> Demo;</span><br><span class="line">	<span class="keyword">delete</span> demo;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行到<code>delete demo;</code>时，析构函数将会调用，产生如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>
<p>当<code>delete</code>一个指针数组时，该数组元素也会依次调用析构函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Demo* <span class="built_in">array</span>;</span><br><span class="line">	<span class="built_in">array</span> = <span class="keyword">new</span> Demo[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时析构函数将会被调用3次，产生如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>注意：</p><p>若<code>new</code>一个对象数组，那么使用<code>delete</code>释放时应该写<code>[]</code>，否则只<code>delete</code>一个对象，析构函数只被调用一次。</p>
          </div>
<h2 id="对象作为函数返回值返回后调用析构函数"><a href="#对象作为函数返回值返回后调用析构函数" class="headerlink" title="对象作为函数返回值返回后调用析构函数"></a>对象作为函数返回值返回后调用析构函数</h2><ul>
<li><p>当对象作为函数参数时，会导致复制构造函数的调用，同时在参数对象消亡时会导致析构函数被调用。</p>
</li>
<li><p>当对象作为函数放回值使用时，也会导致析构函数被调用</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">	Demo() &#123;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	~Demo()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Demo <span class="title">fun</span><span class="params">(Demo demo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	obj = fun(obj);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们定义了一个全局变量<code>Demo obj;</code>，当执行<code>fun(obj)</code>时，参数为一个对象，此时会导致析构函数被调用一次；</p>
<p>同时，<code>fun()</code>函数返回一个对象，当完成<code>obj = fun(obj);</code>的赋值后，析构函数也会被调用一次；</p>
<p>最后，全局变量<code>obj</code>消亡时析构函数在此被调用，所以以上样例产生如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>c++</tag>
        <tag>转换构造函数</tag>
        <tag>类型转换构造函数</tag>
        <tag>析构函数</tag>
        <tag>~运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>c++友元(friends)</title>
    <url>/2020/07/13/C++/14%E3%80%81c-%E5%8F%8B%E5%85%83-friend/</url>
    <content><![CDATA[<p>友元可以分为友元函数和友元类</p>
<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><h2 id="普通友元函数"><a href="#普通友元函数" class="headerlink" title="普通友元函数"></a>普通友元函数</h2><p>在c++中，我们通过类对数据进行了封装，并设置了可访问范围。但有时候我们需要在类外通过函数访问类中的私有成员，这时我们就可以将该函数声明为类的友元函数。</p>
<p>友元函数不是类的成员函数，只是一个普通的函数，在类中加上<code>friend</code>声明后，变为这个类的友元函数。一个类的友元函数可以访问这个类的私有成员。</p>
<a id="more"></a>
<p>假设有如下所示的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类有两个私有变量<code>name</code>以及<code>age</code>，并声明了一个友元函数<code>void getInfo(const Person&amp; p);</code>，<code>getInfo(const Person&amp; p)</code>为一个全局变量函数。</p>
<p>假设有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//输出Person类的私有变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"name："</span> &lt;&lt; p.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"age："</span> &lt;&lt; p.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"张三"</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">	getInfo(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初始化一个对象<code>p</code>，将<code>name</code>设为<code>张三</code>，<code>age</code>设置为<code>21</code>，然后通过友元函数<code>void getInfo(const Person&amp; p)</code>去访问这两个私有成员变量。</p>
<p>执行上面程序，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name：张三</span><br><span class="line">age：21</span><br></pre></td></tr></table></figure>
<p>通过结果，我们看到通过友元函数确实能访问到对象的使用成员变量。</p>
<h2 id="将一个类的成员函数声明为另一个类的友元函数"><a href="#将一个类的成员函数声明为另一个类的友元函数" class="headerlink" title="将一个类的成员函数声明为另一个类的友元函数"></a>将一个类的成员函数声明为另一个类的友元函数</h2><p>除了可以将普通函数声明为友元外，我们还可以将一个类的成员函数(包括构造函数以及析构函数)声明为另一个类的友元函数。</p>
<p>类似下面这种实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h1><p>如果<code>A</code>类是<code>B</code>类的友元类，那么通过<code>A</code>类的成员函数就可以访问<code>B</code>类的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span><span class="comment">//声明友元类</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAnimalName</span><span class="params">(Animal &amp;a)</span> </span>&#123;</span><br><span class="line">		a.name = <span class="string">"XXXXX"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将<code>Person</code>类声明为<code>Animal</code>类的友元类，那么在<code>Person</code>类中就可以访问<code>Animal</code>类的私有成员。</p>
<p>我们通过<code>Person</code>类的成员函数<code>setAnimalName()</code>对<code>Animal</code>类的对象进行赋值。</p>
<p>假设上面的类有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Animal dog;</span><br><span class="line">	Person p;</span><br><span class="line">	p.setAnimalName(dog);</span><br><span class="line">	dog.getName();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初始化一个<code>Animal</code>类对象<code>dog</code>以及一个<code>Person</code>类对象<code>p</code>，然后通过<code>p</code>的成员函数对<code>dog</code>对象私有成员进行赋值操作，最后调用<code>dog</code>类成员函数输出私有变量，查看私有变量值是否发生改变。</p>
<p>运行上面程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XXXXX</span><br></pre></td></tr></table></figure>
<p>证明确实能通过该类的友元类的成员函数访问该类的私有成员。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><strong>友元之间的关系不能传递，不能继承。</strong></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>friends</tag>
        <tag>友元</tag>
        <tag>友元函数</tag>
        <tag>友元类</tag>
      </tags>
  </entry>
  <entry>
    <title>c++复制构造函数</title>
    <url>/2020/07/10/C++/11%E3%80%81c++%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>复制构造函数</strong>(<strong>Copy constructor</strong>)是c++中的一个特殊构造函数，也称<strong>拷贝构造函数</strong>，它只有一个参数，参数类型为同类对象的引用。</p>
<p>如果没有定义复制构造函数，那么编译器将生成默认的复制构造函数。默认的复制构造函数完成复制的功能。<br><a id="more"></a></p>
<p>复制构造函数的参数为同类对象的引用，可以是常应用，也可以是非常引用。形如<code>类名::类名(类名&amp;)</code>或<code>类名::类名(const 类名&amp;)</code></p>
<h1 id="默认复制构造函数"><a href="#默认复制构造函数" class="headerlink" title="默认复制构造函数"></a>默认复制构造函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的复数类，假设我们有如下的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1.real="</span> &lt;&lt; c1.real &lt;&lt; <span class="string">"\tc1.imag="</span> &lt;&lt; c1.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//调用复制构造函数初始化c2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c2.real="</span> &lt;&lt; c2.real &lt;&lt; <span class="string">"\tc2.imag="</span> &lt;&lt; c2.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的初始化工作中，我们调用构造函数对<code>c1</code>进行初始化工作，然后输出<code>c1</code>的实部以及虚部。然后用<code>c1</code>去初始化<code>c2</code>，此时将调用编译器自动生成的构造函数将<code>c2</code>初始化为和<code>c1</code>一样，然后输出<code>c2</code>的实部以及虚部。运行上面的程序，得到如下的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c1.real=5       c1.imag=2</span><br><span class="line">c2.real=5       c2.imag=2</span><br></pre></td></tr></table></figure>
<p>可以看到此时<code>c2</code>被初始化为和<code>c1</code>相同。</p>
<p><a name="write"></p>
<h1 id="编写复制构造函数"><a href="#编写复制构造函数" class="headerlink" title="编写复制构造函数"></a>编写复制构造函数</h1><p>在上面的例子中，我们并没有编写复制构造函数，此时编译器将生成一个默认的复制构造函数完成复制工作。</p>
<p>当我们自己编写了复制构造函数之后，编译器将不再生成默认的复制构造函数。如下面的例子所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//分别表示实部以及虚部</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(<span class="keyword">const</span> Complex&amp; c) &#123;<span class="comment">//复制构造函数</span></span><br><span class="line">		real = c.real;</span><br><span class="line">		imag = c.imag;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用复制构造函数！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的类，在复制构造函数被调用的时候将完成复制的工作，并且向控制台输出<strong>调用复制构造函数！！</strong>，假设我们有如下的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1.real="</span> &lt;&lt; c1.real &lt;&lt; <span class="string">"\tc1.imag="</span> &lt;&lt; c1.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//调用复制构造函数初始化c2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c2.real="</span> &lt;&lt; c2.real &lt;&lt; <span class="string">"\tc2.imag="</span> &lt;&lt; c2.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后可以得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c1.real=5       c1.imag=2</span><br><span class="line">调用复制构造函数！！</span><br><span class="line">c2.real=5       c2.imag=2</span><br></pre></td></tr></table></figure>
<p>可以看到，此时我们自己编写的复制构造函数被调用，并且向屏幕输出了<strong>调用复制构造函数！！</strong>。</p>
<h1 id="错误用法"><a href="#错误用法" class="headerlink" title="错误用法"></a>错误用法</h1><p>复制构造函数的参数一定要是<strong>对同类对象的引用</strong>，不能为其它的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line">	Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex(Complex c) &#123;<span class="comment">//错误的写法</span></span><br><span class="line">		real = c.real;</span><br><span class="line">		imag = c.imag;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用复制构造函数！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们错误的将参数<code>Complex&amp; c</code>写为了<code>Complex c</code>，此时我们的编译将无法通过，在<code>visual studio 2019</code>中将得到以下的报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error C2652: “Complex”: 非法的复制构造函数: 第一个参数不应是“Complex”</span><br><span class="line">message : 参见“Complex”的声明</span><br><span class="line">error C2333: “Complex::Complex”: 函数声明中有错误；跳过函数体</span><br><span class="line">error C2558: class“Complex”: 没有可用的复制构造函数或复制构造函数声明为“explicit”</span><br></pre></td></tr></table></figure>
<p>总之，复制构造函数的参数一定要是<strong>同类对象的引用</strong>。</p>
<h1 id="复制构造函数起作用的情况"><a href="#复制构造函数起作用的情况" class="headerlink" title="复制构造函数起作用的情况"></a>复制构造函数起作用的情况</h1><h2 id="用一个对象来初始化正在构造的对象变量"><a href="#用一个对象来初始化正在构造的对象变量" class="headerlink" title="用一个对象来初始化正在构造的对象变量"></a>用一个对象来初始化正在构造的对象变量</h2><p>如上面<a href="#write">编写复制构造函数</a>小节中所展示的那样，当我们用同类的一个对象去初始化另一个对象时，会导致构造函数被调用。</p>
<p>需要注意的是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c3 = c1;<span class="comment">//初始化语句，非赋值语句</span></span><br></pre></td></tr></table></figure>
<p>上面的第三天语句为初始化语句，并非赋值语句。</p>
<h2 id="函数参数作为对象传值"><a href="#函数参数作为对象传值" class="headerlink" title="函数参数作为对象传值"></a>函数参数作为对象传值</h2><p>如果某函数有一个参数是类的对象，那么该函数被调用时，该类的复制构造函数将被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex() &#123;&#125;;</span><br><span class="line">	Complex(<span class="keyword">const</span> Complex&amp; c) &#123;<span class="comment">//复制构造函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用复制构造函数！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的类，假设我们有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Complex c)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Complex c;</span><br><span class="line">	fun(c);<span class="comment">//调用fun(Complex c)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们定义了一个函数<code>fun(Complex c)</code>，其参数为一个<code>Complex</code>对象，当我们在调用<code>fun(Complex c)</code>的时候，形参<code>c</code>将被初始化，此时将调用复制构造函数完成初始化工作，产生如下的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">调用复制构造函数！！</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果函数的参数为对象的引用或常引用时，将不会导致构造函数被调用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Complex &amp;c)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数返回一个对象"><a href="#函数返回一个对象" class="headerlink" title="函数返回一个对象"></a>函数返回一个对象</h2><p>如果函数的返回值是某类的对象，则函数返回时，复制构造函数将被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex() &#123;&#125;;</span><br><span class="line">	Complex(<span class="keyword">const</span> Complex&amp; c) &#123;<span class="comment">//复制构造函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用复制构造函数！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的类有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fun().real &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>fun()</code>返回一个<code>Complex</code>类的对象，在调用<code>fun()</code>函数时会导致复制构造函数被调用。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>上述情形未必会调用复制构造函数。因为C++标准允许编译器实现做一些优化。例如：<code>Class X b=X();</code></li>
</ul>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>当对象作为函数参数，在对函数进行调用时会调用复制构造函数对形参进行初始化工作，此时会产生额外的开销，我们可以将函数的参数写为对象的引用来避免额外的开销，如果担心对象的值在函数中会被改变，我们也可以用常引用的方式。</p>
<p>对于如下的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">fun</span><span class="params">(Complex c)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">fun</span><span class="params">(Complex&amp; c)</span></span>&#123;&#125;</span><br><span class="line"><span class="function">Complex <span class="title">fun</span><span class="params">(<span class="keyword">const</span> Complex&amp; c)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>c++</tag>
        <tag>复制构造函数</tag>
        <tag>拷贝构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ this 指针</title>
    <url>/2020/07/12/C++/13%E3%80%81this-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>this</code>指针是c++程序中的一个关键字，<code>this</code>指向当前对象，通过<code>this</code>指针可以访问当前对象的所有成员。</p>
<p><code>this</code> 只能用在类的内部，通过 <code>this</code> 可以访问类的所有成员，包括 <code>private</code>、<code>protected</code>、<code>public</code> 属性的成员。</p>
<a id="more"></a>
<p>所谓的<strong>当前对象</strong>指的是<strong>当前所使用的对象</strong>，下面我们通过一个例子来看<code>this</code>指针的作用。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;real = real;</span><br><span class="line">		<span class="keyword">this</span>-&gt;imag = imag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的复数类中，我们有一个构造函数，其作用是给<code>real</code>和<code>imag</code>赋值。其参数表中的参数名与成员变量名一致，在赋值时我们就会写成<code>real = real;</code>以及<code>imag = imag</code>，这样我们看不出到底是谁给谁赋值。</p>
<p>这时我们就可以用到<code>this</code>指针，将上面的式子写成<code>this-&gt;real = real;</code>，这样，就不难看出是用形参表的<code>real</code>给成员变量<code>real</code>赋值。</p>
<p>需要注意的是，<code>this</code> 是一个指针，要用<code>-&gt;</code>来访问成员变量或成员函数。</p>
<h1 id="验证this指针"><a href="#验证this指针" class="headerlink" title="验证this指针"></a>验证this指针</h1><p>我们修改上面的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;real = r;<span class="comment">//等价于real = r</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;imag = i;<span class="comment">//等价于imag = i</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"this：%p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c1:%p\n"</span>, &amp;c1);</span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c2:%p\n"</span>, &amp;c2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，我们使用<code>printf</code>函数输出<code>this</code>指针的值，同时，在<code>main</code>函数里，我们打印出<code>c1</code>以及<code>c2</code>的值。</p>
<p>运行上面的程序，可以得到如下所示结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">this：00000037490FF8A0</span><br><span class="line">c1:00000037490FF8A0</span><br><span class="line">this：00000037490FF8B0</span><br><span class="line">c2:00000037490FF8B0</span><br></pre></td></tr></table></figure>
<p>我们可以看到，构造<code>c1</code>时所用到的<code>this</code>指针地址与直接输出的<code>c1</code>的地址相同，都是<code>00000037490FF8A0</code>，对于<code>c2</code>也是同理。</p>
<p>我们可以得出结论，<code>this</code>指针指向的就是当前所使用的对象。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>this指针</tag>
        <tag>this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载基本概念</title>
    <url>/2020/07/14/C++/17%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="运算符重载的需求"><a href="#运算符重载的需求" class="headerlink" title="运算符重载的需求"></a>运算符重载的需求</h1><p>在数学上，两个复数是允许直接进行加减运算的。在c++中，我们用类来实现复数的表达，但是直接将<code>+</code>或<code>-</code>用于复数对象是不允许的。</p>
<p>有时候我们希望让对象也能通过运算符进行运算，这样代码更加简洁，容易理解。</p>
<a id="more"></a>
<p>例如：</p>
<p><code>complex_a</code>和<code>complex_b</code>是两个复数对象，求两个复数的和，我们希望能写成：<code>complex_a + complex_b</code>的形式。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>运算符重载就是对c++已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。</li>
<li>运算符重载的目的是扩展c++中提供的运算符的适用范围，使之能作用于对象上。</li>
<li>同一运算符，对不同类型的操作数，所发生的行为不同。</li>
</ul>
<h1 id="运算符重载的形式"><a href="#运算符重载的形式" class="headerlink" title="运算符重载的形式"></a>运算符重载的形式</h1><ul>
<li>运算符重载的实质是函数重载</li>
<li>运算符可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换为对运算符函数的调用。</li>
<li>把运算符的操作数转换为运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<p>运算符重载的基本形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="重载为成员函数"><a href="#重载为成员函数" class="headerlink" title="重载为成员函数"></a>重载为成员函数</h2><p>我们有如下的复数类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//实部、虚部</span></span><br><span class="line">	Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) &#123;</span><br><span class="line">		real = r; imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c) &#123;<span class="comment">//重载为成员函数</span></span><br><span class="line">		<span class="comment">//返回一个新的临时对象</span></span><br><span class="line">		<span class="keyword">return</span> Complex(real - c.real, imag - c.imag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在<code>Complex</code>类中重载了<code>-</code>号运算符，其参数为一个对象。</p>
<p>为什么参数为一个对象，而不是两个？</p>
<p>我们都知道成员函数是作用在某个具体的对象上的，所以当我们把运算符重载为某个类的成员函数的时候，该函数就必须作用在某个具体的对象上，从而只需要再有一个对象，就能完成二目运算符的操作。</p>
<p>对于上面的类，我们有如下的调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">	Complex c = c1 - c2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c.real="</span> &lt;&lt; c.real &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c.imag="</span> &lt;&lt; c.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初始化了三个<code>Complex</code>类对象<code>c1</code>、<code>c2</code>以及<code>c</code>，其中<code>c=c1-c2</code>。</p>
<p>运行上面的程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c.real=-4</span><br><span class="line">c.imag=-4</span><br></pre></td></tr></table></figure>
<p>将<code>-</code>号重载为成员函数，<code>c1-c2</code>就等价于<code>c1.operator-(c2)</code>。</p>
<h2 id="重载为普通函数"><a href="#重载为普通函数" class="headerlink" title="重载为普通函数"></a>重载为普通函数</h2><p>对于上面的复数类，我们将其<code>+</code>运算符重载为普通函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; c1, <span class="keyword">const</span> Complex&amp; c2) &#123;</span><br><span class="line">	<span class="comment">//返回一个临时对象</span></span><br><span class="line">	<span class="keyword">return</span> Complex(c1.real + c2.real, c1.imag + c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">	Complex c = c1 + c2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c.real="</span> &lt;&lt; c.real &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c.imag="</span> &lt;&lt; c.imag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们把运算符重载为普通函数的时候，就需要两个参数才能完成二目运算符的基本操作。<code>c=c1+c2</code>就等价于<code>operator+(c1,c2)</code></p>
<p>执行上面程序，得到下面的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c.real=6</span><br><span class="line">c.imag=8</span><br></pre></td></tr></table></figure>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul>
<li>重载为成员函数时，参数个数为运算符目数减一</li>
<li>重载为普通函数时，参数个数为运算符目数</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>c++静态成员变量以及静态成员函数</title>
    <url>/2020/07/12/C++/16%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>静态成员：在说明前加上<code>static</code>关键字的成员为静态成员。</li>
<li>静态函数：在函数声明前加上<code>static</code>关键字的函数就是静态成员函数。</li>
</ul>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum_of_numbers;<span class="comment">//静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_sum_of_numbers</span><span class="params">()</span></span>&#123;<span class="comment">//静态函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum of numbers is :"</span> &lt;&lt; sum_of_numbers &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>sum_of_numbers</code>就是静态成员变量，<code>void print_sum_of_numbers()</code>就是静态成员函数。</p>
<ul>
<li>普通成员变量为每个对象各自有一份，而静态成员变量一共就一份，为所有成员所共享。</li>
<li><code>sizeof</code>运算符不计算静态成员变量。</li>
<li>普通成员函数必须作用于某个具体的对象，而静态成员变量不作用于某个具体的变量。</li>
<li>静态成员不需要通过对象就能访问。</li>
<li>静态成员变量的本质是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。</li>
<li>静态成员函数本质上全局函数</li>
<li>设置静态成员的目的是将某些紧密联系的全局变量写到类里，看上去像一个整体，易于维护和理解。</li>
<li><strong>在静态成员函数中，只能访问静态成员变量以及函数。</strong></li>
</ul>
<h1 id="静态成员变量的访问"><a href="#静态成员变量的访问" class="headerlink" title="静态成员变量的访问"></a>静态成员变量的访问</h1><p>例如有如下的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum_of_numbers;<span class="comment">//记录对象总数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person() &#123;</span><br><span class="line">		sum_of_numbers++;<span class="comment">//对象总数加一</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_sum_of_numbers</span><span class="params">()</span></span>&#123;<span class="comment">//静态函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum of numbers is :"</span> &lt;&lt; sum_of_numbers &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		sum_of_numbers--;<span class="comment">//对象总数减一</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用如下几种方式访问静态成员：</p>
<ol>
<li>类名<code>::</code>成员名：<code>Person::print_sum_of_numbers();</code></li>
<li>对象名<code>.</code>成员名：<code>Person p1;  p1.print_sum_of_numbers();</code></li>
<li>指针<code>-&gt;</code>成员名：<code>Person *p=&amp;p1;  p-&gt;print_sum_of_numbers();</code></li>
<li>引用<code>.</code>成员名：<code>Person &amp;ref=r; int n=ref.sum_of_numbers;</code></li>
</ol>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>接下来我们通过一个实例来讲解静态成员的用法。</p>
<p>首先我们定义一个<code>Person</code>类，用<code>sum_of_numbers</code>来统计一个初始化了多少个对象，用<code>print_sum_of_numbers()</code>输出</p>
<p><code>sum_of_numbers</code>统计的数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum_of_numbers;<span class="comment">//记录对象总数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person() &#123;</span><br><span class="line">		sum_of_numbers++;<span class="comment">//对象总数加一</span></span><br><span class="line">	&#125;</span><br><span class="line">	Person(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		sum_of_numbers++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_sum_of_numbers</span><span class="params">()</span></span>&#123;<span class="comment">//静态函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum of numbers is :"</span> &lt;&lt; sum_of_numbers &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		sum_of_numbers--;<span class="comment">//对象总数减一</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::sum_of_numbers = <span class="number">0</span>;<span class="comment">//显示声明</span></span><br></pre></td></tr></table></figure>
<p>以上就定义了一个<code>Person</code>类，每当构造函数被调用，就会导致一个对象的生成，所以这里有<code>sum_of_numbers++;</code></p>
<p>对于复制构造函数，我们在前面以及了解过当对象作为函数参数以及返回值等使用时会导致新的临时对象的生成，会调用复制构造函数进行初始化工作，所以这里我们需要自己写一个构造函数，并在构造函数里执行<code>sum_of_numbers++;</code>。</p>
<p>另外需要注意的是，对于<code>static</code>类型的成员变量，我们需要在定义类的文件中对静态成员变量进行一次说明或初始化。否则的话<strong>编译能通过，链接不能通过</strong>，上面代码中的最后一行<code>int Person::sum_of_numbers = 0;//显示声明</code>进行声明。</p>
<p>每当析构函数被调用时，会导致对象的消亡，所以执行<code>sum_of_numbers--;</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">fun</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入fun函数，参数为一个Person对象,并返回一个person对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Person::print_sum_of_numbers();</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"生成p1对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Person p1;</span><br><span class="line">	Person::print_sum_of_numbers();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"生成p2对象数组，包含3个对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Person* p2 = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line">	p2-&gt;print_sum_of_numbers();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用fun函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Person p3=fun(p1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开fun函数，并生成一个person对象p3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Person::print_sum_of_numbers();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete对象数组p2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span>[]p2;</span><br><span class="line">	Person::print_sum_of_numbers();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>首先生成<code>p1</code>，所以<code>sum_of_numbers=1</code></li>
<li>生成对象数组<code>p2</code>，包含三个对象，所以<code>sum_of_numbers=4</code></li>
<li>调用<code>fun</code>函数，参数类型为<code>Person</code>对象，导致一个对象生成，所以<code>sum_of_numbers=5</code></li>
<li><code>fun</code>返回一个对象，此时<code>fun</code>参数生成的对象消亡，<code>sum_of_numbers=4</code></li>
<li>注意，此处使用<code>visual studio 2019</code>，对象作为函数返回值并没有导致对象生成。不同编译器结果不同。</li>
<li><code>p3</code>使用<code>fun</code>的返回值初始化，导致一个对象的生成，所以<code>sum_of_numbers=5</code></li>
<li><code>delete</code>掉<code>p2</code>对象数组，包含3个对象，所以<code>sum_of_numbers=2</code></li>
</ol>
<p>执行上面代码，得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">生成p1对象</span><br><span class="line">sum of numbers is :1</span><br><span class="line">生成p2对象数组，包含3个对象</span><br><span class="line">sum of numbers is :4</span><br><span class="line">调用fun函数</span><br><span class="line">进入fun函数，参数为一个Person对象,并返回一个person对象</span><br><span class="line">sum of numbers is :5</span><br><span class="line">离开fun函数，并生成一个person对象p3</span><br><span class="line">sum of numbers is :5</span><br><span class="line">delete对象数组p2</span><br><span class="line">sum of numbers is :2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>static</tag>
        <tag>静态成员</tag>
        <tag>静态函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c++常量对象、常量成员函数以及常引用</title>
    <url>/2020/07/13/C++/15%E3%80%81%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h1><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加上<code>const</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		value = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于上面的类，我们可以通过<code>setValue(int n)</code>成员函数给成员变量<code>value</code>赋值。如果我们在定义对象时在前面加上<code>const</code>关键字，就不能再通过<code>setValue(int n)</code>函数去修改成员变量了。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	const Test test;</span><br><span class="line">	test.setValue(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将<code>test</code>对象声明为<code>const</code>常对象，此时就不能用<code>test.setValue(1);</code>去修改成员变量<code>value</code>的值。</p>
<p>常对象一旦初始化成功，就不能再去修改其值。</p>
<h1 id="常量函数"><a href="#常量函数" class="headerlink" title="常量函数"></a>常量函数</h1><p>在类的成员函数后面加上<code>const</code>关键字，则该成员函数成为常量成员函数。</p>
<p>常量成员函数执行期间<strong>不应修改其所作用的对象</strong>。因此，在常量成员函数中不能修改成员变量的值(静态成员对象除外)，也不能调用同类的非常量成员函数(静态成员函数除外)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::getValue</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	value = <span class="number">0</span>;<span class="comment">//错误</span></span><br><span class="line">	func();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码所示，我们将<code>getValue()</code>函数修饰为常量成员函数，我们就不能再通过该常量成员函数去修改成员变量<code>value = 0</code>，也不能调用非常量成员函数<code>func()</code>。</p>
<p>假设对于上面的类有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Test test;</span><br><span class="line">	test.value = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	test.func();<span class="comment">//错误</span></span><br><span class="line">	test.getValue();<span class="comment">//OK</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个常量对象<code>test</code>，有以下几个注意事项：</p>
<ul>
<li>不能通过常量对象去修改成员变量。如<code>test.value = 100;</code></li>
<li>不能通过常量对象调用非常量成员函数。如<code>test.func();</code></li>
<li><strong>可以通过常量对象调用常量成员函数</strong>。如<code>test.getValue();</code></li>
</ul>
<h1 id="常量成员函数的重载"><a href="#常量成员函数的重载" class="headerlink" title="常量成员函数的重载"></a>常量成员函数的重载</h1><p>两个成员函数，名字和参数表都一样，但是一个是<code>const</code>，一个不是。他们之间算重载关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Test() &#123; value = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面的类，有两个<code>getValue()</code>函数，一个是<code>const</code>，一个不是。<code>const</code>类型的常量成员函数返回<code>1</code>，普通的函数返回<code>2</code>。</p>
<p>它们之间该怎么调用呢？我们通过一个例子来讲解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Test const_test;</span><br><span class="line">	Test test;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; const_test.getValue() &lt;&lt; <span class="string">","</span> &lt;&lt; test.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了两个<code>Test</code>类的对象<code>const_test</code>以及<code>test</code>，其中<code>const_test</code>为<code>const</code>类型。我们分别输出两个对象的<code>getValue()</code>的返回值，得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure>
<p>对于<code>const_test</code>对象，由于其为常量对象，所以只能调用常量成员函数，故匹配到函数<code>getValue()const</code>输出<code>1</code></p>
<p>对于<code>test</code>对象，由于其是非常量的对象，所以作用在其上的也为非常量成员函数<code>getValue()</code>，输出<code>2</code></p>
<h1 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h1><p>引用前面可以加<code>const</code>关键字，成为常引用，不能通过常引用，修改其引用的变量。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r=n;</span><br><span class="line">r=<span class="number">5</span>;<span class="comment">//错误</span></span><br><span class="line">n=<span class="number">5</span>;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<h2 id="常引用作为函数参数"><a href="#常引用作为函数参数" class="headerlink" title="常引用作为函数参数"></a>常引用作为函数参数</h2><p>我们知道，对象作为函数参数时，生成该参数需要调用复制构造函数，效率比较低。</p>
<p>如果将参数改为对象的引用，此时可以避免复制构造函数的调用，但是此时被引用的对象又是不安全的，我们可能在函数执行期间修改了对象的值。</p>
<p>这时，我们就可以将参数改为对象的常引用，不仅避免了额外的开销，也使得被引用对象是安全的。</p>
<p>如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> Sample&amp; e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>const</tag>
        <tag>常量对象</tag>
        <tag>常量成员函数</tag>
        <tag>常引用</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ const关键字使用</title>
    <url>/2020/05/31/C++/1%E3%80%81C-const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="const定义常量"><a href="#const定义常量" class="headerlink" title="const定义常量"></a><code>const</code>定义常量</h1><p>在c语言中，我们学习过可以使用<code>#define</code>来定义常量。但是<code>#define</code>的原理是简单的替换，因此对于<code>#define</code>来说没有类型检查这回事。</p>
<p>c++中提供了<code>const</code>关键字，用<code>const</code>关键字修饰的变量其值是不能修改的，因此可以使用<code>const</code>关键字来替换<code>#define</code>，这有益于编译器进行类型检查。</p>
<a id="more"></a>
<p><code>const</code>关键字定义变量如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> NAME[] = <span class="string">"yurui"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MAX = PI;<span class="comment">//报错</span></span><br><span class="line">	<span class="keyword">int</span> a = PI;<span class="comment">//警告</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序所示，使用<code>const</code>关键字定义了<code>MAX</code>、<code>PI</code>、<code>NAME</code>三个全局变量。</p>
<p>通过<code>MAX = PI;</code>对const修饰的变量进行赋值时会报错；通过<code>int a = PI;</code>进行赋值时编译系统会给出警告，提示类型不符合。</p>
<p>通过上面的例子，我们可以看出，通过使用<code>const</code>关键字修饰常量，在使用时编译系统会进行类型检查。</p>
<h1 id="const定义常量指针"><a href="#const定义常量指针" class="headerlink" title="const定义常量指针"></a><code>const</code>定义常量指针</h1><p>通过<code>const</code>关键字定义常量指针，这样就不能通过指针修改变量的值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	*p = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">    a = <span class="number">100</span>;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的程序，定义常指针<code>p</code>,当我们通过<code>p</code>去修改其所指向的值时，编译器就会对其报错。</p>
<p>但通过变量名还是可以修改其值，如<code>a = 100;</code>。</p>
<p>另外，观察下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* a;</span><br><span class="line">	<span class="keyword">int</span>* b;</span><br><span class="line">	a = b;<span class="comment">//正确</span></span><br><span class="line">	b = a;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于常指针，我们可以直接对其赋值，如<code>a = b;</code>；对于非常量指针，我们不能使用常量指针对其进行赋值，如<code>b = a;</code>。</p>
<h1 id="const修饰引用对象"><a href="#const修饰引用对象" class="headerlink" title="const修饰引用对象"></a><code>const</code>修饰引用对象</h1><p>引用也可以用<code>const</code>关键字修饰，这样就不能通过引用名来修改变量值了。</p>
<p>如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; r = a;</span><br><span class="line">    a = <span class="number">10</span>;<span class="comment">//正常</span></span><br><span class="line">	r = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>r=10;</code>这条语句时编译器会报错，提示<strong>表达式必须是可修改的左值</strong>，因为我们再初始化引用时将其加上了了<code>const</code>关键字，我们就不能通过引用名来修改变量的值了。</p>
<p>对于<code>a = 10;</code>这条语句则执行正常，因为a没有<code>const</code>关键字修饰。</p>
<p>再考量下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;<span class="comment">//错误</span></span><br><span class="line">	r = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	a = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于用<code>const</code>关键字修饰的变量，我们在为其创建引用对象时，任然需要创建<code>const</code>类型的引用对象，且无法通过变量名或引用名来修改变量的值。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>const</tag>
        <tag>常引用</tag>
        <tag>const关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>c++赋值运算符的重载</title>
    <url>/2020/07/14/C++/18%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="赋值运算符重载需求"><a href="#赋值运算符重载需求" class="headerlink" title="赋值运算符重载需求"></a>赋值运算符重载需求</h1><p>有时候我们希望运算符两边的类型可以不匹配。比如，把一个<code>int</code>类型的变量赋值给一个对象，或者把<code>char*</code>类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符<code>=</code>。</p>
<a id="more"></a>
<p>需要注意的是，<strong>赋值运算符只能重载为成员函数</strong>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">String</span>()&#123;</span><br><span class="line">		str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		str[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">	~<span class="keyword">String</span>()&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s) &#123;</span><br><span class="line">	<span class="comment">//重载=号使得字符串给对象赋值能成立</span></span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面我们简单地实现了一个<code>String</code>类，有一个私有的<code>char*</code>类型的指针，用来存放字符串的地址。</p>
<p>我们还重载了<code>=</code>号运算符，目的是能用字符串给对象赋值，所以参数为一个<code>const char *</code>的一个变量。在函数内部，我们首先需要<code>delete</code>掉原来的<code>str</code>，然后再重新为<code>str</code>分配内存空间，大小为参数中字符串的大小加一，<code>+1</code>的目的是为了存放字符串末尾的<code>\0</code>，然后将参数<code>s</code>中的内容通过<code>strcpy</code>函数复制到<code>str</code>当中，最后返回这个对象的引用。</p>
<p>下面来看一个应用实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//String s = "hello";//错误写法</span></span><br><span class="line">	<span class="keyword">String</span> s;</span><br><span class="line">	s = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	s = <span class="string">"world"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要注意，不能写成上面第一句<code>String s = &quot;hello&quot;;</code>，<strong>在这里<code>=</code>是初始化语句，不是赋值语句</strong>，所以需要用构造函数初始化，这里没有为其写这样的构造函数，所以会出错。</p>
<p>首先我们初始化一个<code>s</code>对象，然后用<code>hello</code>为其赋值，并调用<code>c_str()</code>输出<code>s</code>对象内的值。然后给<code>s</code>对象重新赋值，再输出。</p>
<p>执行上面的程序，我们可以得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>可以看到，在重新赋值后<code>world</code>覆盖掉了原来的<code>hello</code>。</p>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>还是上面的例子，如果我们希望能实现下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1, s2;</span><br><span class="line">s1 = <span class="string">"hello"</span>;</span><br><span class="line">s2 = <span class="string">"world"</span>;</span><br><span class="line">s1 = s2;</span><br></pre></td></tr></table></figure>
<p>我们可以看出，前两句的赋值实现都没有问题，用我们前面重载的<code>=</code>运算符就可以实现。</p>
<p>对于<code>s1=s2</code>，我们希望可以将<code>s1</code>里面的内容都变得跟<code>s2</code>一样，由于两边的参数类型是相同的，即使我们不再为其重载<code>=</code>运算符，编译也能通过，但对于这样一个表达式，它是否是安全的呢？</p>
<p>下面我们来看一张图：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200714155329348.png" alt="s1=s2过程"></p>
<p>通过上面的图，我们可以看到，在执行<code>s1=s2</code>之后，如果等号没有经过重载，那么原生的等号的目的是使得<code>=</code>左右两边的字节变得全部相等。此时<code>s1</code>里面的<code>str</code>就指向了<code>s2</code>里面的<code>str</code>，也就是说<code>s1</code>和<code>s2</code>指向了同一片空间。</p>
<p>这样做之后会带来一系列问题：</p>
<ul>
<li>原先存储<code>hello</code>的这片空间被直接废弃，且这片空间没有被<code>delete</code>，以后不会被<code>delete</code>。产生了内存垃圾。</li>
<li>如果<code>s1</code>先消亡，析构函数就将释放掉<code>str</code>，此时导致<code>s2</code>对象的<code>str</code>变为空，且在<code>s2</code>消亡时析构函数还会释放一次<code>str</code>的空间。这将导致程序运行错误。</li>
<li>如果将<code>s1</code>或<code>s2</code>再赋值时，重载的<code>=</code>运算符也会<code>delete</code>掉<code>str</code>，导致和上面一样的错误。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如何解决上面出现的问题呢？方法是我们需要对<code>s1=s2</code>这种情况重载<code>=</code>号运算符，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">String</span>()&#123;</span><br><span class="line">		str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		str[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">	<span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; s);</span><br><span class="line">	~<span class="keyword">String</span>()&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s) &#123;</span><br><span class="line">	<span class="comment">//重载=号使得字符串给对象赋值能成立</span></span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重载=运算符，使得s1=s2成立</span></span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时调用<code>s1=s2</code>这样的语句时，就相当于调用<code>s1.operator=(s2)</code>。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>考虑如下代码是否正确：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s;</span><br><span class="line">s = <span class="string">"hello"</span>;</span><br><span class="line">s = s;</span><br></pre></td></tr></table></figure>
<p>当我们在执行<code>s=s</code>时，将调用以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重载=运算符，使得s1=s2成立</span></span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先该函数会<code>delete</code>掉<code>str</code>，由于<code>=</code>号两边都是同一个对象，此时再执行后面的代码时就会导致错误。我们应该在入口处增加一些判断语句如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重载=运算符，使得s1=s2成立</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;s)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[]str;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断<code>=</code>号两边是否是同一个对象，是则直接返回。</p>
<h1 id="对operator-返回值类型讨论"><a href="#对operator-返回值类型讨论" class="headerlink" title="对operator=返回值类型讨论"></a>对operator=返回值类型讨论</h1><p>为什么返回值是<code>String &amp;</code></p>
<p>对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性。</p>
<p>例如对于下面的运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a=b=c</span><br><span class="line">(a=b)=c</span><br></pre></td></tr></table></figure>
<p>对于<code>=</code>运算符，它的结合方向为从右到左，对于第一个表达式，<code>a</code>是等于<code>b=c</code>的返回值的，如果不是同类对象，接下来的<code>a=</code>将无法计算。</p>
<p>看第二个运算，首先需要执行<code>a=b</code>将<code>a、b</code>的值变为一样，然后再将<code>c</code>的值赋给<code>a=b</code>的返回值，即<code>&amp;a</code>。</p>
<p>所以赋值运算符的返回值应该为同类对象的引用。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>运算符重载</tag>
        <tag>赋值运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>c++运算符重载为友元函数</title>
    <url>/2020/07/14/C++/19%E3%80%81c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<p>一般情况下，将运算符重载为成员函数是比较好的选择。</p>
<p>但有时候，重载为成员函数又不能满足需求，重载为普通函数，又不能访问类的私有成员，这时我们就需要将运算符重载为友元。</p>
<a id="more"></a>
<p>下面来看一个例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;<span class="comment">//实部、虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) &#123;</span><br><span class="line">		real = r; imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r) &#123;<span class="comment">//重载为成员函数</span></span><br><span class="line">		<span class="comment">//重载+运算符实现 c1+5</span></span><br><span class="line">		<span class="keyword">return</span> Complex(real + <span class="number">5</span>, imag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们为上面的<code>Complex</code>重载了<code>+</code>运算符，使得能够实现对象加上一个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	Complex c2;</span><br><span class="line">	c2 = c1 + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>c2 = c1 + 5;</code>在重载了<code>+</code>运算符之后就能正常解释了。</p>
<p>有时候我们希望不仅能实现<code>c1+5</code>，还能实现<code>5+c1</code>这种表达，这时简单地重载为成员函数就不能满足需求了，我们需要将<code>+</code>号重载为普通函数。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r, <span class="keyword">const</span> Complex&amp; c2) &#123;</span><br><span class="line">	<span class="comment">//解释5+c这种情况</span></span><br><span class="line">	<span class="keyword">return</span> Complex(r + c2.real, c2.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面地重载，看似可以解决问题，但是由于<code>real</code>和<code>imag</code>时私有成员变量，此时我们无法通过<code>c2</code>直接访问到私有成员变量。</p>
<p>这是就需要我们将这个普通函数声明为类的友元函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//实部、虚部</span></span><br><span class="line">	Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) &#123;</span><br><span class="line">		real = r; imag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r) &#123;<span class="comment">//重载为成员函数</span></span><br><span class="line">		<span class="comment">//重载+运算符实现 c1+5</span></span><br><span class="line">		<span class="keyword">return</span> Complex(real + <span class="number">5</span>, imag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r, <span class="keyword">const</span> Complex&amp; c2);<span class="comment">//声明为友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时我们就能实现<code>5+c</code>这种运算了。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>c++继承及派生基本概念</title>
    <url>/2020/07/30/C++/23%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%B4%BE%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>继承：在定义一个新的类<code>B</code>时，如果该类与某个已有的类<code>A</code>相似（<code>B</code>拥有<code>A</code>的全部特征），那么就可以把<code>A</code>作为一个<strong>基类</strong>，而把<code>B</code>作为基类的一个<strong>派生类</strong>（也成为子类）。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量或成员函数。</li>
<li>派生类一旦定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量。不论是<code>public</code>、<code>protected</code>还是<code>private</code>。</li>
<li>在派生类的各个成员函数中，不能访问基类的<code>private</code>成员</li>
</ul>
<a id="more"></a>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>假设我们需要编写一个学生类，我们可以先将其基本信息抽象出来组成一个基类。</p>
<p>所有学生都有的共同属性：</p>
<ul>
<li>姓名</li>
<li>学号</li>
<li>性别</li>
<li>成绩</li>
</ul>
<p>所有学生都共有的方法：</p>
<ul>
<li>是否留级</li>
<li>是否奖励</li>
</ul>
<p>而不同种类的学生，又有各自不同的种类和方法，例如：</p>
<p>研究生</p>
<ul>
<li>导师</li>
<li>系</li>
</ul>
<p>大学生</p>
<ul>
<li>系</li>
</ul>
<p>中学生</p>
<ul>
<li>特长加分</li>
</ul>
<p>此时我们可以将上面的学生类作为基类派生出研究生类、大学生类以及中学生类</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="派生类基本写法格式"><a href="#派生类基本写法格式" class="headerlink" title="派生类基本写法格式"></a>派生类基本写法格式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名：<span class="title">public</span> 基类名&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isThreeGood</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123; <span class="keyword">this</span>-&gt;name = name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergraduateStudent</span> :</span><span class="keyword">public</span> Student &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> department;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isThreeGood</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//覆盖基类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，<code>UndergraduateStudent</code>类从<code>Student</code>类派生得到，所以<code>UndergraduateStudent</code>拥有基类的全部属性。</p>
<p>需要注意的是，在<code>UndergraduateStudent</code>类中，我们再次定义了函数<code>isThreeGood()</code>，与基类中的相同，此时派生类中的该函数会对基类中的该函数进行覆盖。也就是说，当我们直接调用<code>isThreeGood()</code>时调用的是派生类中的该函数，如果需要调用基类的<code>isThreeGood()</code>,我们需要将其写成<code>Student::isThreeGood()</code>。</p>
<h1 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h1><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置于派生类对象新增的成员变量之前。</p>
<p>例如上面的学生类以及研究生类的存储关系可由下图表示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200730234817787.png" alt="派生类对象的内存空间"></p>
<h1 id="派生类样例"><a href="#派生类样例" class="headerlink" title="派生类样例"></a>派生类样例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> ID, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ID = ID;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"name:"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; ID &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergraduateStudent</span> :</span><span class="keyword">public</span> Student &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> department;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(<span class="built_in">string</span> name, <span class="keyword">int</span> ID, <span class="keyword">int</span> age, <span class="keyword">int</span> department)</span> </span>&#123;</span><br><span class="line">		Student::setInfo(name, ID, age);<span class="comment">//调用基类构造函数初始化</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;department = department;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="comment">//覆盖基类print()</span></span><br><span class="line">		Student::<span class="built_in">print</span>();<span class="comment">//调用基类print()</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"department:"</span> &lt;&lt; department &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UndergraduateStudent stu;</span><br><span class="line">	stu.setInfo(<span class="string">"jack"</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">5</span>);</span><br><span class="line">	stu.<span class="built_in">print</span>();<span class="comment">//调用派生类print()</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是上面的学生类以及研究生类，我们通过<code>setInfo()</code>函数设置学生信息，通过<code>print()</code>函数打印出学生的信息。</p>
<p>需要注意的是：</p>
<ul>
<li>当派生类中有成员函数或成员变量名与基类相同时，则基类的成员函数或变量将被覆盖。直接访问该成员函数或变量时访问的为派生类的成员函数或变量，需要访问基类的成员函数或变量时需要在成员函数或变量名前加上<code>基类名::</code>才能正常访问。</li>
<li>在上面的样例中，基类以及派生类中均有<code>setInfo()</code>以及<code>print()</code>两种方法，直接访问时为派生类的方法，在派生类中通过<code>Student::</code>访问基类的方法。</li>
</ul>
<p>运行上面的程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name:jack</span><br><span class="line">age:22</span><br><span class="line">ID:1</span><br><span class="line">department:5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>继承和派生</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>c++继承关系和复合关系</title>
    <url>/2020/07/30/C++/24%E3%80%81c-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><ul>
<li><p>继承关系：“是”关系</p>
<ul>
<li>基类为<code>A</code>，<code>B</code>是基类<code>A</code>的派生类。</li>
<li>逻辑上要求：一个<code>B</code>对象也是一个<code>A</code>对象。</li>
</ul>
<p>例如：从<code>学生类</code>派生出一个<code>研究生类</code>，原则上来说，一个<code>研究生类</code>也是一个<code>学生类</code>。</p>
<a id="more"></a>
</li>
<li><p>复合关系：“有”关系</p>
<ul>
<li>类<code>A</code>中有成员变量<code>k</code>，<code>k</code>是类<code>B</code>的对象，则<code>A</code>和<code>B</code>是复合关系。</li>
<li>逻辑上要求：<code>B</code>对象是<code>A</code>对象的固有属性或组成部分。</li>
</ul>
</li>
</ul>
<h1 id="继承关系的使用"><a href="#继承关系的使用" class="headerlink" title="继承关系的使用"></a>继承关系的使用</h1><p>假设我们需要写一个人事管理系统，假设需要一个<code>Man</code>类和一个<code>Woman</code>类分别来表示男人和女人。</p>
<p>这是我们不能从<code>Man</code>类派生出<code>Woman</code>类或从<code>Woman</code>类派生出一个<code>Man</code>类，因为一个男人不是一个女人，相反一个女人也不是一个男人。</p>
<p>我们需要提取出男人和女人的共同特点，封装为一个<code>Human</code>类，然后由<code>Human</code>类派生出<code>Man</code>类和<code>Woman</code>类。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200731140916016.png" alt="继承关系"></p>
<p>像上图这样，一个男人或是一个女人都属于人，这样就合乎逻辑了。</p>
<h1 id="复合关系的使用"><a href="#复合关系的使用" class="headerlink" title="复合关系的使用"></a>复合关系的使用</h1><p>在几何图形的程序中，我们有一个<code>Point</code>点类，当我们想画一个圆时，我们可以通过<code>Point</code>类来表示圆心，只需要再有一个变量来表示半径，就可以画出一个圆。</p>
<p>这是如果直接让<code>Circle</code>类继承<code>Point</code>类，只需要增加一个<code>r</code>作为半径就可表示一个圆。这样看似没有什么问题，但却不满足继承的逻辑上要求，即一个圆不是一个点，此时我么就需要使用复合关系来表示一个圆。如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x;<span class="comment">//x坐标</span></span><br><span class="line">    <span class="keyword">double</span> y;<span class="comment">//y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Point p;<span class="comment">//圆心</span></span><br><span class="line">    <span class="keyword">double</span> r;<span class="comment">//半径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时在<code>Circle</code>对象中就直接包含了一个<code>Point</code>对象来表示圆心，这样就比较合理。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象</tag>
        <tag>继承关系</tag>
        <tag>复合关系</tag>
      </tags>
  </entry>
  <entry>
    <title>c++覆盖和保护成员</title>
    <url>/2020/07/31/C++/25%E3%80%81c-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>派生类可以定义一个和基类成员同名的成员，这就叫<strong>覆盖</strong>。</p>
<p>在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号<code>::</code>。</p>
<a id="more"></a>
<h1 id="基类和派生类有同名成员的情况"><a href="#基类和派生类有同名成员的情况" class="headerlink" title="基类和派生类有同名成员的情况"></a>基类和派生类有同名成员的情况</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设有如上的类，<code>Derived</code>类从<code>Base</code>类派生得到。其中两个类都定义了同名变量<code>i</code>以及同名函数<code>func()</code>。</p>
<p>需要注意的是，在基类和派生类中应尽量避免同名的变量。</p>
<p>对于<code>Derived</code>类的<code>access()</code>函数，假设我们有如下实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	j = <span class="number">0</span>;<span class="comment">//错误，j为基类的私有变量，不能访问</span></span><br><span class="line">	i = <span class="number">5</span>;<span class="comment">//此处为派生类的i</span></span><br><span class="line">	Base::i = <span class="number">5</span>;<span class="comment">//此处为基类的5</span></span><br><span class="line">	func();<span class="comment">//派生类func()</span></span><br><span class="line">	Base::func();<span class="comment">//基类func()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在派生类中不能访问基类的私有变量。</li>
<li>当基类与派生类有同名变量或函数时，直接访问该变量或函数时访问的为派生类的成员。</li>
<li>要想访问基类中的同名函数或变量，需要使用<code>::</code>域运算符。</li>
</ul>
<p>假设我们有如下定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived obj;</span><br></pre></td></tr></table></figure>
<p>则<code>obj</code>占用的存储空间如下：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200731151544942.png" alt="派生类存储空间"></p>
<h1 id="类的保护成员"><a href="#类的保护成员" class="headerlink" title="类的保护成员"></a>类的保护成员</h1><h2 id="类成员的可访问范围"><a href="#类成员的可访问范围" class="headerlink" title="类成员的可访问范围"></a>类成员的可访问范围</h2><ul>
<li>基类的<code>private</code>成员：<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
</ul>
</li>
<li>基类的<code>public</code>成员：<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数</li>
<li>派生类的友元函数</li>
<li>其它的函数</li>
</ul>
</li>
<li>基类的<code>protected</code>成员：<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数可以访问当前对象的基类保护成员</li>
</ul>
</li>
</ul>
<p>以下程序说明类的成员的可访问范围：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> nPrivate;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> nPublic;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> nProtected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accessBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		nPrivate = <span class="number">1</span>;<span class="comment">//错误，不能访问基类私有成员</span></span><br><span class="line">		nProtected = <span class="number">1</span>;<span class="comment">//OK</span></span><br><span class="line">		nPublic = <span class="number">1</span>;<span class="comment">//OK</span></span><br><span class="line">		Derived d;</span><br><span class="line">		d.nProtected = <span class="number">1</span>;<span class="comment">//错误，d不是当前对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base s;</span><br><span class="line">	d.nPublic = <span class="number">1</span>;<span class="comment">//OK</span></span><br><span class="line">	s.nPublic = <span class="number">1</span>;<span class="comment">//OK</span></span><br><span class="line">	d.nProtected = <span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">	s.nProtected = <span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">	d.nPrivate = <span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">	s.nPrivate = <span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象</tag>
        <tag>保护成员</tag>
        <tag>覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>c++派生类的构造函数与析构函数</title>
    <url>/2020/07/31/C++/26%E3%80%81c-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在创建派生类对象时：</p>
<ol>
<li>先执行基类的构造函数，用来初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，初始化派生类对象中的成员变量。</li>
<li>最后执行派生类自己的构造函数</li>
</ol>
<a id="more"></a>
<p>调用基类构造函数的两种方式：</p>
<ul>
<li>显式方式：在派生类的构造函数中，为基类的构造函数提供参数</li>
<li>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数。</li>
</ul>
<p>在派生类对象消亡时：</p>
<ol>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数</li>
</ol>
<h1 id="派生类对象构造函数"><a href="#派生类对象构造函数" class="headerlink" title="派生类对象构造函数"></a>派生类对象构造函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> legs;</span><br><span class="line">	<span class="keyword">int</span> color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line">	Bug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_) &#123;</span><br><span class="line">		legs = legs_;</span><br><span class="line">		color = color_;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printBug</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span> :</span><span class="keyword">public</span> Bug &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> wings;</span><br><span class="line">	FlyBug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_, <span class="keyword">int</span> wings_);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们有一个<code>Bug</code>类，然后由<code>Bug</code>类派生出<code>FlyBug</code>类。</p>
<p><code>Bug</code>类有自己的构造函数，现在我们为<code>FlyBug</code>类编写构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_, <span class="keyword">int</span> wings_) &#123;</span><br><span class="line">	legs = legs_;<span class="comment">//错误，不能访问基类私有变量</span></span><br><span class="line">	color = color_;<span class="comment">//错误，不能访问基类私有变量</span></span><br><span class="line">	wings = wings_;<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现编译器报错，原因是在派生类中不能访问基类的私有变量。此时，在编写派生类的构造函数时，我们需要先调用基类的构造函数将基类成员初始化，然后再初始化派生类的成员。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_, <span class="keyword">int</span> wings_) &#123;</span><br><span class="line">	Bug(legs_, color_);</span><br><span class="line">	wings = wings_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译可以通过，除此之外，我们还能通过初始化列表的方式初始化基类对象，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_, <span class="keyword">int</span> wings_):Bug(legs_,color_),wings(wings_)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造函数以及析构函数调用时机"><a href="#构造函数以及析构函数调用时机" class="headerlink" title="构造函数以及析构函数调用时机"></a>构造函数以及析构函数调用时机</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> legs;</span><br><span class="line">	<span class="keyword">int</span> color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line">	Bug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_) &#123;</span><br><span class="line">		legs = legs_;</span><br><span class="line">		color = color_;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"基类Bug构造函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Bug()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"基类Bug析构函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printBug</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Demo() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"派生类成员Demo类构造函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Demo()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"派生类成员Demo类析构函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span> :</span><span class="keyword">public</span> Bug &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> wings;</span><br><span class="line">	Demo d;</span><br><span class="line">	FlyBug(<span class="keyword">int</span> legs_, <span class="keyword">int</span> color_, <span class="keyword">int</span> wings_) :Bug(legs_, color_), wings(wings_) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"派生类FlyBug构造函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~FlyBug()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"派生类FlyBug析构函数被调用!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">FlyBug <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，由<code>Bug</code>类派生出了<code>FlyBug</code>类，<code>FlyBug</code>类包含一个<code>Demo</code>类成员。执行以上程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基类Bug构造函数被调用!</span><br><span class="line">派生类成员Demo类构造函数被调用!</span><br><span class="line">派生类FlyBug构造函数被调用!</span><br><span class="line">派生类FlyBug析构函数被调用!</span><br><span class="line">派生类成员Demo类析构函数被调用!</span><br><span class="line">基类Bug析构函数被调用!</span><br></pre></td></tr></table></figure>
<p>在创建派生类对象时：</p>
<ol>
<li>先执行基类的构造函数，用来初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，初始化派生类对象中的成员变量。</li>
<li>最后执行派生类自己的构造函数</li>
</ol>
<p>在派生类对象消亡时：</p>
<ol>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>c++</tag>
        <tag>析构函数</tag>
        <tag>面向对象</tag>
        <tag>派生类</tag>
      </tags>
  </entry>
  <entry>
    <title>c++流插入和流提取运算符的重载</title>
    <url>/2020/07/19/C++/20%E3%80%81c-%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">5</span>&lt;&lt;<span class="string">"this"</span>;</span><br></pre></td></tr></table></figure>
<p>上面语句为什么可以成立？</p>
<p><code>cout</code>是什么？<code>&lt;&lt;</code>为什么可以作用在<code>cout</code>上？</p>
<a id="more"></a>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><code>cout</code>是在<code>iostream</code>中定义的<code>ostream</code>类的对象。<code>&lt;&lt;</code>能作用在<code>cout</code>是因为在<code>iostream</code>里对<code>&lt;&lt;</code>进行了重载。</p>
<p>考虑，怎样重载才能使得<code>cout&lt;&lt;5;</code>和<code>cout&lt;&lt;&quot;this&quot;;</code>都能成立。</p>
<h1 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载&lt;&lt;运算符"></a>重载&lt;&lt;运算符</h1><p>假设按照以下的方法重载<code>&lt;&lt;</code>运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="comment">//输出n</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">	<span class="comment">//输出str</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起了似乎没有什么问题，而且也能实现<code>cout&lt;&lt;5;</code>和<code>cout&lt;&lt;&quot;this&quot;;</code>两个语句。</p>
<p><code>cout&lt;&lt;5</code>相当于<code>cout.operator&lt;&lt;(5);</code></p>
<p><code>cout&lt;&lt;&quot;this&quot;</code>相当于<code>cout.operator&lt;&lt;(&quot;this&quot;);</code></p>
<p>但是当我们想要输出<code>cout&lt;&lt;5&lt;&lt;&quot;this&quot;;</code>时，就会出现问题了，因此我们需要修改上面的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="comment">//输出n</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">	<span class="comment">//输出str</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将两个函数的返回值改为<code>ostream&amp;</code>，此时返回了一个<code>ostream</code>对象的引用，就可以识别<code>cout&lt;&lt;5&lt;&lt;&quot;this&quot;;</code>这样的语句了，相当于<code>cout.operator&lt;&lt;(5).operator&lt;&lt;(&quot;this&quot;);</code></p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>假设<code>c</code>是<code>Complex</code>复数类的对象。现在希望写成<code>cout&lt;&lt;c;</code>就能以<code>a+bi</code>的形式输出<code>c</code>的值。写成<code>cin&gt;&gt;c;</code>就能接收<code>a+bi</code>形式的输入，并且<code>c.real=a</code>，<code>c.imag=b</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;<span class="comment">//实部、虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) &#123;</span><br><span class="line">		real = r;</span><br><span class="line">		imag = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c) &#123;</span><br><span class="line">	<span class="comment">//以a+bi的形式输出</span></span><br><span class="line">	os &lt;&lt; c.real &lt;&lt; <span class="string">"+"</span> &lt;&lt; c.imag &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c) &#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	is &gt;&gt; s;<span class="comment">//将a+bi以字符串形式读入</span></span><br><span class="line">	<span class="keyword">int</span> pos = s.<span class="built_in">find</span>(<span class="string">"+"</span>, <span class="number">0</span>);<span class="comment">//找到+号位置</span></span><br><span class="line">	<span class="built_in">string</span> real = s.substr(<span class="number">0</span>, pos);<span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">	<span class="comment">//atof能将const char*的内容转换为float</span></span><br><span class="line">	c.real = atof(real.c_str());</span><br><span class="line">	<span class="comment">//分离出虚部字符串</span></span><br><span class="line">	<span class="built_in">string</span> imag = s.substr(pos + <span class="number">1</span>, s.length() - pos - <span class="number">2</span>);</span><br><span class="line">	c.imag = atof(imag.c_str());</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的类实现中，我们将<code>ostream&amp; operator&lt;&lt;(ostream&amp; os, const Complex&amp; c)</code>以及<code>istream&amp; operator&gt;&gt;(istream&amp; is, Complex&amp; c)</code>函数声明为类<code>Complex</code>类的友元，这样就能访问<code>Complex</code>类的私有成员了。</p>
<p>主函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Complex c1;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; c1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1+5i</span><br><span class="line">1+5i</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
        <tag>左移运算符重载</tag>
        <tag>右移运算符重载</tag>
        <tag>流插入运算符</tag>
        <tag>流提取运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>c++公有继承的赋值兼容规则</title>
    <url>/2020/07/31/C++/27%E3%80%81c-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="赋值规则"><a href="#赋值规则" class="headerlink" title="赋值规则"></a>赋值规则</h1><p>假设有如下的类定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Base b;</span><br><span class="line">Derived d;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们有如下的赋值兼容规则：</p>
<ul>
<li>派生类的对象可以赋值给基类的对象<ul>
<li><code>b=d;</code></li>
</ul>
</li>
<li>派生类对象可以初始化基类引用<ul>
<li><code>Base&amp; br=d;</code></li>
</ul>
</li>
<li>派生类对象的地址可以赋值给基类指针<ul>
<li><code>Base *p=&amp;d;</code></li>
</ul>
</li>
</ul>
<p>如果派生方式为<code>protected</code>或<code>private</code>，则上述三条规则不再适用。</p>
<h1 id="直接基类和间接基类"><a href="#直接基类和间接基类" class="headerlink" title="直接基类和间接基类"></a>直接基类和间接基类</h1><p>假设类<code>A</code>派生出类<code>B</code>，类<code>B</code>派生出类<code>C</code>，类<code>C</code>派生出类<code>D</code>，······</p>
<ul>
<li>类<code>A</code>为类<code>B</code>的直接基类，类<code>B</code>为类<code>C</code>的直接基类</li>
<li>类<code>A</code>为类<code>C、D</code>的间接基类</li>
</ul>
<p>在声明一个派生类时，只需要列出它的直接基类即可。</p>
<p>派生类沿着类的层次自动向上继承它的间接基类</p>
<p>派生类的成员包括：</p>
<ul>
<li>派生类自己定义的成员</li>
<li>直接基类中的所有成员</li>
<li>所有间接基类的全部成员</li>
</ul>
<h1 id="多层派生实例"><a href="#多层派生实例" class="headerlink" title="多层派生实例"></a>多层派生实例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base构造函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Base() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base析构函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived构造函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Derived()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived析构函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreDerived</span> :</span><span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MoreDerived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"MoreDerived构造函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~MoreDerived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"MoreDerived析构函数被调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，由<code>Base</code>类派生出<code>Derived</code>类，然后由<code>Deriver</code>类派生出<code>MoreDerived</code>类</p>
<p>假设初始化一个<code>MoreDerived</code>类对象如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MoreDerived m;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Base构造函数被调用！</span><br><span class="line">Derived构造函数被调用！</span><br><span class="line">MoreDerived构造函数被调用！</span><br><span class="line">MoreDerived析构函数被调用！</span><br><span class="line">Derived析构函数被调用！</span><br><span class="line">Base析构函数被调用！</span><br></pre></td></tr></table></figure>
<p>可以看到，在执行构造函时，先执行基类的构造函数，依次最后执行派生类的构造函数。</p>
<p>在执行析构函数时，先执行派生类的构造函数，依次向上最后执行基类的析构函数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>公有继承</tag>
        <tag>public</tag>
      </tags>
  </entry>
  <entry>
    <title>c++虚函数和多态的基本概念</title>
    <url>/2020/07/31/C++/28%E3%80%81c-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul>
<li>在类的定义中，前面由<code>virtual</code>关键字的成员函数称为<strong>虚函数</strong>。</li>
<li><code>virtual</code>关键字只用在类定义里的函数声明中，写函数体时不用。</li>
<li>构造函数和静态成员函数不能是虚函数。</li>
</ul>
<a id="more"></a>
<h1 id="多态的表现形式一"><a href="#多态的表现形式一" class="headerlink" title="多态的表现形式一"></a>多态的表现形式一</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>派生类的指针可以赋给基类指针</li>
<li>通过基类指针调用基类和派生类中的同名虚函数时：<ul>
<li>若该指针指向一个基类对象，那么调用的为基类的虚函数。</li>
<li>若该指针指向一个派生类，那么调用的为派生类的虚函数。</li>
</ul>
</li>
</ul>
<p>这种机制就叫做<strong>多态</strong>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base类虚函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived类虚函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base b;</span><br><span class="line">	Base* p = &amp;d;</span><br><span class="line">	p-&gt;virtualFunction();</span><br><span class="line">	p = &amp;b;</span><br><span class="line">	p-&gt;virtualFunction();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实例中，<code>Base</code>类派生出<code>Derived</code>类，两个类中都有虚函数<code>virtualFunction()</code>。</p>
<p>在<code>main</code>函数中，我们初始化一个<code>Derived</code>对象<code>d</code>以及一个<code>Base</code>对象<code>b</code>。</p>
<p>然后初始化一个<code>Base</code>类指针<code>p</code>，让<code>p</code>指向<code>Derived</code>对象<code>d</code>，然后调用<code>virtualFunction()</code>函数。</p>
<p>接着让<code>p</code>指向<code>Base</code>对象<code>b</code>，然后调用<code>virtualFunction()</code>函数。</p>
<p>执行上面程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Derived类虚函数</span><br><span class="line">Base类虚函数</span><br></pre></td></tr></table></figure>
<p>我们可以知道，当<code>p</code>执行<code>Derived</code>类对象时，执行的是<code>Derived</code>类对象的<code>virtualFunction()</code>函数。</p>
<p>当<code>p</code>指向<code>Base</code>类对象时，执行的为<code>Base</code>类对象的<code>virtualFunction()</code>函数。</p>
<h1 id="多态的表现形式二"><a href="#多态的表现形式二" class="headerlink" title="多态的表现形式二"></a>多态的表现形式二</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>派生类对象可以赋值给基类的引用</p>
</li>
<li><p>通过基类的引用调用基类和派生类中同名的虚函数时：</p>
<ul>
<li>若该引用引用的是一个基类对象，那么被调用的是基类的虚函数</li>
<li>若该引用引用的是一个派生类对象，那么被调用的是派生类的虚函数。</li>
</ul>
<p>这种机制也叫做<strong>多态</strong>。</p>
</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base类虚函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived类虚函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base b;</span><br><span class="line">	Base&amp; r1 = b;</span><br><span class="line">	Base&amp; r2 = d;</span><br><span class="line">	r1.virtualFunction();</span><br><span class="line">	r2.virtualFunction();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，<code>Base</code>类派生出<code>Derived</code>类，两个类中都有虚函数<code>virtualFunction()</code>。</p>
<p>在<code>main</code>函数中，我们初始化一个<code>Derived</code>对象<code>d</code>以及一个<code>Base</code>对象<code>b</code>。</p>
<p>然后分别定义两个<code>Base</code>类的引用<code>r1、r2</code>，分别指向<code>b、d</code>。</p>
<p>然后通过两个引用调用<code>virtualFunction()</code>函数。</p>
<p>得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Base类虚函数</span><br><span class="line">Derived类虚函数</span><br></pre></td></tr></table></figure>
<p>可以证实：</p>
<ul>
<li>若该引用引用的是一个基类对象，那么被调用的是基类的虚函数</li>
<li>若该引用引用的是一个派生类对象，那么被调用的是派生类的虚函数。</li>
</ul>
<h1 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h1><p>定义如下的多重派生类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::print"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::print"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"C::print"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::print"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他们之间的派生关系如下：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200731171536208.png" alt="多重派生"></p>
<p>假设由如下的调用实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	C c;</span><br><span class="line">	D d;</span><br><span class="line">	A* p = &amp;a;</span><br><span class="line">	</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	p = &amp;b;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	p = &amp;c;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	p = &amp;d;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A::<span class="built_in">print</span></span><br><span class="line">B::<span class="built_in">print</span></span><br><span class="line">C::<span class="built_in">print</span></span><br><span class="line">D::<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<h1 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h1><p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>虚函数</tag>
        <tag>多态</tag>
        <tag>virtual</tag>
      </tags>
  </entry>
  <entry>
    <title>c++重载强制类型转换运算符</title>
    <url>/2020/07/23/C++/21%E3%80%81c-%E9%87%8D%E8%BD%BD%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>强制类型转换运算符是单目运算符，也可以被重载，但<strong>只能重载为成员函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> real; &#125;  <span class="comment">//重载强制类型转换运算符 double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>)c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1.2</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">2</span> + c;  <span class="comment">//等价于 double n = 2 + c. operator double()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;  <span class="comment">//输出 3.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在上面的程序中，我们重载了<code>double</code>类型强制转换运算符，可以将一个复数类强制转换为一个<code>double</code>类型的变量，具体做法是返回这个复数类的实部。</p>
<p>需要注意的是</p>
<ul>
<li><p>因为强制类型转换运算符是单目运算符，重载为成员函数后其参数个数为目数减一，所以该函数没有参数。</p>
</li>
<li><p>强制类型转换运算符本身就指明了返回值类型，所以<strong>不需要返回值</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>运算符重载</tag>
        <tag>类型转换运算符重载</tag>
        <tag>()运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>C++引用</title>
    <url>/2020/05/31/C++/3%E3%80%81C-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h1><p>引用是变量的一个别名，相当于已经存在的变量的另一个名字。引用名与被引用的变量名都指向同一个内存地址。</p>
<h1 id="引用的创建"><a href="#引用的创建" class="headerlink" title="引用的创建"></a>引用的创建</h1><p>引用创建的语法格式如下，其中<code>T</code>为任意类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T &amp;引用名 = 变量名;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//定义r引用a</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//修改a的值</span></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//修改r的值</span></span><br><span class="line">	r = <span class="number">1000</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//用已知变量对r赋值</span></span><br><span class="line">	r = b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tr="</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//输出a和r的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a的地址为："</span> &lt;&lt; (<span class="keyword">void</span>*)a &lt;&lt; <span class="string">"\tb的地址为："</span> &lt;&lt; (<span class="keyword">void</span>*)b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序，可以得到如下所示的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10    r=10</span><br><span class="line">a=100   r=100</span><br><span class="line">a=1000  r=1000</span><br><span class="line">a=20    r=20</span><br><span class="line">a的地址为：0000000000000014     b的地址为：0000000000000014</span><br></pre></td></tr></table></figure>
<p>通过观察上面的结果，我们可以得知</p>
<ol>
<li>引用必须在定义的时候初始化</li>
<li>引用是始终如一的，即引用了一个变量后就不能再引用其它变量</li>
<li>引用和被引用的变量都指向同一个内存地址</li>
<li>引用只能引用同一种类型的变量，不能引用常量。<code>int a=10;double &amp;b=a;</code>这种引用是非法的，以及<code>int &amp;a=10;</code>也是非法的。</li>
</ol>
<h1 id="常引用（const-amp-）"><a href="#常引用（const-amp-）" class="headerlink" title="常引用（const &amp;）"></a>常引用（const &amp;）</h1><p>引用也可以用<code>const</code>关键字修饰，这样就不能通过引用名来修改变量值了。</p>
<p>如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; r = a;</span><br><span class="line">    a = <span class="number">10</span>;<span class="comment">//正常</span></span><br><span class="line">	r = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>r=10;</code>这条语句时编译器会报错，提示<strong>表达式必须是可修改的左值</strong>，因为我们再初始化引用时将其加上了了<code>const</code>关键字，我们就不能通过引用名来修改变量的值了。</p>
<p>对于<code>a = 10;</code>这条语句则执行正常，因为a没有<code>const</code>关键字修饰。</p>
<p>再考量下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">int</span>&amp; r = a;<span class="comment">//错误</span></span><br><span class="line">	r = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	a = <span class="number">100</span>;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于用<code>const</code>关键字修饰的变量，我们在为其创建引用对象时，任然需要创建<code>const</code>类型的引用对象，且无法通过变量名或引用名来修改变量的值。</p>
<h1 id="引用的简单实例："><a href="#引用的简单实例：" class="headerlink" title="引用的简单实例："></a>引用的简单实例：</h1><p>在学习<code>C/C++</code>的过程中，我们难免会遇到交换两个变量值的题目。在没有学习引用之前，我们只能通过指针的方式来修改两个变量的值，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写显得很复杂，而且在调用的地方还要通过<code>&amp;</code>符号来对变量进行取地址操作。其实我们可以将函数的两个参数改写为引用，这样就可以简化我们的代码，增强可读性了，改写如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型 &amp;函数名（形参列表）&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>观察如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	setValue() = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后得到如下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n=4</span><br><span class="line">n=10</span><br></pre></td></tr></table></figure>
<p>函数<code>setValue()</code>返回一个全局变量<code>n</code>的引用，然后将函数名作为左值修改n的值。</p>
<p>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></p>
<p>对于引用作为函数返回值，在这里我们可以先不明觉厉。以后会说到。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>c++引用</tag>
        <tag>函数返回值引用</tag>
        <tag>变量引用</tag>
      </tags>
  </entry>
  <entry>
    <title>c++自增自减运算符重载</title>
    <url>/2020/07/30/C++/22%E3%80%81c-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>自增运算符<code>++</code>以及自减运算符<code>--</code>有前置、后置之分，为了区分该运算符为前置还是后置，<code>c++</code>有如下规定：</p>
<a id="more"></a>
<ul>
<li><p>前置运算符作为<strong>一元运算符</strong>重载</p>
<p><strong>重载为成员函数:</strong></p>
<p>（注意：<code>T</code>为任意类型）</p>
<p><code>T &amp; operator++();</code></p>
<p><code>T &amp; operator--();</code></p>
<p><strong>重载为全局函数：</strong></p>
<p><code>T &amp; operator++(T1);</code></p>
<p><code>T &amp; operator--(T1);</code></p>
</li>
<li><p>后置运算符作为<strong>二元运算符</strong>重载，多写一个没用的参数。</p>
<p><strong>重载为成员函数：</strong></p>
<p><code>T &amp; operator++(int);</code></p>
<p><code>T &amp; operator--(int);</code></p>
<p><strong>重载为全局函数：</strong></p>
<p><code>T &amp; operator++(T1,int);</code></p>
<p><code>T &amp; operator--(T1,int);</code></p>
</li>
</ul>
<p>通过多写一个参数来区分前置、后置的区别。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Demo(<span class="keyword">int</span> i=<span class="number">0</span>):n(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	Demo&amp; <span class="keyword">operator</span>++();<span class="comment">//前置++</span></span><br><span class="line">	Demo <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置++</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;;<span class="comment">//重载强制类型转换运算符，用于直接输出结果</span></span><br><span class="line">	<span class="keyword">friend</span> Demo&amp; <span class="keyword">operator</span>--(Demo&amp; d);<span class="comment">//前置--</span></span><br><span class="line">	<span class="keyword">friend</span> Demo <span class="keyword">operator</span>--(Demo&amp;, <span class="keyword">int</span>);<span class="comment">//后置--</span></span><br><span class="line">&#125;;</span><br><span class="line">Demo&amp; Demo::<span class="keyword">operator</span>++()&#123;<span class="comment">//前置++</span></span><br><span class="line">	++n;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//++s即为s.operator++();</span></span><br><span class="line"></span><br><span class="line">Demo Demo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="comment">//后置++</span></span><br><span class="line">	<span class="function">Demo <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//记录修改前内容</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> temp;<span class="comment">//返回修改前内容</span></span><br><span class="line">&#125;<span class="comment">//s++即为s.operator++(0)</span></span><br><span class="line"></span><br><span class="line">Demo&amp; <span class="keyword">operator</span>--(Demo&amp; d) &#123;<span class="comment">//前置--</span></span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;<span class="comment">//--s即为operator--(s)</span></span><br><span class="line"></span><br><span class="line">Demo <span class="keyword">operator</span>--(Demo&amp; d, <span class="keyword">int</span>) &#123;<span class="comment">//后置--</span></span><br><span class="line">	<span class="function">Demo <span class="title">temp</span><span class="params">(d)</span></span>;<span class="comment">//记录操作前数据</span></span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> temp;<span class="comment">//返回--前数据</span></span><br><span class="line">&#125;<span class="comment">//s--相当于operator--(d,0)</span></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们将<code>++</code>运算符重载为成员函数，将<code>--</code>运算符重载为全局函数。为了使得<code>--</code>运算符能访问私有变量，需要将其写为<code>Demo</code>类的友元函数。</p>
<p>并且重载<code>int()</code>强制类型转换运算符，使得能直接输出<code>n</code>的值。</p>
<p>需要注意的时，为了维持<code>c++</code>原有的计算特性，需要将前置<code>++/--</code>运算符的返回值写为同类对象的引用。</p>
<p>对于上面的类，假设我们有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Demo <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d++) &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (++d) &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d--) &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (--d) &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0,1,2,2</span><br><span class="line">2,1,0,0</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h1><ol>
<li>c++不允许定义新的运算符</li>
<li>重载后运算符的含义应当复合日常习惯</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载<code>&quot;.&quot;,&quot;.*&quot;,&quot;::&quot;,&quot;?:&quot;,&quot;sizeof&quot;</code></li>
<li><code>()、[]、-&gt;、=</code>只能重载为成员函数</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>运算符重载</tag>
        <tag>自增运算符</tag>
        <tag>自减运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中cin.getline和cin.get函数的使用</title>
    <url>/2019/09/16/C++/4%E3%80%81C-%E4%B8%ADgetline%E5%92%8Cget%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在C++中，我们通常使用<code>cin</code>作为输入函数来读取用户键盘输入的数据，由于不能通过键盘来输入空字符，因此<code>cin</code>需要用别的方法来确定字符串结尾位置。<code>cin</code>使用空白、空格、制表符和换行符来确定字符串的结束位置，这意味着<code>cin</code>在读入数据的时候只能截取上述结束符前的数据，对于结束符后的数据讲不能读入程序中。我们来考一个<code>cin</code>读入字符串的实例。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面的程序，当我们输入<code>woody allen</code>时，程序会得到下面的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">您的名字是：woody</span><br></pre></td></tr></table></figure>
<p>我们发现<code>cin</code>函数读入的数据并不完整，在上述样例中输入的名字被空格键截断了，所以cin只读入了一个单词就结束了读入操作。再来考察一个类似实例看看输入缓冲区内发生了什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的地址："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的地址为："</span> &lt;&lt; addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，我们发现，还没对地址输入提示做出反应，程序就把他显示出来了。然后立即显示最后一行。运行结果如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">请输入您的地址：您的名字是：woody</span><br><span class="line">您的地址为：allen</span><br></pre></td></tr></table></figure>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="面向行输入：getline"><a href="#面向行输入：getline" class="headerlink" title="面向行输入：getline()"></a>面向行输入：getline()</h2><p><code>getline()</code>函数读取输入的整行，它使用通过回车键输入的换行符来作为结束符。要调用这种方法可以使用<code>cin.getline()</code>，该函数有两个参数，第一个参数是用来存储输入行的数组名称，另一个参数是要读取的字符串长度，如果参数为30，则最多读取29各字符，最后一个用来存储在字符串末尾的空字符。<br>例如，假设要使用<code>cin.getline()</code>将姓名读入到一个包含30各元素的<code>name</code>数组中，可使用下面这样的函数调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(name,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>这样就可以将一行读入到数组中————如果这一行不超过29个字符(<code>getline()</code>成员函数还可以接受第三个可选参数，在此不做讨论)。现在对上述样例进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的姓名："</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(name,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的地址："</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(addr,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的名字是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您的地址为："</span> &lt;&lt; addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中将<code>cin</code>换成了<code>cin.getline()</code>，我们得到了正确的输入如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">请输入您的姓名：woody allen</span><br><span class="line">请输入您的地址：Guizhou China</span><br><span class="line">您的名字是：woody allen</span><br><span class="line">您的地址为：Guizhou China</span><br></pre></td></tr></table></figure>
<p><code>getline()</code>函数每次读取一行，它通过回车键输入的换行符来确定行尾，但是不保存换行符。相反，在存储字符串时，它用空字符来替换换行符。</p>
<h2 id="面向行的输入get"><a href="#面向行的输入get" class="headerlink" title="面向行的输入get()"></a>面向行的输入get()</h2><p>另外还有一种方法。<code>istream</code>类有另一个名为<code>get()</code>的成员函数，该函数有几种变体，其中一种与<code>getline()</code>类似，他们接受相同的参数，解释参数的方式也相同，都读取到行尾。单<code>get()</code>不再读取并丢弃换行符，而是将其留在输入队列中，假设我们连续两次调用<code>get()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,arrSize);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(addr,arrSize);</span><br></pre></td></tr></table></figure>
<p>运行上诉代码，我们会发现第二行代码并没有读入数据，原因是当第二行代码在读取数据时，把第一行读取的回车符当成了第二个字符串的结束标志，所以接下来的数据都没有读入，一个解决办法是将上诉代码改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,arrSize);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(addr,arrSize);</span><br></pre></td></tr></table></figure>
<p>通过新增的<code>cin.get();</code>先读取上一行留下来的换行符，然后再读取下一个字符串。</p>
<p>另一种使用<code>get()</code>的方法是将两个类成员函数拼接起来使用，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,addr).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>之所以这样做，是由于<code>cin.get(name,addr)</code>返回一个<code>cin</code>对象，该对象随后将被用来调用<code>get()</code>函数，同样，下面语句也能将输入的两行分别读到数组<code>name</code>和<code>addr</code>中，其效果与两次调用<code>cin.getline()</code>相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(name,ArSize).getline(addr,ArSize);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cin.get函数</tag>
        <tag>cin.getline函数</tag>
        <tag>cin.get()</tag>
        <tag>cin.getline()</tag>
        <tag>字符串输入</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++函数指针</title>
    <url>/2020/02/25/C++/2%E3%80%81C-C-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>指针</strong>是用来在程序中指向某一个变量的，实际上指针内存放的就是一个变量的相对内存地址（实际的物理地址还要加上一个偏移值）。</p>
<p>在程序运行期间，每个函数都会占用一段连续的内存空间，而函数名就是该函数所占内存空间的起始地址（入口地址），我们可以将一个函数的起始地址赋值给一个指针，进而通过该指针来调用函数，这就是函数指针。</p>
<a id="more"></a>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。在如 <code>C</code>这样的语言中，通过提供一个简单的选取、执行函数的方法，函数指针可以简化代码。函数指针只能指向具有特定特征的函数。因而所有被同一指针运用的函数必须具有<strong>相同的参数和返回类型</strong>。</p>
<p>C语言标准规定，函数指示符（function designator，即函数名字）既不是左值，也不是右值。但C++语言标准规定函数指示符属于左值，因此函数指示符转换为函数指针的右值属于左值转换为右值。</p>
<p>除了作为<code>sizeof</code>或取地址&amp;的操作数，函数指示符在表达式中自动转换为函数指针类型右值。因此通过一个函数指针调用所指的函数，不需要在函数指针前加取值或反引用（*）运算符。</p>
<h1 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h1><p>对于一个函数指针，我们采用如下的定义方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值 (* 指针变量名)(参数类型1，参数类型2，······)</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (* pf)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><br>其中，</p>
<p><strong>返回值</strong>：函数返回的数据类型</p>
<p><strong>指针变量名</strong>:函数指针变量名</p>
<p><strong>参数类型</strong>：函数的参数类型</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//返回两个数中的最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个函数指针pf</span></span><br><span class="line">	<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">//让pf指向min函数</span></span><br><span class="line">	pf = <span class="built_in">min</span>;</span><br><span class="line">	<span class="comment">//通过函数名调用min函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"min=%d\n"</span>, <span class="built_in">min</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//通过函数指针pf调用min函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pf=%d\n"</span>, pf(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行上面的程序，我们得到了以下结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min=10</span><br><span class="line">pf=10</span><br></pre></td></tr></table></figure><br>从结果中我们可以看出两种调用方式得到了一样的结果。接下来我们进而修改一下上面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//返回两个数中的最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个函数指针pf</span></span><br><span class="line">	<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">//让pf指向min函数</span></span><br><span class="line">	pf = <span class="built_in">min</span>;</span><br><span class="line">	<span class="comment">//获取min函数的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"min=  %p\n"</span>, &amp;<span class="built_in">min</span>);</span><br><span class="line">	<span class="comment">//查看函数指针pf内的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pf=   %p\n"</span>, pf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，我们得到下面的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min&#x3D;  001C1221</span><br><span class="line">pf&#x3D;   001C1221</span><br></pre></td></tr></table></figure><br>从结果我们可以明显的看出<code>pf</code>函数中存放的确实是<code>min</code>的地址。</p>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>在<strong>C语言</strong>中，有一个常用的快速排序库函数，能够对任意的数组以任意规则进行排序，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nitems, <span class="keyword">size_t</span> <span class="built_in">size</span>, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span>*))</span></span></span><br></pre></td></tr></table></figure>
<p>其中，</p>
<p><code>base</code>为将要排序的数组的首地址</p>
<p><code>nitems</code>为由<code>base</code>指向的数组的元素个数</p>
<p><code>size</code>为该数组中每个元素的大小</p>
<p><code>compar</code>为排序规则函数，其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 函数名(const void *elem1,const void *elem2);</span><br></pre></td></tr></table></figure>
<p>该函数的返回值有三种情况：</p>
<p>1.返回<code>负整数</code>：<code>*elem1</code>排在<code>*elem2</code>前面</p>
<p>2.返回<code>0</code>： <code>*elem1</code>和<code>*elem2</code>谁在前面都可以</p>
<p>3.返回<code>正整数</code>：<code>*elem1</code>排在<code>*elem2</code>后面</p>
<p>下面我们来考察一个实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCompar</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;<span class="comment">//排序规则函数</span></span><br><span class="line">    <span class="comment">//由于*a和*b是两个无类型的地址，</span></span><br><span class="line">    <span class="comment">//在使用之前我们先将其强制类型转换为int*，</span></span><br><span class="line">    <span class="comment">//然后再取其值进行比较</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123; <span class="number">23</span>, <span class="number">6</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序之前的列表：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用qsort进行排序</span></span><br><span class="line">    qsort(values, <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), myCompar);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n排序之后的列表：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上程序，我们得到下面所示结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序之前的列表：</span><br><span class="line">23 6 100 2 25</span><br><span class="line">排序之后的列表：</span><br><span class="line">2 6 23 25 100</span><br></pre></td></tr></table></figure><br>经过qsort调用mycompar函数后成功升序地将数组进行了排序</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
        <tag>c语言函数指针</tag>
        <tag>c++函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态内存分类(new/delete)</title>
    <url>/2020/05/31/C++/5%E3%80%81C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB-new-delete/</url>
    <content><![CDATA[<h1 id="使用new运算符分配一个变量"><a href="#使用new运算符分配一个变量" class="headerlink" title="使用new运算符分配一个变量"></a>使用<code>new</code>运算符分配一个变量</h1><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T;</span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>是任意类型名，<code>P</code>是类型为<code>T*</code>的指针。</p>
<p>使用该表达式动态分配出一片大小为<code>sizeof(T)</code>字节的内存空间。并且将该内存空间的其实地址赋值给<code>P</code>。<br><a id="more"></a><br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*p = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，为<code>p</code>动态分配了<code>sizeof(int)</code>大小的空间，并将起始地址赋值给了<code>p</code>。</p>
<h1 id="使用new运算符分配一个数组"><a href="#使用new运算符分配一个数组" class="headerlink" title="使用new运算符分配一个数组"></a>使用<code>new</code>运算符分配一个数组</h1><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>是任意类型名，<code>P</code>是类型为<code>T*</code>的指针，<code>N</code>是要分配的数组元素的个数，<code>N</code>可以是表达式。</p>
<p>使用该表达式动态分配出<code>N*sizeof(T)</code>字节的内存空间，并将起始地址渎职给<code>P</code>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">9</span>] = <span class="number">10</span>;</span><br><span class="line">	p[<span class="number">10</span>] = <span class="number">10</span>;<span class="comment">//越界</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，为<code>p</code>动态分配了<code>10 * sizeof(int)</code>大小的空间，并将起始地址赋值给了<code>p</code>。</p>
<p>为数组分配完空间后就可以像访问数组一样访问该指针。但是需要注意的是在执行<code>p[10] = 10;</code>时会导致数组越界，编译器又可能不会报错。</p>
<h1 id="使用delete运算符释放动态分配的内存"><a href="#使用delete运算符释放动态分配的内存" class="headerlink" title="使用delete运算符释放动态分配的内存"></a>使用<code>delete</code>运算符释放动态分配的内存</h1><p>使用<code>new</code>运算符动态分配的内存空间，一定要使用<code>delete</code>运算符进行释放。</p>
<h2 id="delete变量"><a href="#delete变量" class="headerlink" title="delete变量"></a><code>delete</code>变量</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> 指针;<span class="comment">//该指针必须指向new出来的空间</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//报错，只能delete一次</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>delete</code>时只能对同一片空间使用一次<code>delete</code>，否则将会报错，如上程序所示。</p>
<h2 id="delete数组"><a href="#delete数组" class="headerlink" title="delete数组"></a><code>delete</code>数组</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []指针;<span class="comment">//该指针必须指向new出来的空间</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>delete</code>释放动态分配的数组时，要添加<code>[]</code>。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">delete</span> []p;</span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//错误,只会释放第一个元素的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>delete []p;</code>来正确释放动态分配的内存空间，指针前有<code>[]</code>符；当使用<code>delete p;</code>时，将导致该数组的首元素空间被释放，而其余空间未被释放，形成“野指针”。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>内存分配</tag>
        <tag>new关键字</tag>
        <tag>delete关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内联函数inline</title>
    <url>/2020/06/01/C++/6%E3%80%81c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline/</url>
    <content><![CDATA[<h1 id="inline概念"><a href="#inline概念" class="headerlink" title="inline概念"></a><code>inline</code>概念</h1><p>在<code>c++</code>中，函数调用是会产生额外的时间开销的，如果函数本身代码很短，执行很快，并且该函数被反复调用。相比之下调用函数所产生的开销就会很大，甚至超过执行代码所产生的开销。</p>
<p>为了减少函数调用的开销，<code>c++</code>引入了<code>内联函数</code>的机制。编译器在处理内联函数的调用语句时，直接将整个内联函数代码插入到调用语句处，从而减少函数调用产生的开销。<br><a id="more"></a></p>
<h1 id="inline定义"><a href="#inline定义" class="headerlink" title="inline定义"></a><code>inline</code>定义</h1><p><code>inline</code>关键字的使用比较简单，只需要在函数的定义头部加上<code>inline</code>关键字即可，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> 返回值类型 函数名(参数)&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数的具体使用如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//返回两数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，定义一个内联函数<code>max</code>，该函数返回两个数中的最大值，只需要在函数定义时加入<code>inline</code>关键字即可，在对<code>max</code>函数进行调用时，编译器直接将<code>max</code>的函数代码嵌入到调用的地方，以此来节省函数调用产生的额外开销。</p>
<h1 id="inline函数注意事项"><a href="#inline函数注意事项" class="headerlink" title="inline函数注意事项"></a><code>inline</code>函数注意事项</h1><p>通过上面的例子，我们了解了<code>inline</code>关键字的基本使用方法，内联函数虽然节省了函数调用产生的开销，但并不是所有的地方都能使用内联函数定义。</p>
<p>当函数代码过长时，使用内联函数会使得程序变得臃肿。此时就不应该使用内联函数。</p>
<p>另外，当函数中包含循环控制语句时，也不应该使用内联函数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>inline函数</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c++函数的缺省参数</title>
    <url>/2020/06/01/C++/7%E3%80%81c-%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>c++中，定义函数的时候可以让<strong>最右边的连续若干个</strong>参数有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">1</span>, <span class="keyword">int</span> c = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在调用时，如果参数<code>b</code>和<code>c</code>的参数没有给出，则默认为缺省值。</p>
<p>函数缺省参数的作用在于提高程序的<strong>可扩充性</strong>。比如某个以及写好的函数需要添加新的参数，而原先调用函数的的那些语句未必需要新增加的参数，为了避免对原来所有调用该函数的地方进行修改，就可以使用函数缺省参数了。</p>
<h1 id="全缺省"><a href="#全缺省" class="headerlink" title="全缺省"></a>全缺省</h1><p>顾名思义，全缺省就是参数的所有值都为缺省参数，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">2</span>, <span class="keyword">int</span> c = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fun();</span><br><span class="line">    fun(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该程序，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1     b=2     c=3</span><br><span class="line">a=4     b=5     c=6</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们在调用函数时，只能缺省<strong>最右边的若干个参数</strong>，形如：<code>fun(4, , 6);</code>这种调用是错误的调用方法。</p>
<h1 id="半缺省"><a href="#半缺省" class="headerlink" title="半缺省"></a>半缺省</h1><p>半缺省指的是参数中有一部分为缺省参数，有一部分为非缺省参数。</p>
<p>值得注意的是，缺省参数只能为<strong>最右边的若干个</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">2</span>, <span class="keyword">int</span> c = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">"\tb="</span> &lt;&lt; b &lt;&lt; <span class="string">"\tc="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fun(<span class="number">1</span>);</span><br><span class="line">	fun(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	fun(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面程序，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1     b=2     c=3</span><br><span class="line">a=1     b=4     c=3</span><br><span class="line">a=4     b=5     c=6</span><br></pre></td></tr></table></figure>
<p>形如：<code>void fun(int a=1, int b, int c = 3) { }</code>这样的语句是错误的用法。</p>
<p>形如：<code>fun(1, ,3)</code>这种调用也是错误的。</p>
<p>总之记住，缺省参数只能为最右边的若干个参数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>参数缺省</tag>
        <tag>函数参数缺省</tag>
      </tags>
  </entry>
  <entry>
    <title>c++函数重载</title>
    <url>/2020/06/01/C++/8%E3%80%81c-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>假设如下函数来比较两个<code>int</code>型数据的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当我们需要再增加一个比较两个<code>double</code>或<code>char</code>类型的数据时，我们的函数名会变得臃肿，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_double</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_char</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要比较更多类型数据的大小时，我们的<code>max_xxx</code>函数会变得越来越多。在进行调用时会越来越麻烦。</p>
<h1 id="函数重载定义"><a href="#函数重载定义" class="headerlink" title="函数重载定义"></a>函数重载定义</h1><p>函数重载指的是一个或多个函数，名字相同，然而参数个数以及参数类型不同，我们就称之为函数重载。</p>
<p>将上面的代码改写为如下形势：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们在调用函数时就不需要用函数名去区分该调用哪个函数，此时程序会根据我们的参数个数以及参数类型去选择调用的函数。</p>
<p>如下函数调用代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">//调用 1</span></span><br><span class="line">	<span class="built_in">max</span>(<span class="string">'a'</span>, <span class="string">'b'</span>);<span class="comment">//调用 3</span></span><br><span class="line">	<span class="built_in">max</span>(<span class="number">2.3</span>, <span class="number">3.2</span>);<span class="comment">//调用 2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序，在执行<code>max(2, 3);</code>时，参数为两个<code>int</code>类型的，所以自动匹配到调用第1个<code>max</code>函数。其他两次调用类似。</p>
<p>函数重载使得函数的命名变得简单，调用过程也变得简洁。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>考察如下函数调用语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.1</span>);</span><br></pre></td></tr></table></figure>
<p>当我们进行上述的函数调用时，就会产生二义性。</p>
<p>此时编译器不知道是将<code>3.1</code>转换为<code>int</code>去调用<code>max(int a, int b)</code> ，还是将<code>2</code>转化为<code>double</code>去调用 <code>max(double a, double b)</code>。</p>
<p>因此，在调用重载函数时要注意去避免产生二义性。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04安装</title>
    <url>/2019/12/24/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/2%E3%80%81Ubuntu18.04%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文为系列文章的第二篇，关于本专栏相关文章可以到文末专栏目录查看。</p>
<p>就这样，请拥有，并享受。</p>
<h1 id="制作安装镜像"><a href="#制作安装镜像" class="headerlink" title="制作安装镜像"></a>制作安装镜像</h1><h2 id="下载操作系统镜像"><a href="#下载操作系统镜像" class="headerlink" title="下载操作系统镜像"></a>下载操作系统镜像</h2><p>首先到Ubuntu中国官网下载最新版本的Ubuntu18.04桌面版</p>
<p>下载传送门：点击这里</p>
<p>step1.点击桌面系统<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/0.jpg" alt="ubuntu首页"></p>
<p>step2.点击下载Ubuntu<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/1.jpg" alt="桌面系统主页"></p>
<p>step3.点击Ubuntu18.04.3 LTS后面的直接下载<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/2.jpg" alt="下载界面"></p>
<p>在写文章时的官方最新版本为18.04.3，具体可能会有变化。</p>
<p>LTS为官方长期支持版本，你也可以选择下载最新的试用版本，具体看个人怎么选择，官方也对各版本有详细的说明。个人建议选择LTS版本。</p>
<p>注！可以选择BT下载，这样下载速度会比较快。</p>
<h2 id="下载启动盘制作工具"><a href="#下载启动盘制作工具" class="headerlink" title="下载启动盘制作工具"></a>下载启动盘制作工具</h2><p>制作启动盘的工具市面上有很多，可以参考网络上其他同类文章，这里选择用UltraISO作为制作工具。</p>
<p>UltraISO传送门：点击这里</p>
<p>step1.点击导航栏<strong>下载</strong><br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/4%E3%80%81ultraiso.jpg" alt="UltraISO官网主页"></p>
<p>step2.点击<strong>免费下载试用</strong><br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/5.jpg" alt="下载界面"></p>
<p>step3.安装</p>
<p>这里就部展开详述了，安装完成后打开，会跳出窗口订购，在这里点击下方的试用即可。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20115307.jpg" alt="UltraISO订阅界面"></p>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>重要！！！制作U盘安装工具会擦除U盘所有数据，请提前备份好U盘数据！！！</p>
<p>step1.打开刚才下载的Ubuntu安装镜像<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20115730.jpg" alt="UltraISO软件界面"><br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20115759.jpg" alt="加载安装镜像后"></p>
<p>step2.安装镜像文件到U盘</p>
<p>注：一下操作会擦除U盘数据，请做好备份。</p>
<p>点击菜单栏启动—&gt;写入硬盘镜像</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20115816.jpg" alt="制作镜像启动"></p>
<p>之后会跳出一个窗口，磁盘驱动器处选择要作为启动盘的U盘，其它选项默认，然后点击写入，整个过程会持续几分钟，待进度条跑完后及完成（注意错误提示，并在网上寻求解决方案）。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20115857.jpg" alt="镜像写入"></p>
<p>到此不出意外的话整个启动U盘就制作好了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>接下来你需要设置主板从U盘启动，不同的主板设置不一样，在此不做任何操作说明，具体你可以百度主板型号+U盘启动来寻找你主板对应的设置方法。</p>
<p>从U盘启动后，会看到下图的界面，全部默认，点击install ubuntu（安装ubuntu）</p>
<p>（你也可以选择其他语言，但是建议选择英文，中文安装后在后续的操作目录切换中特别麻烦，你还需要安装一个中文编译器，但是相信我，作为nas的操作系统，你需要中文输入的地方很少，尤其是对于linux，只会增加一些没用且繁琐的折腾，所以选择英文就好）<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20170625.jpg" alt="Welcome界面"></p>
<p>之后选择键盘和布局，这里默认就好，然后点击continue（继续）。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20170644.jpg" alt="​选择键盘和布局"></p>
<p>之后跳转到​下图界面，选择Minimal installation（最小化安装）即可，Normal installation（正常安装）提供了较为完整的软件，但那些都是我们用不到的东西。</p>
<p>Download updates while installing Ubuntu（安装过程中更新软件）选上这个会在安装的过程中更新软件包，会增加安装时间。可以在后续安装完成后更新。</p>
<p>install third-party software······这个选项勾上，会为你安装硬件驱动等，减少后期工作量。</p>
<p>完成后点击continue</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20170709.jpg" alt="​更新以及第三方软件"></p>
<p>之后选择安装类型，如果你懒得折腾，选择默认的即可，你也可以选择Something else来自定义安装，如果你没有相关linux基础，建议选择默认，如果你有相关基础，相信你会自己做出选择。</p>
<p>然后点击continue<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20170730.jpg" alt="​安装类型"></p>
<p>这里提示你会擦除硬盘内容，叫你确认。</p>
<p>没有其他任何问题的话这里选择continue<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20171232.jpg" alt="​确认框"></p>
<p>之后选择时区，选择shanghai即可，然后continue。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20171313.jpg" alt="选择时区"></p>
<p>下面进行用户配置</p>
<p>your name：用户名</p>
<p>your computer name：计算机名</p>
<p>pick a username：登录用户名（不要为中文）</p>
<p>choose a password：密码</p>
<p>confirm your password：确认密码</p>
<p>然后勾选下面的log in automatically，点击continue<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20171349.jpg" alt="用户信息​"></p>
<p>之后进入到漫长的安装过程，只需等待即可，整个过程看你的网络情况，从几十分到几小时不等，ubuntu服务器在国外，访问会比较慢，可以使用梯子。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20171407.jpg" alt="安装过程"></p>
<p>安装完成后会跳出一个弹窗，这里选择restart now（重启）</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20175101.jpg" alt="重启界面"></p>
<p>好了，到这里这个安装过程就结束了，而折腾的真个nas过程也就完成了60%了。</p>
<p>是不是很兴奋。</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1><p>注！[✔]表示已更新，[✖] 表示未更新</p>
<p>[✔] 前言</p>
<p>[✔] Ubuntu18.04的安装</p>
<p>[✖] Linux的基本操作</p>
<p>[✖] 基本工具安装及使用</p>
<p>[✖] Docker安装</p>
<p>[✖] 控制面板</p>
<p>[✖] jellyfin影音服务</p>
<p>[✖] 网盘服务</p>
<p>[✖] 下载工具</p>
<p>[✖] 笔记管理</p>
<p>[✖] 手机开关机</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04安装</tag>
        <tag>Ubuntu安装</tag>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类和对象基础知识</title>
    <url>/2020/07/08/C++/9%E3%80%81C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在c语言中，程序是由若干的函数以及变量组成的，它们之间并没有很严格的关系，这就导致了当程序规模逐渐变大之后，就不易于程序的扩充以及维护。另外，当我们想要复用之前程序中的一些代码片段时，函数中的变量使得我们很难将其从程序中抽离出来。总之，结构化程序设计使得我们的程序难以扩充、难以维护、难以重用。</p>
<a id="more"></a>
<p>c++在c语言的基础上增加了<strong>面向对象程序设计</strong>（Object-oriented programming，OOP）的机制，而面向对象的这种机制恰好解决了c语言结构化设计的这种缺陷。简单来说，在面向对象程序设计中，我们可以依照以下的设计方法：</p>
<ol>
<li>我们将某类客观事物的共同特点（属性）归纳出来，形成一个数据结构，可以用多个变量描述事物的属性。</li>
<li>将这类事物所能进行的行为也归纳出来，形成函数，这些函数就用来操作数据结构。</li>
<li>然后通过某种方式将这些数据结构与函数捆绑<strong>封装</strong>起来，从而形成一个类。</li>
</ol>
<p>需要注意的是，被封装的函数只能访问与它封装在一起的数据结构，反之，这些数据结构也只能被与它封装在一起的函数所操作。这样就使得某一类事物的数据结构只能由与之封装的函数进行操作，而其它函数是无法访问其数据结构的。</p>
<div class="note info">
            <p>案例<br>假设我们现在要实现一个矩形类，该如何表示呢？</p><ul><li>矩形有长(length)和宽(weight)两个属性</li></ul><p>作为一个矩形，可以有哪些行为呢？</p><ul><li>设置长和宽</li><li>计算面积</li><li>计算周长</li></ul>
          </div>
<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>我们将上面的矩形属性长(length)和宽(weight)以及与之对应的行为封装在一起，就能形成一个矩形类。</p>
<p>矩形属性成为“<strong>成员变量</strong>”，3个函数成为该类的“<strong>成员函数</strong>”，成员变量与成员函数统称为类的成员。</p>
<p>实际上，类看上去就像带函数的结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">	<span class="keyword">double</span> weight;<span class="comment">//宽</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> length_,<span class="keyword">double</span> weight_)</span> </span>&#123;<span class="comment">//设置长和宽</span></span><br><span class="line">		length = length_;<span class="comment">//设置长</span></span><br><span class="line">		weight = weight_;<span class="comment">//设置宽</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;<span class="comment">//计算面积</span></span><br><span class="line">		<span class="keyword">return</span> length * weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">Perimeter</span><span class="params">()</span> </span>&#123;<span class="comment">//计算周长</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * (length + weight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;<span class="comment">//分号不可省略</span></span><br></pre></td></tr></table></figure>
<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。除了<strong>public</strong>，我们还可以指定成员为<strong>private</strong> 或 <strong>protected</strong>，我们将在后续进行讲解。</p>
<p>这样我们就得到了一个矩形类。</p>
<ul>
<li><strong>length</strong> 和 <strong>weight</strong> 分别为矩形的长和宽</li>
<li><strong>init</strong>、<strong>Area</strong>、<strong>Perimeter</strong>分别为类的成员函数，函数中的<strong>length</strong> 和 <strong>weight</strong> 指的是成员变量的<strong>length</strong> 和 <strong>weight</strong> 。</li>
</ul>
<h1 id="定义-C-对象"><a href="#定义-C-对象" class="headerlink" title="定义 C++ 对象"></a>定义 C++ 对象</h1><h2 id="普通定义"><a href="#普通定义" class="headerlink" title="普通定义"></a>普通定义</h2><p>我们有了<strong>Rectangle</strong>类之后就要去使用它，声明类的对象，就像声明基本数据类型的变量一样，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Rectangle r;<span class="comment">//声明一个对象</span></span><br><span class="line">	<span class="keyword">double</span> length = <span class="number">10.0</span>;</span><br><span class="line">	<span class="keyword">double</span> weight = <span class="number">10.0</span>;</span><br><span class="line">	r.init(length, weight);<span class="comment">//初始化对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形面积为："</span> &lt;&lt; r.Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形周长为："</span> &lt;&lt; r.Perimeter() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们声明了一个对象<code>r</code>,类型为<code>Rectangle</code>。<strong>我们通过<code>.</code>运算符可以访问类的成员</strong>，通过<code>r.init(length, weight);</code>来初始化对象，此时调用了类的成员函数<code>void init(double length_,double weight_)</code>，设置了矩形的长和宽。</p>
<p>接下来，通过<code>r.Area()</code>以及<code>r.Perimeter()</code>计算矩形的面积以及周长，并通过<code>cout</code>输出，运行上面的代码，我们可以得到如下结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">矩形面积为：100</span><br><span class="line">矩形周长为：40</span><br></pre></td></tr></table></figure>
<h2 id="通过指针定义"><a href="#通过指针定义" class="headerlink" title="通过指针定义"></a>通过指针定义</h2><p>除了上面所展示的普通定义之外，我们还可以通过指针来定义类的对象，其用法与基本数据类型的指针定义相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">	<span class="keyword">double</span> weight;<span class="comment">//宽</span></span><br><span class="line">	Rectangle *r;<span class="comment">//声明一个对象指针</span></span><br><span class="line">	r = <span class="keyword">new</span> Rectangle;<span class="comment">//为对象动态分配内存空间</span></span><br><span class="line">	r-&gt;init(length, weight);<span class="comment">//初始化对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形面积为："</span> &lt;&lt; r-&gt;Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形周长为："</span> &lt;&lt; r-&gt;Perimeter() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> r;<span class="comment">//释放动态分配的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象指针的创建与基本数据类型的指针定义相同，通过<code>Rectangle *r;</code>创建一个对象指针，并通过<code>new</code>运算符为其动态分配内存空间，值得注意的是，在访问对象的成员时，需要使用<code>-&gt;</code>运算符进行访问，而不再是<code>.</code>运算符。</p>
<p>执行上面代码，我们可以获得与普通定义相同的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">矩形面积为：100</span><br><span class="line">矩形周长为：40</span><br></pre></td></tr></table></figure>
<p>最后，在使用完之后，我们需要使用<code>delete</code>运算符来释放动态分配的空间。</p>
<p>通过类可以定义变量，类定义出来的<strong>变量</strong>，也成为类的实例，就是我们所说的<strong>对象</strong>。</p>
<h1 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h1><p>类的对象的公共数据成员(<strong>public</strong>)可以使用直接成员访问运算符<code>.</code>或<code>-&gt;</code>来访问。</p>
<h2 id="使用-访问"><a href="#使用-访问" class="headerlink" title="使用.访问"></a>使用<code>.</code>访问</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Rectangle r;<span class="comment">//声明一个对象</span></span><br><span class="line">	<span class="keyword">double</span> length = <span class="number">10.0</span>;</span><br><span class="line">	<span class="keyword">double</span> weight = <span class="number">10.0</span>;</span><br><span class="line">	r.init(length, weight);<span class="comment">//初始化对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形长为："</span> &lt;&lt; r.length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形宽为："</span> &lt;&lt; r.weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过<code>r.init(length, weight);</code>，我们调用了初始化函数初始化了矩形的长和宽。</p>
</li>
<li><p>通过<code>r.length</code>，得到了矩形的长。</p>
</li>
<li><p>通过<code>r.weight</code>，得到了矩形的宽。</p>
</li>
</ul>
<p>执行上面的代码，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">矩形长为：10</span><br><span class="line">矩形宽为：10</span><br></pre></td></tr></table></figure>
<h2 id="使用-gt-访问"><a href="#使用-gt-访问" class="headerlink" title="使用-&gt;访问"></a>使用<code>-&gt;</code>访问</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">	<span class="keyword">double</span> weight;<span class="comment">//宽</span></span><br><span class="line">	Rectangle *r;<span class="comment">//声明一个对象指针</span></span><br><span class="line">	r = <span class="keyword">new</span> Rectangle;<span class="comment">//为对象动态分配内存空间</span></span><br><span class="line">	r-&gt;init(length, weight);<span class="comment">//初始化对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形长为："</span> &lt;&lt; r-&gt;length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩形宽为："</span> &lt;&lt; r-&gt;weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> r;<span class="comment">//释放动态分配的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，得到下面结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">矩形长为：10</span><br><span class="line">矩形宽为：10</span><br></pre></td></tr></table></figure>
<p>与使用<code>.</code>运算符的结果一致。</p>
<h1 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h1><p>一般的，我们认为对象所占用的内存大小为，等于<strong>所有成员变量的大小之和</strong>。</p>
<p>对于上面的<code>Rectangle</code>类，<code>sizeof(Rectangle)=16</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">	<span class="keyword">double</span> weight;<span class="comment">//宽</span></span><br><span class="line">	Rectangle r;<span class="comment">//声明一个对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Rectangle)="</span> &lt;&lt; <span class="keyword">sizeof</span>(Rectangle) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码，得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sizeof(Rectangle)=16</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>注意</p><ul><li>并不是所有的类所占内存空间大小都为成员变量之和，有时还需要考虑<strong>对齐</strong>等情况，会有所差异。</li><li>一个类的成员函数只有一份，为所有成员共享，故类的成员函数所占用内存空间没有计算。</li><li>每个对象都有自己的存储空间，一个对象的值改变了并不会影响另一个变量</li></ul>
          </div>
<h1 id="类的成员函数和类的定义分开写"><a href="#类的成员函数和类的定义分开写" class="headerlink" title="类的成员函数和类的定义分开写"></a>类的成员函数和类的定义分开写</h1><p>当我们的类拥有很多的成员变量以及成员函数的时候，如果将所有的成员函数的实现都写在类的定义当中的话，就会显得十分的臃肿，不利于代码的阅读。此时，我们可以将类的定义以及实现分类来写，类的定义当中仅写成员函数的定义，而成员函数的实现则写到类的外面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">	<span class="keyword">double</span> weight;<span class="comment">//宽</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> length_, <span class="keyword">double</span> weight_)</span></span>;<span class="comment">//设置长和宽</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;<span class="comment">//计算面积</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">Perimeter</span><span class="params">()</span></span>; <span class="comment">//计算周长</span></span><br><span class="line">&#125;;<span class="comment">//分号不可省略</span></span><br></pre></td></tr></table></figure>
<p>我们改写上面所示的代码，在类的实现当中仅写成员函数的定义。将成员函数写在类外，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rectangle::init</span><span class="params">(<span class="keyword">double</span> length_, <span class="keyword">double</span> weight_)</span> </span>&#123;</span><br><span class="line">	length = length_;</span><br><span class="line">	weight = weight_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Rectangle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> length * weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Rectangle::Perimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * (length * weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其基本格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 类名::函数名(参数表)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>类名::</code>说明后面的函数为类的成员函数，而非普通函数。</p>
<h1 id="类成员的可访问范围"><a href="#类成员的可访问范围" class="headerlink" title="类成员的可访问范围"></a>类成员的可访问范围</h1><p>在类的定义中，用以下的关键字来说明类成员的访问范围：</p>
<ul>
<li><strong>private</strong>：私有成员，只能在成员函数内访问</li>
<li><strong>public</strong>：公用成员，可以在任何地方访问</li>
<li><strong>protected</strong>：保护成员，具体用法以后讨论</li>
</ul>
<div class="note info">
            <ul><li>以上三种关键字出现次数和先后顺序没有限制</li><li>没有说明访问范围的默认为<strong>private</strong></li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">//默认为private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">time_t</span> birthday;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如在上面的学生类中，<strong>name</strong>属性没有指定访问范围，值默认缺省为<strong>private</strong>。</p>
<p>对于上面的类，假设我们有如下外部调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student stu;</span><br><span class="line">	stu.printInfo();<span class="comment">//OK</span></span><br><span class="line">	stu.sex;<span class="comment">//OK</span></span><br><span class="line">	stu.name;<span class="comment">//错误，不能访问私有成员</span></span><br><span class="line">	stu.birthday;<span class="comment">//错误，不能访问保护成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仅能访问类的公有成员(<strong>public</strong>)，不能访问其它属性的成员。</p>
<p>对于如下的内部调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//OK</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; birthday &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的成员函数内部，我们可以访问所有的成员。</p>
<div class="note info">
            <p>注意</p><ul><li><strong>private</strong>属性的成员只能通过类的成员函数访问，不能在类外部访问。</li><li>在类的成员函数内部，能够访问<strong>当前对象的全部属性、函数</strong>以及<strong>同类其它对象的全部属性、函数</strong>。</li><li>在类的成员函数以外的地方，就只能访问该类对象的公有成员(<strong>public</strong>)</li></ul>
          </div>
<p>设置私有成员的的机制叫“<strong>隐藏</strong>”，隐藏的目的时强制成员变量的访问一定要通过成员函数进行，使得成员变量不能被外部所访问到，确保了成员变量的安全，同时也易于以后的维护。</p>
<h1 id="成员函数的重载与缺省"><a href="#成员函数的重载与缺省" class="headerlink" title="成员函数的重载与缺省"></a>成员函数的重载与缺省</h1><p>类的成员函数也可以进行重载以及缺省参数值，其用法与普通函数的重载与参数缺省相同。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>面向对象</tag>
        <tag>c++对象</tag>
        <tag>c++类</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装基本工具及基本命令的使用</title>
    <url>/2019/12/25/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/3%E3%80%81%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在上期文章中，我们完成了Ubuntu的硬盘安装，本期文章将说明基本linux的命令使用以及基本基本工具的安装使用。如果你有过相关linux的使用经验，那么本文纯属在浪费你的时间，你可以选择跳过此篇文章。</p>
<p>就这样，请拥有，并享受。</p>
<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>安装完成后开启电脑，会进入到ubuntu的桌面，我们在屏幕任意位置点击右键，选择Open Terminal来打开一个终端，以后我们的所有工作将在这个终端内完成。</p>
<p>本系列文章不探讨相关实现原理，仅为演示，如何关注的话可以去看linux系统的相关知识。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20214716.jpg" alt="terminal"></p>
<p>更改软件源<br>step1.在终端中敲入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>
<p>然后输入密码，将权限切换到root权限。（输入的密码不会显示，该密码为用户密码）</p>
<p>完成后你会发现前面的提示符由用户名变为了root，这样就可以了。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20215409.jpg" alt="切换权限"></p>
<p>然后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>然后将打开的文本替换为网站<a href="https://developer.aliyun.com/mirror中ubuntu" target="_blank" rel="noopener">https://developer.aliyun.com/mirror中ubuntu</a> 18.04(bionic) 配置的内容，注意选择对应的版本。然后保存。</p>
<p>（注！！在ubuntu中粘贴快捷键为Shift+Insert）<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E9%98%BF%E9%87%8C%E4%BA%91%E8%BD%AF%E4%BB%B6%E5%9B%AD.jpg" alt="阿里云软件源"></p>
<h2 id="基本工具安装"><a href="#基本工具安装" class="headerlink" title="基本工具安装"></a>基本工具安装</h2><p>完成后回到终端，依次执行以下语句，在此对语句做简要说明，如不关注可忽略，直接执行即可。</p>
<p>(注意语句之间的空格不可忽略)</p>
<p>apt是ubuntu中的包管理工具，通过apt命令来管理软件。</p>
<p>step1.更新软件源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>step2.升级软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt -y upgrade</span><br></pre></td></tr></table></figure>
<p>step3.安装vim文本编辑器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y vim</span><br></pre></td></tr></table></figure>
<p>step4.安装ssh远程连接工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y openssh-server</span><br></pre></td></tr></table></figure>
<p>step5.安装网络工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y net-tools</span><br></pre></td></tr></table></figure>
<p>step6.查看IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-23%20222141.jpg" alt="查看ip"></p>
<p>我的网卡在这里为ens33，记住后面的IP地址，不同的机器会有不同的IP。</p>
<p>到这里你就可以扔掉nas的显示器了，接下来的所有操作将会用远程主机连接nas进行操作。</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p>ubuntu不同于windows操作系统，需要具有一定的动手能力，毕竟鼠标那一套在这不好使，在这里我们将介绍相关的一些基本命令使用。</p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><p>在这里不想展开详述linux的相关知识，我也没法把详细的内容说清楚，毕竟那是一个厚几百到几千页的书，如果关注的话可以自行进一步了解。</p>
<p>首先需要知道根目录，也就是<code>/</code></p>
<p>这是linux最为重要的东西，没有之一。所有目录都是由根目录衍生出来的；根目录与系统的开机、修复、还原密切相关；</p>
<p>下面这些内容并不需要你去记住，你只需要知道有这么个东西即可</p>
<p><code>/bin/</code>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</p>
<p><code>/boot/</code>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</p>
<p><code>/dev/</code>设备文件保存位置</p>
<p><code>/etc/</code>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</p>
<p><code>/home/</code>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</p>
<p><code>/lib/</code>系统调用的函数库保存位置</p>
<p><code>/mnt/</code>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</p>
<p><code>/opt/</code>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件</p>
<p><code>/root/</code> root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下/sbin/保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</p>
<p><code>/tmp/</code>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</p>
<h2 id="基本命令使用"><a href="#基本命令使用" class="headerlink" title="基本命令使用"></a>基本命令使用</h2><ol>
<li><p>cd命令<br>cd命令用来在上面这些目录之间切换，用法为cd+路径，例如要到/mnt目录中<code>cd /mnt</code></p>
</li>
<li><p>ls命令<br>ls是显示当前路径中的文件和文件夹的，直接输入ls即可</p>
</li>
<li><p>vim编辑器使用<br>参考：点击这里<br>知道<strong>-i插入</strong>、<strong>:wq保存退出</strong>即可</p>
</li>
</ol>
<p>专栏目录<br>注！[✔]表示已更新，[✖] 表示未更新</p>
<p>[✔] 前言</p>
<p>[✔] Ubuntu18.04的安装</p>
<p>[✔] Ubuntu18.04基本软件安装及使用</p>
<p>[✖] Docker安装</p>
<p>[✖] 控制面板</p>
<p>[✖] jellyfin影音服务</p>
<p>[✖] 网盘服务</p>
<p>[✖] 下载工具</p>
<p>[✖] 笔记管理</p>
<p>[✖] 手机开关机</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>Ubuntu18.04配置</tag>
        <tag>Ubuntu配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH工具Xshell的安装以及使用</title>
    <url>/2019/12/26/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/4%E3%80%81SSH%E5%B7%A5%E5%85%B7Xshell%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在原本的计划中并没有准备专门写一篇关于SSH远程连接的教程，但想了想，该专栏文章应该致力于让所有读者都能看懂，即使你是从未使用过Linux操作系统的小白。</p>
<p>当然，本文仅介绍了XShell的试用，你也可以选择其他软件，这都一样，并不影响你的使用。</p>
<p>如果你已经有相关的使用经验，那么你可以直接跳过本章，毕竟下面的内容会浪费你宝贵生命中的几分钟。</p>
<p>就这样，请拥有，并享受。</p>
<h1 id="下载Xshell"><a href="#下载Xshell" class="headerlink" title="下载Xshell"></a>下载Xshell</h1><p>首先到XShell的官网：<a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">点击这里</a>点击<strong>下载</strong>按钮，之后会跳转到一个信息填写页面，可以申请30天的免费试用。作为学校和家庭用户，点击右边的<a href="https://www.netsarang.com/zh/free-for-home-school/" target="_blank" rel="noopener"><strong>免费授权页面</strong></a>可以申请免费使用。</p>
<p>填写完信息后下载链接会发送到你所填写的邮箱中，点击里面的下载链接即可下载。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20060647.jpg" alt="Xshell主页"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20060720.jpg" alt="信息填写"></p>
<h1 id="使用Xshell"><a href="#使用Xshell" class="headerlink" title="使用Xshell"></a>使用Xshell</h1><p>下载完成安装后，打开软件可以看到下图所示的页面。<br>（我这里以及添加有很多连接，可以忽略）</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/Xshell%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2.jpg" alt="XShell软件启动"></p>
<p>然后点击对话框左上角添加按钮，在弹出的对话框<strong>名称</strong>处输入你想要的名称，<strong>主机</strong>一栏输入你在<strong>第一篇文章中</strong>所查看的主机<strong>IP</strong></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA.jpg" alt="IP输入"></p>
<p>然后点击界面左边的<strong>用户身份验证</strong>，进入后输入<strong>用户名</strong>和<strong>密码</strong>，该用户名和密码为你在安装Ubuntu时设置的用户名以及密码。</p>
<p>然后点击连接，中途会跳出是否保存用户名密码，自己根据情况选择；在跳出密钥接收保存询问框的时候选择接收并保存。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.jpg" alt="用户名密码输入"></p>
<p>然后看到下如所示的提示信息即说明连接成功。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20062918.jpg" alt="连接成功"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>整个NAS的前期准备工作到此就结束了，在接下来的文章中我们将一同探讨大家比较关心的影音服务、管理面板、网盘工具等内容的搭建了。</p>
<p>前面的文章看起来多少有些无趣，但这却是整个系统管理中不可获缺的。如上面提到的基本命令，这将是你使用频率非常高的命令，甚至可以说这些是你进行接下来的工作不可少的东西，如果你还没有掌握它的话，应该利用闲余的几分钟去了解一下它。</p>
<p>使用Ubuntu的过程中，你或多或少会在搜索引擎中查找相应技术文章，再次过程中你将会感受到计算机专业的开源精神。</p>
<p>但是，在寻求解决方案的时候<strong>请不要轻易尝试别人给你的命令，除非你想把之前的工作从头再来一遍</strong>。执行任何含有<strong>rm</strong>的命令你都应当十分小心地确认你的操作，尤其是在你的数据盘中。</p>
<p>请牢记好上面的内容，<strong>必要的时候请先在虚拟机中验证它的正确性</strong>。</p>
<h1 id="专栏导航"><a href="#专栏导航" class="headerlink" title="专栏导航"></a>专栏导航</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>xshell配置</tag>
        <tag>ssh安装及使用</tag>
        <tag>xshell安装</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客next主题插入图片问题</title>
    <url>/2019/07/12/hexo%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>最近在使用hexo博客next主题的时候发现kramed渲染器在处理插入的图片时不显示标题描述，仅仅显示图片。例如我通过<code>![描述](url连接)</code>的形式插入一张图片，kramed渲染器将其渲染为下面这样：</p>
<a id="more"></a>
<figure><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%9C%AA%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0.jpg" alt="未显示图片描述.jpg"><figcaption>"未显示图片描述"</figcaption></figure>

<p>并未将图片的描述显示在下方，这对于在文中想要引用插入的图片变得尤为困难，搜索引擎也没有找到相关的问题以及解决办法（也许是我搜索引擎用的不是很好^^）。<br>在查看了渲染出来的网页后，发现kramed在渲染图片时将<code>[]</code>中的的图片描述渲染为了 <code>alt</code>属性，这是图片加载错误时显示的替补文字，按照 <a href="https://github.com/iissnan/hexo-theme-next/issues/436" target="_blank" rel="noopener">hexo-theme-next #436</a>中的方法找到<code>var imageTitle = $image.attr(&#39;title&#39;);</code>，将其中的<code>title</code>改为<code>alt</code>，但是任然无法解决问题。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>查看其它网站的图片对于的<code>html</code>源码发现，在插入图片之后，图片的部分代码为：<br><code>&lt;figure&gt;&lt;img src=&quot;URL&quot; alt=&quot;未正常显示图片描述&quot;&gt;&lt;figcaption&gt;&quot;图片描述&quot;&lt;/figcaption&gt;&lt;figure&gt;</code>而kramed渲染出来的格式为：<br><code>&lt;img src=&quot;URL&quot; alt=&quot;未显示图片描述&quot;&gt;</code><br>发现少了一对<code>&lt;figure&gt;</code>和一对<code>&lt;figcaption&gt;</code>标签，从这个思路出发，Google后发现，<code>&lt;figure&gt;</code> 标签是 <code>HTML5</code> 中的新标签，用作文档中插图的图形，其基本用法为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> <span class="attr">alt</span>=<span class="string">"未显示图片描述"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>src</code>为图片的地址。</li>
<li><code>width</code>为图片显示宽度。</li>
<li><code>height</code>为图片显示高度。</li>
<li><code>alt</code>为未正常显示图片时的描述</li>
</ul>
<p><code>width</code>和<code>height</code>参数可以不写，这样会保持图片原有比例，进一步查看后了解到，<code>&lt;figcaption&gt;</code> 标签也是 <code>HTML5</code> 中的新标签，是与其相关联的图片的说明/标题，用于描述其父节点 <code>&lt;figure&gt;</code> 元素里的其他数据。基本用法为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> <span class="attr">alt</span>=<span class="string">"未显示图片描述"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图片描述/说明<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="更改图片插入格式"><a href="#更改图片插入格式" class="headerlink" title="更改图片插入格式"></a>更改图片插入格式</h2><p>有了这些概念后，既然markdown支持<code>html</code>语法，通过改变图片的插入方式以及增加适当的标签，就可以正常地渲染出图片描述了，通过这个构思，开始着手改进。我用的编辑器是<code>visual studio code</code>，markdown文件也是在里面编辑，图片通过PicGo上传至GitHub图床。<br>首先设置PicGo的输出格式，先来看PicGo的说明</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Picgo:</span> <span class="string">Custom</span> <span class="string">Output</span> <span class="string">Format</span></span><br><span class="line"><span class="string">Customize</span> <span class="string">the</span> <span class="string">output</span> <span class="string">format</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image.</span></span><br><span class="line"><span class="string">$&#123;url&#125;:</span> <span class="string">the</span> <span class="string">url</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image.</span></span><br><span class="line"><span class="string">$&#123;uploadedName&#125;:</span> <span class="string">the</span> <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">uploaded</span> <span class="string">image,</span> <span class="attr">see Picgo:</span> <span class="string">Custom</span> <span class="string">Upload</span> <span class="string">Name.</span></span><br><span class="line"><span class="attr">Examples:</span></span><br><span class="line"><span class="string">![$&#123;uploadedName&#125;]($&#123;url&#125;)</span> <span class="string">-&gt;</span> <span class="string">![picName-2016-07-25](https://example.com/xxx.jpg)</span></span><br><span class="line"><span class="string">&lt;img</span> <span class="string">src="$&#123;url&#125;"</span> <span class="string">alt="$&#123;uploadedName&#125;"&gt;</span> <span class="string">-&gt;</span> <span class="string">&lt;img</span> <span class="string">src="https://example.com/xxx.jpg"</span> <span class="string">alt="picName-2016-07-25"&gt;</span></span><br></pre></td></tr></table></figure>
<p>有几个参数要注意，<code>url</code>是图片的地址，<code>uploadedName</code>是图片上传时的图片标题，上面给出了基本使用样例。我们想得到的一个格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片URL"</span> <span class="attr">alt</span>=<span class="string">"未显示图片时的描述"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图片描述/说明<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们需要一个这样的基本格式，于是将输出格式改为下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;url&#125;"</span> <span class="attr">alt</span>=<span class="string">"$&#123;uploadedName&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>"$&#123;uploadedName&#125;"<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加一对<code>&lt;figure&gt;</code>标签和一对<code>&lt;figcaption&gt;</code>标签，将图片名用作描述/说明文字，这样就解决了插入格式问题，只要通过PicGo上传图片，就自动导出连接格式。</p>
<h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><p>但是还有一个问题是，图片增加了两队标签，看似可以解决问题，然而hexo是通过渲染器（我用的是kramed）将markdown文件渲染为html文件。在渲染的时候渲染器将无法通过CSS渲染<code>&lt;figcaption&gt;</code>标签，这样最终显示出来的图片虽然显示了描述/说明，但是描述和普通文本并没有什么区别，不会在图片下方居中，看不出和图片有啥联系。这时候通过修改<code>themes\next\source\css\_common\components\post\post.styl</code>文件，往里面增加<code>&lt;figcaption&gt;</code>的css样式为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">figcaption</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#808080;</span></span><br><span class="line">    <span class="attr">font:</span> <span class="string">italic</span> <span class="string">16px</span> <span class="string">arial</span> <span class="string">smaller</span> <span class="string">sans-serif;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="string">0px;</span></span><br><span class="line">    <span class="attr">text-align:</span> <span class="string">center;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>color</code>为描述文字的颜色</li>
<li><code>font</code>为字体属性</li>
<li><code>padding</code>为离图片的距离</li>
<li><code>text-align</code>为文字对齐方式，<code>center</code>为居中显示</li>
</ul>
<p>保存之后执行<code>hexo clean</code>清除，然后执行<code>hexo g</code>重新渲染，就可以看到图片的描述正常显示了。如下图：</p>
<figure><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0.jpg" alt="正常显示图片描述.jpg"><figcaption>"正常显示图片描述"</figcaption></figure>

<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>[1]  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure" target="_blank" rel="noopener">figure：可附标题内容元素</a></p>
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>next主题</tag>
        <tag>图片问题</tag>
        <tag>markdown插入图片</tag>
        <tag>hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB-UI管理面板Cockpit(轻量简单)安装与使用</title>
    <url>/2019/12/28/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/6%E3%80%81WEB-UI%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFCockpit(%E8%BD%BB%E9%87%8F%E7%AE%80%E5%8D%95)%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在前面我们介绍了管理面板Webmin的安装与使用，这次我们来看Cockpit的安装与使用，Webmin与Cockoit都属于轻量级的管理面板，但是Cockpit的功能较Webmin有了更多的减少，提供了更多的图表可视化功能，对中文的支持也比Webmin要好得多。</p>
<p>cockpit提供了几乎所有Linux发行版本的安装包，对各个Linux平台支持都很好，这在官方的宣传里可以看到。该软件为开源软件，并在官网提供了详细的开发者文档。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20141709.jpg" alt="cockpit"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>cockpit的官网提供了各平台的安装方法以及相关的的使用文档，并且在Ubuntu17.04以及之后的Ubuntu版本中加入了官方的软件源中，这意味这我们可以很容易地安装Cockpit。</p>
<p>只需要在终端中执行以下命令即可安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt -y install cockpit</span><br></pre></td></tr></table></figure><br>安装完成后没有给出任何地提示信息，我们只需要用浏览器打开<code>https://服务器IP:9090</code>即可打开监控界面，然后输入ubuntu的用户名密码就可以登录它。<br>（打开过程中浏览器可能会拦截该页面，允许访问即可）</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>在浏览器中打开<code>https://服务器IP:9090</code>后我们可以看到如下画面，输入用户名、密码登录即可。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20141314.jpg" alt="cockpit登录界面"></p>
<p>登录成功后我们就进入道路cockpit的管理界面，在这里可以直观的看到NAS的运行状态，包括CPU使用率、内存使用率、硬盘使用率等。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20141354.jpg" alt="cockpit仪表盘"></p>
<p>下面我们来看看cockpit中有那些功能。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97.jpg" alt="系统日志"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.jpg" alt="存储管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86.jpg" alt="网络管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1.jpg" alt="系统服务"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E4%BB%AA%E8%A1%A8%E7%9B%98.jpg" alt="仪表盘"></p>
<h1 id="cockpit使用"><a href="#cockpit使用" class="headerlink" title="cockpit使用"></a>cockpit使用</h1><p>在cockpit中我们可以很方便的管理各系统服务，下面将介绍一些基本的管理功能</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>在磁盘管理中，为我们提供了图形化创建RAID设备，可支持RAID0、1、4、5、6、10。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20143552.jpg" alt="创建RAID设备"></p>
<p>可以图形化创建磁盘分区表，格式化磁盘。可支持GPT以及MBR分区方式。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20143743.jpg" alt="创建磁盘分区表"></p>
<p>更改磁盘挂载点等</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144009.jpg" alt="磁盘挂载点"></p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>可以添加绑定、添加网桥、划分vlan的网络操作。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%B7%BB%E5%8A%A0%E7%BB%91%E5%AE%9A.jpg" alt="添加绑定"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144216.jpg" alt="添加网桥"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144227.jpg" alt="VLAN划分"></p>
<p>还可以进行ipv4、ipv6等设置，支持管理连接状态，实时日志查看等</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/ipv4.jpg" alt="IPV4设置"></p>
<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><p>支持查看相关系统服务进程，并支持启用、禁用相关进程。支持定时任务管理等</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144606.jpg" alt="系统服务管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144730.jpg" alt="定时任务"></p>
<p>除此之外，还提供了一个终端的功能，可直接在网页中打开终端</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-26%20144908.jpg" alt="终端"></p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>cockpit比webmin要精简很多，去除了很多感觉不要的东西，在我看来是最适合做NAS管理面板的软件，其使用起来也很方便，不需要很复杂的操作就可以管理系统相关服务。对各种数据监控提供了很好的图形可视化支持，能很好的查看系统使用状态</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>linux管理面板</tag>
        <tag>Cockpit</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu挂载硬盘</title>
    <url>/2019/12/29/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/7%E3%80%81Ubuntu%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>在开始下篇文章之前我觉得有必要讲解一下在linux中的硬盘挂载。这和Windows不同，Windows会自动扫描本地硬盘并为你自动挂载，但是linux不会值么做，它需要你自己去挂载硬盘到系统中。</p>
<p>如果你是新硬盘，你需要对硬盘进行格式化才能正常使用，linux支持ext4、NTFS等文件系统，在此建议将硬盘格式化为NTFS格式，这样就算你把硬盘从linux移动Windows环境下也可以正常使用，Windows不知EXT4文件系统。</p>
<p>但是格式化NTFS也会带来一个弊端，就是你无法对文件进行权限操作，这样你在使用的时候应该小心一些，避免误操作删除硬盘数据。</p>
<h1 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h1><p>如果你的硬盘已经格式化过存有数据的话，你应该跳过这一小节的内容，直接跳转到下一小节参考硬盘挂载操作。</p>
<p>首先你需要查看设备位置，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>然后找到你需要挂载的硬盘，例如我在这里要挂载<strong>Disk /dev/sdb: 7.3 TiB</strong>这块磁盘，记下它的位置，这里为/dev/sdb</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20160129.jpg" alt="查看硬盘设备"></p>
<h2 id="格式化为EXT4格式"><a href="#格式化为EXT4格式" class="headerlink" title="格式化为EXT4格式"></a>格式化为EXT4格式</h2><p>如果需要格式化为EXT4格式，只需要执行下面语句即可，将/dev/sdb换成你需要进行格式化操作的设备路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4  &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure></p>
<h2 id="格式化为NTFS"><a href="#格式化为NTFS" class="headerlink" title="格式化为NTFS"></a>格式化为NTFS</h2><p>NTFS是windows的文件系统，在进行格式化操作之前需要安装一个工具，输入下面命令进行安装。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt -y install ntfsprogs</span><br></pre></td></tr></table></figure><br>安装完成后执行格式化语句，这里同样将/dev/sdb更改为你要执行格式化操作的设备路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkntfs -f &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><br>到此就将硬盘格式化完成了，接下来进行挂载操作</p>
<h1 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h1><p>在进行挂载操作之前需要先查看硬盘的UUID值，输入sudo blkid进行查看</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20162314.jpg" alt="UUID值"></p>
<p>这里假设我们要挂载/dev/sdb1: LABEL=”mybook” UUID=”21B724CC1FE1D190” TYPE=”ntfs” ···这块硬盘，我们选中UUID后面的值（不要双引号），在xshell中可以右键复制下来。</p>
<p>然后创建一个挂载点，这个挂载点就是你以后打开查看硬盘内容的地方，这里假设我们需要将硬盘挂载到/mnt/sdb这个路径。你可以选择其他任何一个你觉得可以的地方进行挂载。<br>首先执行<strong>cd /mnt</strong>进入到mnt目录。<br>然后执行<strong>mkdir sdb</strong>创建一个名为sdb的文件夹，这个文件夹为我们需要挂载硬盘的地方。</p>
<p>然后编辑系统挂载配置文件/etc/fstab</p>
<p>执行<strong>vim /etc/fstab</strong>打开配置文件，可以看到下图所示的内容<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20163118.jpg" alt="fstab文件"></p>
<p>这里的格式为<strong>设备名称 挂载点 分区类型 挂载选项 dump选项 fsck选项</strong><br>dump为0表示不进行备份<br>fsck为启动时检查顺序，0为不检查，/更目录为1，其他只能从2开始</p>
<p>添加要挂载的内容到末行，这里我们以刚才的为例<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20163801.jpg" alt="挂载设置"><br>挂载点为我们刚才设置的挂载路径/mnt/sdb，格式为NTFS（如果你格式化为ext4，这里就填ext4），挂载选项默认defaults，不进行备份，开机不检查。</p>
<p>挂载完成后执行<code>reboot</code>命令重启电脑，重启后我们就可以到/mnt/sdb目录下查看硬盘内容了</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20164125.jpg" alt="查看硬盘数据"></p>
<h1 id="查看硬盘使用状态"><a href="#查看硬盘使用状态" class="headerlink" title="查看硬盘使用状态"></a>查看硬盘使用状态</h1><p>除了在WEB-UI管理界面中查看硬盘使用状态，我们也可以在命令行中输入<strong>df -h</strong>查看硬盘使用状态<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20164727.jpg" alt="硬盘使用状态"><br>Size为总分区大小<br>Used为已使用<br>Avail为可用容量<br>Use%为使用百分比<br>Mounted on为挂载点</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>linux硬盘挂载</tag>
        <tag>ubuntu挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB-UI管理面板webmin（轻量级较全面）安装及使用</title>
    <url>/2019/12/27/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/5%E3%80%81WEB-UI%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFwebmin%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BE%83%E5%85%A8%E9%9D%A2%EF%BC%89%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>相信很多人选择黑群晖的原因之一是因为群晖有很好的图形化管理面板，其实Ubuntu，或者说linux也可以很好的图形化管理面板。</p>
<p>本系列文章将介绍两种轻量级的管理面板<strong>Webmin(功能较全面)</strong>和<strong>Cockpit(功能简单)</strong>，对于那些功能全面的重量级面板，再次不做介绍，尽管那些工具开发得很完善，但是在家用nas上使用却显得有些臃肿了。</p>
<p>就这样，请拥有，并享受。</p>
<h1 id="Webmin安装"><a href="#Webmin安装" class="headerlink" title="Webmin安装"></a>Webmin安装</h1><p>对于Webmin的安装以及使用在它的官网中有详细的介绍，大家可以参考官网。</p>
<p>传送门：<a href="http://www.webmin.com/" target="_blank" rel="noopener">点击这里</a></p>
<ol>
<li>打开xshell并连接到主机，然后切换到<strong>root</strong>用户，执行一下命令下载软件包<br>（我在写文章安装时的版本为1.930，安装时可到官网查看最新版本）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;prdownloads.sourceforge.net&#x2F;webadmin&#x2F;webmin_1.930_all.deb</span><br></pre></td></tr></table></figure>
执行dpkg命令进行安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg --install webmin_1.930_all.deb</span><br></pre></td></tr></table></figure>
提示：在输入时可以使用Tab键进行命令补全。</li>
</ol>
<p>在执行上面的语句时，你可能会得到下面的报错：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20072855.jpg" alt="缺少编译环境"></p>
<p>这是由于缺少编译环境导致的，输入以下命令安装相关相关工具<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install perl libnet-ssleay-perl openssl libauthen-pam-perl libpam-runtime libio-pty-perl apt-show-versions python</span><br></pre></td></tr></table></figure><br>在输入完上述命令后，可能还会出现一个错误如下：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20073439.jpg" alt="错误提示"></p>
<p>此时我们按照提示运行输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt --fix-broken install</span><br></pre></td></tr></table></figure><br>然后再运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg --install webmin_1.930_all.deb</span><br></pre></td></tr></table></figure><br>即可安装成功，安装完成后如下图</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20073838.jpg" alt="安装完成"></p>
<p>Webmin默认安装到<code>/usr/share/webmin</code>目录下，我们可以通过<code>https://服务器ip:10000/</code>来登录管理面板；登录密码为<code>root</code>密码或者可以运行<code>sudo su</code>的管理者用户名密码来登录。</p>
<p>（因为Ubuntu不允许使用<code>root</code>来作为默认登录用户，你可以使用其它可以执行<code>sudo su</code>切换到管理员权限的用户名密码来作为登录用户）</p>
<h1 id="Webmin配置"><a href="#Webmin配置" class="headerlink" title="Webmin配置"></a>Webmin配置</h1><p>完成安装后我们用浏览器打开<code>https://服务器ip:10000/</code>来进入管理面板，打开后会跳出一个错误页面，点击提示中的URL链接即可正常进入。<br>（如果浏览器有安全警告，直接跳过继续前往即可）</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20084600.jpg" alt="打开跳转提示"></p>
<p>之后便是登录界面，输入上面提到的用户名密码进行登录</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20084629.jpg" alt="登录"></p>
<p>完成登录后就进入到管理面板的界面了</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20085032.jpg" alt="管理面板界面"></p>
<p>现在界面显示的英文，我们可以到<code>Webmin -&gt; Webmin Configuration -&gt; Language and Locale</code>将语言改为中文，记得保存。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20085522.jpg" alt="更改语言"></p>
<p>我们可以在面板中很直观地查看到系统的相关信息以及进行相关配置。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20085758.jpg" alt="系统监视"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20085945.jpg" alt="网络管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20090041.jpg" alt="磁盘管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20090156.jpg" alt="开关机管理"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-25%20090317.jpg" alt="进程管理"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Webmin的功能还是比较全面的，可以通过安装模块来扩展功能，支持集群管理等。</p>
<p>到这里本篇文章就结束了，以后就可以通过浏览器来查看以及管理nas了。</p>
<h1 id="专栏目录"><a href="#专栏目录" class="headerlink" title="专栏目录"></a>专栏目录</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>linux管理面板</tag>
        <tag>WEB-UI管理面板</tag>
        <tag>webmin</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下Docker的安装与使用</title>
    <url>/2019/12/30/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/8%E3%80%81Ubuntu%E4%B8%8BDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>经过前面那么多期的铺垫，今天我们终于可以来安装使用我么的docker了。这是一个非常好用的工具，我们的NAS服务百分之九十都会部署在docker上运行。</p>
<p>有了docker以后，你不再需要小心翼翼地担心把系统配置搞乱无法恢复，在这里你可以通过几个简单地命令就可以将相关服务重新部署回来。</p>
<p>就这样，请拥有，并享受</p>
<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>如你并不想了解Docker是什么，只需要能简单的用就行地话你可以跳过本小节，直接进入Docker的安装部分。</p>
<p>关于Docker的详细信息我们可以去Docker的官网查看，<a href="https://docs.docker.com/" target="_blank" rel="noopener">点击这里</a>可以跳转。</p>
<blockquote>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
</blockquote>
<p>这是百科对Docker的解释，看到这里是不是很懵，不要紧，我来为你解释。</p>
<p>Docker是一个容器引擎，容器就是用来放东西的，Docker容器里面放的就是操作系统，一个容器对应一个操作系统，你可以把Docker想象成虚拟机，但是和虚拟机不同的是，得益于Docker的机制，在Docker中运行虚拟机往往不需要很多内存以及处理器资源，相比VMWare动则几个G的大小，在Docker中运行一个虚拟机仅需几十兆到几百兆的空间，你可以运行几十甚至上百个虚拟机在Docker中，这是VMWare所不能比的。</p>
<p>在开始搭建之前，你需要了解docker的几个基本概念</p>
<p>镜像：镜像就是实际就类似于一个安装镜像，比如你需要安装Windows，那么你需要去微软的官网下载windows的镜像，你才能进行安装。</p>
<p>DockerHub：DockerHub就是一个存放以及分享镜像的地方，你可以将你自己制作的镜像上传到DockerHub与别人分享，你也可以到DockerHub下载别人分享的镜像进行使用。</p>
<p>容器：当你启动了一个镜像之后，对应着就会有一个容器生成，容器是用来存储镜像运行时的状态的，这就相当于你通过镜像创建了一个虚拟机，那么创建完成后你的虚拟机就跑在了容器中。镜像是静态的，而容器是动态的。</p>
<p>有了对Docker的一个简单了解后，我们就可以进行接下来的操作了。</p>
<h1 id="Docker安装与卸载"><a href="#Docker安装与卸载" class="headerlink" title="Docker安装与卸载"></a>Docker安装与卸载</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>在apt的官方源中已经加入了Docker，但是这往往不是最新的版本，要安装最新的版本，我们需要进行一些简单的配置。</p>
<p>Docker提供了<code>Enterprise</code>以及<code>Community</code>两个版本可供安装，我们只需要安装<code>Community</code>版即可，这是一个社区版，可以免费使用。</p>
<p>如果你以及安装了一个老的版本的Docker，那么你需要先卸载它，老版本的Docker软件名字为<code>docker</code>、<code>docker.io</code>或者是<code>docker-engine</code>，你可以通过下面语句卸载它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<ol>
<li>首先更新<code>apt</code>包的索引：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li><p>安装软件包以允许<code>apt</code>通过<code>HTTPS</code>使用存储库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加Docker的官方GPG密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p><code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure>
<p>执行后出现以下内容即添加成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下命令来设置稳定的存储库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>apt</code>包索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装最新版本的Docker Engine-Community和containerd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
<p>如果出现如下的版本号，即为安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker version 19.03.5, build 633a0ea838</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Docker卸载"><a href="#Docker卸载" class="headerlink" title="Docker卸载"></a>Docker卸载</h2><ol>
<li>卸载Docker Engine-社区软件包：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt purge docker-ce</span><br></pre></td></tr></table></figure></li>
<li>主机上的映像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Docker配置及基本使用"><a href="#Docker配置及基本使用" class="headerlink" title="Docker配置及基本使用"></a>Docker配置及基本使用</h1><p>在完成docker的安装后，我们就可以开始使用docker来部署服务了，在此之前，我们先来学习一下docker的基本使用方法。</p>
<p>在docker中你首先需要有镜像文件（images），你才可以通过镜像来部署相关服务，镜像的话你可以到DockerHub获取，也可以自己写dockerfile来构建镜像（本专栏不涉及）。</p>
<h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><ol>
<li>修改镜像源<br>docker服务器在国外，在国内访问速度很慢，我们可以通过修改镜像源为阿里云来启用加速</li>
</ol>
<p>首先到阿里云<a href="https://www.aliyun.com/product/acr" target="_blank" rel="noopener">镜像服务中心</a>，你需要登录阿里云。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20202216.jpg" alt="镜像服务中心"></p>
<p>然后进入<strong>管理控制台</strong>，然后选择<code>镜像中心 -&gt; 镜像加速器</code></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20202344.jpg" alt="镜像加速器"><br>如果你没有的话会提示你进行申请，完成后会看到上图的信息，会提示你进行配置，配置的话你只需要将配置镜像加速器下方的代码复制到终端执行即可（如果你分不清命令的话一次性全部复制完，粘贴后按下回车键）。<br>这样当以后下载镜像的时候就会快很多。</p>
<h2 id="Docker基本使用"><a href="#Docker基本使用" class="headerlink" title="Docker基本使用"></a>Docker基本使用</h2><ol>
<li>获取镜像文件<br>首先到docker官网：<a href="https://hub.docker.com/" target="_blank" rel="noopener">点击这里</a>进行注册注册完成后登录<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20203405.jpg" alt="Docker官网"><br>然后点击左上角的搜索框输入需要搜索的东西可进行搜索，这里以搜索Ubuntu为例<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20203714.jpg" alt="镜像搜索"><br>完成搜索后我们可以看到列出了很多的项目，我们根据自己的需要点开一个镜像<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20203937.jpg" alt="镜像页面"><br>在这里我们我们可以看到相关的镜像描述以及基本的信息，右边有一栏黑色的代码框，通过输入代码框的命令我们即可获取相关的镜像。<br>在这里我们输入一下命令来获取镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20205329.jpg" alt="获取镜像"></li>
</ol>
<p>下载完成后我们可以通过以下命令查看本地的镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20205540.jpg" alt="查看本地镜像"></p>
<p><strong>REPOSITORY</strong>：镜像名<br><strong>TAG</strong>：标签：latest为最新版本<br><strong>IMAGE ID</strong>：镜像ID，镜像唯一标识符<br><strong>CREATED</strong>：构建时间<br><strong>SIZE</strong>:镜像大小</p>
<ol>
<li>构建容器<br>在有了本地镜像之后，我们就可以来构建容器了，我们先通过一个简单的例子来讲解<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9999:8096 \</span><br><span class="line">--name&#x3D;ubuntu \</span><br><span class="line">-v &#x2F;mnt&#x2F;sda:&#x2F;mnt \</span><br><span class="line">--restart&#x3D;always \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;renderD128:&#x2F;dev&#x2F;dri&#x2F;renderD128 \</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>
出现下图所示内容即创建成功</li>
</ol>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-27%20210815.jpg" alt="创建成功"></p>
<p>上面命令你也可以将\符去掉写成一行，这里来讲解一下各个参数的作用</p>
<p>-d：表示运行容器后台运行<br>-p：端口映射，格式为<strong>主机端口：容器内端口</strong>，即通过主机的该端口既可以访问到容器内的端口内容<br>—name：命名容器，默认生成的容器名字是随机的，可以通过该命令指定<br>-v：绑定文件卷，格式为<strong>主机目录：容器内目录</strong>，在主机上的某一目录映射到容器内，即通过容器内指定的目录即可访问到主机对应的目录中的文件。<br>—restart：开机重启，always为开机重启<br>—device：绑定硬件到容器内部，在后面章节做详细讲解。</p>
<h2 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h2><p>创建成功后我们可以通过如下命令查看正在运行的容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><br>通过一下命令查看所用容器，包括未运行的容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><br>停止容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>这里容器id只需要输入前几位就可以，只要能和其他的区别开来就行</p>
<p>启动容器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>删除容器（删除前需要先停止容器）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名&#x2F;容器id</span><br></pre></td></tr></table></figure><br>删除镜像（删除前需先删除用该镜像构建的容器）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id</span><br></pre></td></tr></table></figure></p>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><ol>
<li><code>docker pull</code>：拉取镜像</li>
<li><code>docker images</code>：查看本地镜像</li>
<li><code>docker run</code>：通过镜像构建容器</li>
<li><code>docker ps</code>：查看正在运行的容器</li>
<li><code>docker ps -a</code>：查看所有容器</li>
<li><code>docker start</code>:启动容器</li>
<li><code>docker stop</code>：停止容器运行</li>
<li><code>docker rm</code>：查出容器</li>
<li><code>docker rmi</code>：删除镜像</li>
</ol>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>容器相对来说使用还是比较简单的，通过简单的学习就可以使用。如果你对其还不是很熟悉，你应该多去实际使用上面的命令，在这里你不用担心出错，大不了使用<code>docker rm</code>删除了再来一次，而不用担心物理机环境遭到破坏。</p>
<h1 id="目录专栏"><a href="#目录专栏" class="headerlink" title="目录专栏"></a>目录专栏</h1>]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>docker</tag>
        <tag>ubuntu安装docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数列极限的定义及应用</title>
    <url>/2020/06/04/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1%E3%80%81%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="数列极限的定义"><a href="#数列极限的定义" class="headerlink" title="数列极限的定义"></a>数列极限的定义</h1><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>我们先来看一个数列$x_n=\frac{1}{n}$</p>
<p>当$n=1$时，$x_1=\frac{1}{1}=1$</p>
<p>当$n=2$时，$x_2=\frac{1}{2}$</p>
<a id="more"></a>
<p>$\cdots$</p>
<p>当$n=1000$时，$x_{1000}=\frac{1}{1000}$</p>
<p>$\cdots$</p>
<p>当$n\to\infty$时，数列$x_n$的值无限接近$0$。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200604165314460.png" alt="image-20200604165314460"></p>
<p>此时我们就可以说$\underset{n\to \infty }{\text{lim}}\frac{1}{n}=0$。这样我们就可以给出数列极限的一个直观定义：</p>
<script type="math/tex; mode=display">
\underset{n\to \infty }{\text{lim}}x_n=A\Longleftrightarrow n\to \infty ,x_n\rightarrow A</script><blockquote>
<p>当$n$趋近于无穷大时，数列极限$x_n$<strong>无限接近</strong>于一个值$A$。</p>
</blockquote>
<p>用<strong>无限接近</strong>来描述这个定义是不严谨的，我们需要找到一种更加精确的语言来描述这段话。那么如何用数学语言来描述这一变化呢？？</p>
<h2 id="数列极限定义"><a href="#数列极限定义" class="headerlink" title="数列极限定义"></a>数列极限定义</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>分析数列$a_n=\frac{(-1)^n }{n}\sin \left(\frac{1}{n}\right)$的变化趋势</p>
<p>我们任意给定一个$\varepsilon&gt;0$，$\varepsilon$为一个任意小的值，总存在一个$N$(这里的$N$指数列的第$N$项)，当$n&gt;N$时，总存在$|a_n-0|&lt;\frac{1}{n}$，如下</p>
<ul>
<li>取$\varepsilon=\frac{1}{2}$，当$n&gt;2$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_1=2,|a_n-0|&lt;\frac{1}{2}$。</li>
<li>取$\varepsilon=\frac{1}{2^2}$，当$n&gt;2^2$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_2=2^2,|a_n-0|&lt;\frac{1}{2^2}$。</li>
<li>取$\varepsilon=\frac{1}{2^k}$，当$n&gt;2^k$，有$|a_n-0|&lt;\frac{1}{n}&lt;\varepsilon\Longrightarrow n&gt;N_k=2^k,|a_n-0|&lt;\frac{1}{2^k}$。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定数列$\left \{a_n \right\}$，$a$为常数，如果对于任意的$\varepsilon&gt;0$，都存在一个自然数$N$，使得当$n&gt;N$时，成立</p>
<script type="math/tex; mode=display">
|a_n-a|<\varepsilon</script><p>则称数列$\left \{a_n \right\}$以$a$为极限，记作$\underset{n\to \infty }{\text{lim}}a_n=a$</p>
<p>如果该数列没有极限，则称该数列是<strong>发散</strong>的。</p>
<p>需要注意</p>
<ul>
<li>定义中的$\varepsilon$刻画了$x_n$与$a$的逼近程度，定义中的$\varepsilon$可以限制$\varepsilon &lt; a$</li>
<li>定义中的$N$和$\varepsilon$有关，仅要求存在，一般$\varepsilon$越小，$N$越大。</li>
</ul>
<h3 id="数学符号描述"><a href="#数学符号描述" class="headerlink" title="数学符号描述"></a>数学符号描述</h3><script type="math/tex; mode=display">
\forall \varepsilon > 0,\exists N(\varepsilon)\in N^*,\forall n>N:|x_n-a|<\varepsilon</script><p>其中“$\forall$”表示任意的，“$\exists$”表示存在，“$:$”表示满足</p>
<h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>推论$\underset{n\to \infty }{\text{lim}}a_n=a\Longleftrightarrow$当$n&gt;N$时，所有的点$x_n$都落在$(a-\varepsilon,a+\varepsilon)$内，只有有限个(最多$N$个落在其外)。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200605001400184.png" alt="image-20200605001400184"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200605001429236.png" alt="image-20200605001429236"></p>
]]></content>
      <categories>
        <category>数学分析</category>
      </categories>
      <tags>
        <tag>数列极限</tag>
        <tag>数列极限定义</tag>
        <tag>数列极限应用</tag>
      </tags>
  </entry>
  <entry>
    <title>影音服务jellyfin安装与使用</title>
    <url>/2020/01/01/%E5%AE%B6%E5%BA%ADNAS%E3%80%81HTPC%E6%9C%8D%E5%8A%A1%E5%99%A8/9%E3%80%81%E5%BD%B1%E9%9F%B3%E6%9C%8D%E5%8A%A1jellyfin%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>关于的jellyfin影音服务，已经有很多人对其做过介绍了，但在这里我任然要为其写一篇相关安装与使用的文章，因为在别的贴子里，很多人容易忽视掉设置硬件加速的一些必要步骤。</p>
<p>本篇文章将会从本机安装以及docker安装两种安装方式来向大家介绍jellyfin的安装以及基本使用方法。</p>
<p>注意：你应该在看完文章后再决定你选用的安装方式</p>
<p>就这样，请拥有，并享受</p>
<h1 id="jellyfin介绍"><a href="#jellyfin介绍" class="headerlink" title="jellyfin介绍"></a>jellyfin介绍</h1><p>jellyfin是一个免费的媒体系统软件，可以让你控制媒体的管理和流式传输，是emby和plex的替代产品，可以通过多个应用程序将媒体从专用服务器提供给最终用户设备。Jellyfin是Emby 3.5.2发行版的衍生版本，并移植到.NET Core框架以实现全面的跨平台支持。</p>
<p>jellyfin目前支持的平台有：Android、Android TV、Amazon Fire TV、UWP、 Apple iOS（目前正在测试阶段）等等平台，你可以参见<a href="http://jellyfin.org/docs/general/clients/index.html" target="_blank" rel="noopener">jellyfin支持平台</a>获得更多的信息。</p>
<h1 id="查看是设备是否支持硬件加速"><a href="#查看是设备是否支持硬件加速" class="headerlink" title="查看是设备是否支持硬件加速"></a>查看是设备是否支持硬件加速</h1><p>Jellyfin支持使用<code>FFMpeg</code>的视频编码/解码的硬件加速。<code>FFMpeg</code>可通过视频加速<code>API（VAAPI）</code>支持多种硬件加速实现，例如<code>Intel Quicksync（QSV）</code>，<code>AMD AMF</code>，<code>OpenMax OMX</code>，<code>nVidia NVENC / NVDEC</code>等。<br>|操作系统|推荐的硬件加速|<br>|-|-|<br>|Linux / GNU|VAAPI（推荐），NVENC，QSV，AMF|<br>|Windows|QSV，NVENC，AMF，VAAPI|<br>|MacOS|None (videotoolbox support coming)|<br>|Android|MediaCodec, OMX|<br>|RPi|OMX|<br><a href="https://developer.nvidia.com/ffmpeg" target="_blank" rel="noopener">NVIDIA使用ffmpeg官方名单</a>，建议将这些<a href="https://github.com/keylase/nvidia-patch" target="_blank" rel="noopener">驱动程序</a>用于<code>Linux / GNU</code>和<code>Windows</code>。这是支持的编解码器的<a href="https://developer.nvidia.com/video-encode-decode-gpu-support-matrix" target="_blank" rel="noopener">NVIDIA图形卡</a>的官方列表。</p>
<p>VAAPI支持的编解码器列表：<a href="http://jellyfin.org/docs/general/administration/hardware-acceleration.html" target="_blank" rel="noopener">点击这里查看</a><br>支持QSV的Intel处理器列表。<a href="https://ark.intel.com/content/www/us/en/ark.html#@Processors" target="_blank" rel="noopener">点击这里查看</a><br>FFmpeg硬件加速支持列表。<a href="https://trac.ffmpeg.org/wiki/HWAccelIntro" target="_blank" rel="noopener">点击这里查看</a><br>Ubuntu使用NVENC的示例。<a href="https://www.reddit.com/r/jellyfin/comments/amuyba/nvenc_nvdec_working_in_jellyfin_on_ubuntu_server/" target="_blank" rel="noopener">点击这里查看</a></p>
<h2 id="启用硬件加速"><a href="#启用硬件加速" class="headerlink" title="启用硬件加速"></a>启用硬件加速</h2><p>硬件加速选项可在“管理仪表板”的“ 转码”部分下找到。从下拉菜单中选择有效的硬件加速选项，指示设备（如果适用），并检查enable hardware encoding以启用编码以及解码（如果您的硬件支持）。</p>
<p>硬件加速可立即用于媒体播放。无需重新启动服务器。</p>
<p>每种硬件加速类型以及每种Jellyfin安装类型在使用前都需要不同的设置选项。始终最好参考您选择的加速度类型的FFMpeg文档以获取最新信息。</p>
<h3 id="Debian-Ubuntu上配置VAAPI加速"><a href="#Debian-Ubuntu上配置VAAPI加速" class="headerlink" title="Debian / Ubuntu上配置VAAPI加速"></a>Debian / Ubuntu上配置VAAPI加速</h3><p>在Debian / Ubuntu上配置VAAPI需要进行一些其他配置，以确保权限正确。</p>
<ol>
<li>验证render设备现在在中/dev/dri，并记下可写入该设备的权限和组，在这种情况下render：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;dev&#x2F;dri</span><br></pre></td></tr></table></figure>
查看是否有如下输出：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 100 Apr 13 16:37 by-path</span><br><span class="line">crw-rw---- 1 root video 226, 0 Apr 13 16:37 card0</span><br><span class="line">crw-rw---- 1 root video 226, 1 Apr 13 16:37 card1</span><br><span class="line">crw-rw---- 1 root render 226, 128 Apr 13 16:37 renderD128</span><br></pre></td></tr></table></figure>
如果没有，在确保你的设备支持硬件加速的情况下通过<a href="http://jellyfin.org/docs/general/administration/hardware-acceleration.html" target="_blank" rel="noopener">指导文件</a>来进行相关设备的配置以及验证。不同的硬件平台配置方法不一样，在此不展开详述。</li>
</ol>
<ol>
<li>将Jellyfin服务用户添加到上述组中，以允许Jellyfin的FFMpeg进程访问该设备，然后重新启动Jellyfin：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG render jellyfin</span><br><span class="line">sudo systemctl restart jellyfin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：在这里执行完第一条语句后可能会出现报错，这是因为在某些发行版本中，该组可能为video而不是render，将其更改过来即可。<br>在看了很多相关文章后，发现大家都没有配置这一步，这可能导致硬件转码没有办法正常工作。</p>
<p>注意：以下两点请在安装完成jellyfin后在来看</p>
<ol>
<li><p>在管理控制台的“代码转换”页面中配置VAAPI加速。输入/dev/dri/renderD128上面的设备作为VA API Device值。</p>
</li>
<li><p>观看电影，并通过使用或类似工具观看ffmpeg-transcode-*.txt日志来验证是否正在进行转码。</p>
</li>
</ol>
<h1 id="Ubuntu安装jellyfin"><a href="#Ubuntu安装jellyfin" class="headerlink" title="Ubuntu安装jellyfin"></a>Ubuntu安装jellyfin</h1><p>文章存在时效性，具体可参考<a href="http://jellyfin.org/docs/general/administration/installing.html#ubuntu" target="_blank" rel="noopener">官方指南</a></p>
<h2 id="迁移至新仓库"><a href="#迁移至新仓库" class="headerlink" title="迁移至新仓库"></a>迁移至新仓库</h2><p>早期的jellyfin在ubuntu的官方<code>apt-get</code>源中，现在已将其拆分成自己的存储库，以更好地处理单独的二进制程序包。如果遇到ubuntu找不到该发行版的错误，并且以前配置了<code>ubuntu jellyfin.list</code>文件，请按照以下步骤操作。</p>
<ol>
<li>删除旧的<code>/etc/apt/sources.list.d/jellyfin.list</code>文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jellyfin.list</span><br></pre></td></tr></table></figure></li>
<li>按照下面的方法步骤继续操作</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Jellyfin团队提供了一个Ubuntu存储库，可以在<code>Ubuntu Xenial/Bionic/Cosmic/Disco</code>上进行安装。支持的架构<code>amd64、arm64</code>和<code>armhf</code>。<code>Ubuntu Xenial</code> 仅支持 <code>amd64</code>。</p>
<p>注意：Microsoft不为32位x86 Linux系统提供.NET，因此<code>i386</code>体系结构不支持Jellyfin 。</p>
<ol>
<li><p>如果尚未安装APT的HTTPS传输，请执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-transport-https</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用Universe存储库以获取所有FFMpeg依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入GPG签名密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - https:&#x2F;&#x2F;repo.jellyfin.org&#x2F;ubuntu&#x2F;jellyfin_team.gpg.key | sudo apt-key add -</span><br></pre></td></tr></table></figure>
</li>
<li><p>在以下位置添加存储库配置<code>/etc/apt/sources.list.d/jellyfin.list</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch&#x3D;$( dpkg --print-architecture )] https:&#x2F;&#x2F;repo.jellyfin.org&#x2F;ubuntu $( lsb_release -c -s ) main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jellyfin.list</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：支持的版本是：<code>xenial</code>，<code>bionic</code>，<code>cosmic</code>，和<code>disco</code>。</p>
<ol>
<li>更新APT存储库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装Jellyfin：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install jellyfin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用您选择的工具管理Jellyfin系统服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart jellyfin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Docker安装jellyfin"><a href="#Docker安装jellyfin" class="headerlink" title="Docker安装jellyfin"></a>Docker安装jellyfin</h1><p>你可以到<a href="https://registry.hub.docker.com/r/jellyfin/jellyfin" target="_blank" rel="noopener">jellyfin官方docker hub</a>查看该项目的最新动态以及获得相关支持。</p>
<ol>
<li>获取docker镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull jellyfin&#x2F;jellyfin</span><br></pre></td></tr></table></figure></li>
<li>运行jellyfin<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8096:8096 \</span><br><span class="line">--name jellyfin \</span><br><span class="line">--restart always \</span><br><span class="line">-v 配置文件路径:&#x2F;config \</span><br><span class="line">-v 缓存文件路径:&#x2F;cache \</span><br><span class="line">-v 媒体路径1:&#x2F;media \</span><br><span class="line">-v 媒体路径2:&#x2F;media \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;renderD128:&#x2F;dev&#x2F;dri&#x2F;renderD128 \</span><br><span class="line">--device &#x2F;dev&#x2F;dri&#x2F;card0:&#x2F;dev&#x2F;dri&#x2F;card0 \</span><br><span class="line">--privileged&#x3D;true \</span><br><span class="line">--env GIDLIST&#x3D;44 \</span><br><span class="line">jellyfin&#x2F;jellyfin:latest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此，jellyfin的安装工作就算完成了。接下来进行相关的配置工作。</p>
<h1 id="jellyfin配置与使用"><a href="#jellyfin配置与使用" class="headerlink" title="jellyfin配置与使用"></a>jellyfin配置与使用</h1><h2 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h2><p>在浏览器中输入<code>服务器IP:8096</code>即可进入到jellyfin的web端。</p>
<ol>
<li><p>选择语言<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174755.jpg" alt="选择语言"></p>
</li>
<li><p>用户设置<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174819.jpg" alt="添加用户"></p>
</li>
<li><p>设置媒体库<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174832.jpg" alt="媒体库设置"></p>
</li>
<li><p>选择地区与语言<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174851.jpg" alt="选择地区与语言"></p>
</li>
<li><p>远程访问（默认即可）<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174902.jpg" alt="远程访问权限"></p>
</li>
<li><p>完成配置<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174912.jpg" alt="完成配置"></p>
</li>
<li><p>登录<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174925.jpg" alt="用户登录"></p>
</li>
<li><p>进入界面<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20174936.jpg" alt="主页面"></p>
</li>
</ol>
<h2 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h2><p>点击右上角小人，进入如下界面</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20181402.jpg" alt="个人设置"></p>
<p>选择显示菜单</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20181423.jpg" alt="显示配置"></p>
<p>这里选择自己喜欢的主题可以进行配置在上个页面中你也可以进行更多配置</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>选择左上角的<strong>三横图标</strong> —&gt; <strong>控制台</strong> —&gt; <strong>往下找到插件</strong> 来到下图所示的界面<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20182002.jpg" alt="插件"></p>
<p>我这里以及安装了很多插件了，如果你没有安装过，这里将显示空白。点击上方的目录可进入到插件目录</p>
<h3 id="字幕插件"><a href="#字幕插件" class="headerlink" title="字幕插件"></a>字幕插件</h3><p>在元素据中找到Open Subtitles，进去点击安装</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20182159.jpg" alt="字幕插件"></p>
<p>然后回到我的插件，点开Open Subtitles进入配置页面</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20182318.jpg" alt="Open Subtitles配置"><br>输入用户名密码登录，没有的话可以到<a href="http://www.opensubtitles.org/" target="_blank" rel="noopener">opensubtitles官网</a>进行注册。</p>
<h3 id="KODI串流"><a href="#KODI串流" class="headerlink" title="KODI串流"></a>KODI串流</h3><p>在插件目录的常规栏目找到Kodi Sync Queue进行安装<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20182711.jpg" alt="KODI"></p>
<p>然后回到我的插件，进入KODI配置，全勾选上即可<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20182644.jpg" alt="KODI"></p>
<p>关于kodi的使用将在后期文章中进行介绍</p>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>其他插件可以根据自己的需要进行安装，可以参考其他同类文章，在此不进行详述。</p>
<h2 id="添加媒体库"><a href="#添加媒体库" class="headerlink" title="添加媒体库"></a>添加媒体库</h2><p>在控制台中进入到媒体库，可以看到添加媒体库的按钮，如下图<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20183340.jpg" alt="媒体库管理"><br>然后点击添加媒体库<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20183444.jpg" alt="添加媒体库"><br>选择对应的类型与名称，在文件夹处选择刚才对应的媒体库，docker安装的话媒体目录被映射到/media目录下。</p>
<p>点击左上角的显示高级设置<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20183808.jpg" alt="设置"></p>
<p>把除了上图没勾选的之外的全面勾选上。然后确认。之后会自动扫描和下载字幕，该过程有些漫长。<br>然后在主页就可以看到添加的媒体了<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20184026.jpg" alt="媒体"></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20184239.jpg" alt="电影"></p>
<p>对于某些电影，会识别失败，这时我们需要手动识别，进入电影详情页面。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20184406.jpg" alt="电影详情"></p>
<p>然后点击播放 预告片后面的更多<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20184517.jpg" alt="更多"><br>然后选择对应的菜单进入操作即可。</p>
<h1 id="jellyfin播放设置"><a href="#jellyfin播放设置" class="headerlink" title="jellyfin播放设置"></a>jellyfin播放设置</h1><h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>硬件播放可以到控制台 —&gt; 播放进行设置<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20202112.jpg" alt="硬件加速"></p>
<p>可以参考上面的平台推荐加速器进行相关设置，我这里设置为VAAPI<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20202312.jpg" alt="加速方式"></p>
<p>VAAPI选择对应的硬件设备，确保你已依照上面的过程进行了相关的驱动设置。<br><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20202427.jpg" alt="加速设备"></p>
<p>其他参数可依照说明按需进行更改</p>
<h2 id="流媒体传输设置"><a href="#流媒体传输设置" class="headerlink" title="流媒体传输设置"></a>流媒体传输设置</h2><p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/%E6%89%B9%E6%B3%A8%202019-12-31%20202647.jpg" alt="流媒体传输设置"><br>可依据自己的网络情况进行传输设置，这对于防止设备请求比 internet 连接所能处理的更高的比特率非常有用。这可能会导致服务器上的 CPU 负载增加, 以便将视频转码到较低的比特率。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本来想在一篇文章中对jellyfin做个详细的说明，但是发现那样文章就显得太过于长了。<br>下篇文章将对jellyfin的其他使用技巧做一个介绍，比如电影命名规范，格式选择等。<br>除此之外还会对jellyfin的使用过程中遇到的一些问题进行介绍，以及如何获取解决方案。</p>
]]></content>
      <categories>
        <category>家庭NAS、HTPC服务器</category>
      </categories>
      <tags>
        <tag>NAS系统</tag>
        <tag>家庭影音</tag>
        <tag>HTPC服务器</tag>
        <tag>jellyfin</tag>
        <tag>影音服务</tag>
      </tags>
  </entry>
  <entry>
    <title>2.矩阵与线性方程组</title>
    <url>/2020/07/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/2-%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<h1 id="矩阵-matrix-与向量的乘积"><a href="#矩阵-matrix-与向量的乘积" class="headerlink" title="矩阵(matrix)与向量的乘积"></a>矩阵(matrix)与向量的乘积</h1><p>例，我们有如下的线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&x_{1}&+x_{2}&-x_{3} &=1 \\
&2 x_{1}& &+x_{3}&=3 \\
&&2 x_{2}&+x_{3} &=3
\end{aligned}\right.</script><a id="more"></a>
<p>我们将$x{_1}$的系数向量$\left(\begin{array}{l}1 \\ 2 \\ 0\end{array}\right)$，$x{_2}$的系数向量$\left(\begin{array}{l}1 \\ 0 \\ 2\end{array}\right)$以及$x_3$的系数向量$\left(\begin{array}{c}-1 \\ 1 \\ 1\end{array}\right)$分别提取出来，上面的线性方程组我们就可以表示为常数向量$\left(\begin{array}{l}<br>1 \\<br>3 \\<br>3<br>\end{array}\right)$与$x_1$、$x_2$与$x_3$的线性组合，如下所示：</p>
<script type="math/tex; mode=display">
x_{1}\left(\begin{array}{l}
1 \\
2 \\
0
\end{array}\right)+x_{2}\left(\begin{array}{l}
1 \\
0 \\
2
\end{array}\right)+x_{3}\left(\begin{array}{c}
-1 \\
1 \\
1
\end{array}\right)=\left(\begin{array}{l}
1 \\
3 \\
3
\end{array}\right)</script><p>我们将$x{_1}$的系数向量$\left(\begin{array}{l}1 \\ 2 \\ 0\end{array}\right)$记作$\mathbf{u}$，$x{_2}$的系数向量$\left(\begin{array}{l}1 \\ 0 \\ 2\end{array}\right)$记作$\mathbf{v}$，$x_3$的系数向量$\left(\begin{array}{c}-1 \\ 1 \\ 1\end{array}\right)$记作$\mathbf{w}$，将$\mathbf{u}, \mathbf{v}, \mathbf{w}$组成一个矩阵$\mathbf{A}$，$x_1、x_2、x_3$组成一个列向量$\mathbf{X}$，上面的公式可表示如下：</p>
<script type="math/tex; mode=display">
\underbrace{\left(\begin{array}{ccc}
1 & 1 & -1 \\
2 & 0 & 1 \\
0 & 2 & 1
\end{array}\right)}_{A} \underbrace{\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right)}_{\mathbf{x}}=\left(\begin{array}{l}
1 \\
3 \\
3
\end{array}\right)</script><p>这里$A=(\mathbf{u}, \mathbf{v}, \mathbf{w})$，我们还可以将上述表达式改写为如下形式：</p>
<script type="math/tex; mode=display">
A \mathbf{x}=(\mathbf{u}, \mathbf{v}, \mathbf{w})\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right)=x_{1} \mathbf{u}+x_{2} \mathbf{v}+x_{3} \mathbf{w}</script><p>即矩阵$\mathbf{A}$与向量 $\mathbf{X}$ 的乘积等于矩阵的列向量的线性组合，这是矩阵乘积的一种表达方式。</p>
<p>另外，上述方程组$\left\{\begin{aligned}<br>&amp;x_{1}&amp;+x_{2}&amp;-x_{3} &amp;=1 \\<br>&amp;2 x_{1}&amp; &amp;+x_{3}&amp;=3 \\<br>&amp;&amp;2 x_{2}&amp;+x_{3} &amp;=3<br>\end{aligned}\right.$</p>
<p>也可表示为：$\left\{\begin{array}{llll}(1, &amp; 1, &amp; -1) &amp; \cdot&amp;\left(x_{1}, x_{2}, x_{3}\right) &amp; =1 \\ (2, &amp; 0, &amp; 1) &amp; \cdot &amp; \left(x_{1}, x_{2}, x_{3}\right) &amp; =3 \\ (0, &amp; 2, &amp; 1) &amp; \cdot &amp; \left(x_{1}, x_{2}, x_{3}\right) &amp; =3\end{array}\right.$</p>
<p>这也就诱导了矩阵的另一种定义方式，设$A=\left(a_{i j}\right)_{3 \times 3}, \mathbf{x}=\left(x_{1}, x_{2}, x_{3}\right)$，则有：</p>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{x}=\left(\begin{array}{c}
\left(a_{11}, a_{12}, a_{13}\right) \cdot\left(x_{1}, x_{2}, x_{3}\right) \\
\left(a_{21}, a_{22}, a_{23}\right) \cdot\left(x_{1}, x_{2}, x_{3}\right) \\
\left(a_{31}, a_{32}, a_{33}\right) \cdot\left(x_{1}, x_{2}, x_{3}\right)
\end{array}\right)</script><p>通过上述两种$\mathbf{A} \mathbf{x}$的定义，我们对线性方程组可有两种理解，对于</p>
<script type="math/tex; mode=display">
\left(\begin{array}{ccc}
1 & 1 & -1 \\
2 & 0 & 1 \\
0 & 2 & 1
\end{array}\right)\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right)=\left(\begin{array}{l}
1 \\
3 \\
3
\end{array}\right)</script><p>这样一个线性组合，</p>
<p>理解一，求向量$\left(\begin{array}{l}1 \\ 2 \\ 0\end{array}\right),\left(\begin{array}{l}1 \\ 0 \\ 2\end{array}\right),\left(\begin{array}{c}-1 \\ 1 \\ 1\end{array}\right)$的线性组合，使之等于$\left(\begin{array}{l}1 \\ 3 \\ 3\end{array}\right)$</p>
<p>理解二，求向量$\left(\begin{array}{l}x_{1} \\ x_{2} \\ x_{3}\end{array}\right)$，使之与系数矩阵行向量$\left(\begin{array}{c}1 \\ 1 \\ -1\end{array}\right),\left(\begin{array}{l}2 \\ 0 \\ 1\end{array}\right),\left(\begin{array}{l}0 \\ 2 \\ 1\end{array}\right)$的点积分别为1，3，3</p>
<p>例子：将平面上所有向量绕原点$O$旋转角度$\theta$，则点$P(x, y)$在此旋转变换下得像$P^{\prime}\left(x^{\prime}, y^{\prime}\right)$为</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200711233515324.png" alt="例题图"></p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
x^{\prime}=x \cos \theta-y \sin \theta \\
y^{\prime}=x \sin \theta+y \cos \theta
\end{array}\right.</script><p>这可表示为：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right)=\left(\begin{array}{cc}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{array}\right)\left(\begin{array}{l}
x \\
y
\end{array}\right)</script><h1 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h1><p>线性方程组$Ax=b$的解的情况比数量方程$a x=b(a, b \in \mathbb{R})$要复杂。</p>
<p>若$Ax=b$对任意向量$\mathbf{b}$有唯一解，则称$A$是可逆的(invertible)。</p>
<p>例：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{rl}
&x_{1}&& & =b_{1} \\
-&x_{1}&+x_{2}& & =b_{2} \\
&&-x_{2}&+x_{3} & =b_{3}
\end{array} \Longleftrightarrow\left(\begin{array}{ccc}
1 & 0 & 0 \\
-1 & 1 & 0 \\
0 & -1 & 1
\end{array}\right)\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right)=\left(\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right)\right.</script><p>任意给定$b_1、b_2、b_3$，方程组有唯一解$\left\{\begin{aligned} x_{1} &amp;=b_{1} \\ x_{2} &amp;=b_{1}+b_{2} \\ x_{3} &amp;=b_{1}+b_{2}+b_{3} \end{aligned}\right.$，故系数矩阵$\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ -1 &amp; 1 &amp; 0 \\ 0 &amp; -1 &amp; 1\end{array}\right)$是可逆的。</p>
<p>对线性方程组$Ax=b$，若$A$可逆，则可有常数项$b$求得$x$。</p>
<p>若有：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
x_{1} &=b_{1} \\
x_{2} &=b_{1}+b_{2} \\
x_{3} &=b_{1}+b_{2}+b_{3}
\end{aligned}\right.
\Longleftrightarrow\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right)=\underbrace{\left(\begin{array}{lll}
1 & 0 & 0 \\
1 & 1 & 0 \\
1 & 1 & 1
\end{array}\right)}_{S}\left(\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right)</script><p>则称矩阵$S$为$A$得逆。</p>
<p>设$\mathbf{u}=\left(\begin{array}{l}u_{1} \\ u_{2} \\ u_{3}\end{array}\right), \mathbf{v}=\left(\begin{array}{l}v_{1} \\ v_{2} \\ v_{3}\end{array}\right), \mathbf{w}=\left(\begin{array}{l}w_{1} \\ w_{2} \\ w_{3}\end{array}\right)$，若$A=(\mathbf{u}, \mathbf{v}, \mathbf{w})$可逆，则$\mathbf{u}, \mathbf{v}, \mathbf{w}$的全部线性组合为整个3维空间。</p>
<p>此时$\mathbf{0}$写成$\mathbf{u}, \mathbf{v}, \mathbf{w}$的线性组合只有一种可能：</p>
<script type="math/tex; mode=display">
\mathbf{0}=0 \mathbf{u}+0 \mathbf{v}+0 \mathbf{w}</script><p>这时我们称$\mathbf{u}, \mathbf{v}, \mathbf{w}$线性无关(linearly independent)，相应的$Ax=b$只有零解。</p>
<p>否则$\mathbf{0}$写成$\mathbf{u}, \mathbf{v}, \mathbf{w}$的多种线性组合。如：</p>
<script type="math/tex; mode=display">
\mathbf{u}=\left(\begin{array}{l}
1 \\
0 \\
0
\end{array}\right), \mathbf{v}=\left(\begin{array}{l}
0 \\
1 \\
0
\end{array}\right), \mathbf{w}=\left(\begin{array}{l}
1 \\
1 \\
0
\end{array}\right)</script>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title>1、向量及其运算</title>
    <url>/2020/06/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/1%E3%80%81%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>线性代数的中心问题是求解线性方程组。</p>
<p>假设给定一个线性方程组：</p>
<script type="math/tex; mode=display">
x_1+2x_2=4 \\
2x_1-3x_2=-2</script><a id="more"></a>
<p>我们将$x_1$、$x_2$的系数以及结果单独提取出来，它能表示为：</p>
<script type="math/tex; mode=display">
x_1\binom{1}{2}+x_2\binom{2}{-3}=\binom{4}{-2}</script><p>由此可得此方程可解$\Longleftrightarrow$$\binom{4}{-2}$可表示为$\binom{1}{2}$和$\binom{2}{-3}$的线性组合。</p>
<p>线性代数是建立在向量的加法和数乘这两种所谓<strong>线性运算</strong>上的.</p>
<h1 id="n-维空间中的点"><a href="#n-维空间中的点" class="headerlink" title="$n$维空间中的点"></a>$n$维空间中的点</h1><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>在一条直线上取定坐标原点后，每个实数一一对应表示直线上的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601225945203.png" alt="image-20200601225945203"></p>
<p>一个二元的有序数组$(x_1,x_2)$一一对应表示平面上的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601230654410.png" alt="image-20200601230654410"></p>
<p>一个三维有序数组$(x_1,x_2,x_3)$一一对应表示三维空间中的一个点。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200601231634293.png" alt="三维空间中的点"></p>
<p>同理，定义$n$维空间的点为一个$n$元有序数组$x=(x_1,\dots,x_n)$，称$x_i$为点$x$的第$i$个坐标.</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p><strong>相等</strong></p>
<p>对于$n$维空间的两个点$x=(x_1,\dots,x_n)$与$y=(y_1,\dots,y_n)$，若</p>
<script type="math/tex; mode=display">
x_i=y_i, \forall1\leq i \leq n.</script><p>则称$x$与$y$相等。</p>
</li>
</ol>
<ol>
<li><p><strong>相加</strong></p>
<p>对于$n$维空间的两个点$x=(x_1,\dots,x_n)$与$y=(y_1,\dots,y_n)$，其<strong>加法</strong>规则为：</p>
<script type="math/tex; mode=display">
x+y:=(x_1+y_1,\dots,x_n+y_n)</script></li>
<li><p><strong>数乘运算</strong></p>
<p>对于$n$维空间的点$x=(x_1,\dots,x_n)$，以及$c\in R$其<strong>数乘运算</strong>规则为：</p>
<script type="math/tex; mode=display">
cx:=(cx_1,\dots,cx_n)</script></li>
</ol>
<p>这样定义的加法及数乘运算对于任意$n$维空间中的点$x,y,z$满足以下8条性质:</p>
<ol>
<li>$(x+y)+z=x+(y+z)$</li>
<li>$x+y=y+x$</li>
<li>若令$0=(0,\dots,0)$为一个点，则$0+x=x+0=x$</li>
<li>若以$-x$表示$(-1)x$，则$x+(-x)=0$</li>
<li>$1·x=x$</li>
<li>$(c_1·c_2)x=c_1(c_2x)$</li>
<li>$(c_1+c_2)x=c_1x+c_2x$</li>
<li>$c(x+y)=cx+xy$</li>
</ol>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>向量指空间中具有一定<strong>长度</strong>及<strong>方向</strong>的直线段。通常记起点为$A$，终点为$B$的向量为$\overrightarrow{AB}$。</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602000139541.png" alt="image-20200602000139541"></p>
<p>力、位移、速度、加速度等都是物理学中常出现的向量.</p>
<p><strong>两个向量相等$\Longleftrightarrow$二者长度相等，方向相同。</strong></p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602000520092.png" alt="image-20200602000520092"></p>
<h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><h3 id="向量的加法-addition"><a href="#向量的加法-addition" class="headerlink" title="向量的加法(addition):"></a>向量的加法(addition):</h3><p>对于两个向量$\vec{a}=\overrightarrow{OA}$以及$b=\overrightarrow{OB}$，$\vec{a}+\vec{b}$的和为以向量$\vec{a}，\vec{b}$为邻边的平行四边形的对角线$\overrightarrow{OC}$代表的向量（平行四边形法则）。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602001500849.png" alt="image-20200602001500849"></p>
<p>向量的加法又满足三角形法则：</p>
<script type="math/tex; mode=display">
\overrightarrow{OA}+\overrightarrow{AC}=\overrightarrow{OC}</script><h3 id="向量的数乘-scalar-multiplication-："><a href="#向量的数乘-scalar-multiplication-：" class="headerlink" title="向量的数乘(scalar multiplication)："></a>向量的数乘(scalar multiplication)：</h3><p>向量的数乘即向量的方向不变，大小变为原来的$c(c\in R)$倍。如下图所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602090359154.png" alt="image-20200602090359154"></p>
<h3 id="向量的性质"><a href="#向量的性质" class="headerlink" title="向量的性质"></a>向量的性质</h3><ol>
<li><p>向量的加法满足结合律，即对于任意的向量$\vec{a},\vec{b},\vec{c}$</p>
<script type="math/tex; mode=display">
\vec{a}+(\vec{b}+\vec{c})=(\vec{a}+\vec{b})+\vec{c}</script></li>
<li><p>向量的加法满足交换律，即对于任意的向量$\vec{a},\vec{b}$</p>
<script type="math/tex; mode=display">
\vec{a}+\vec{b}=\vec{b}+\vec{a}</script></li>
<li><p>当$A=B$时，称向量$\overrightarrow{AB}$为零向量，记作$\vec{0}$，则</p>
<script type="math/tex; mode=display">
\overrightarrow{AA}+\overrightarrow{AB}=\overrightarrow{AB}可表示为0+\vec{a}=\vec{a}对于任意向量\vec{a}成立</script></li>
<li><p>对向量$a=\overrightarrow{AB}$，记向量$\overrightarrow{BA}=-a$，则$\overrightarrow{AB}+\overrightarrow{BA}=\overrightarrow{AA}$，即</p>
<script type="math/tex; mode=display">
\vec{a}+(-\vec{a})=0,\forall \vec{a}</script></li>
<li><p>$1·\vec{a}=\vec{a}$</p>
</li>
<li><p>$(c_1·c_2)\vec{a}=c_1(c_2)\vec{a}$</p>
</li>
<li><p>$(c_1+c_2)\vec{a}=c_1\vec{a}+c_2\vec{a}$</p>
</li>
<li><p>$c(\vec{a}+\vec{b})=c\vec{a}+c\vec{b}$</p>
</li>
</ol>
<h2 id="向量的表示"><a href="#向量的表示" class="headerlink" title="向量的表示"></a>向量的表示</h2><p>如果固定向量的起点，如记之为原点，则向量由其终点唯一确定，于是我们可以等同：</p>
<ol>
<li>$n$维空间中的点</li>
<li>$n$元有序数组</li>
<li>$n$维空间中由原点出发的向量</li>
</ol>
<p>我们将不加区分地使用向量的这三个身份。</p>
<p>记$\vec{a}=\begin{pmatrix}a_1\\\vdots \\a_n \end{pmatrix}$为列向量，其中$a_i$为向量$\vec{a}$的第$i$个分量。</p>
<p>则有向量的加法：</p>
<script type="math/tex; mode=display">
\vec{a}+\vec{b}:=\begin{pmatrix}a_1+b_1 \\\vdots \\a_n+b_n\end{pmatrix}.</script><p>数乘：</p>
<script type="math/tex; mode=display">
c\vec{a}:=\begin{pmatrix}c\vec{a_1} \\\vdots \\c\vec{a_n}\end{pmatrix}.</script><h1 id="向量的空间定义"><a href="#向量的空间定义" class="headerlink" title="向量的空间定义"></a>向量的空间定义</h1><p>在由称为”向量“的元素构成的非空集合$V$中，若定义了加法和数乘运算，且对任意向量$\vec{a},\vec{b},\vec{c}$及数$k,l\in F$满足以下8条性质：</p>
<ol>
<li>$\vec{a}+(\vec{b}+\vec{c})=(\vec{a}+\vec{b})+\vec{c}$</li>
<li>$\vec{a}+\vec{b}=\vec{b}+\vec{a}$</li>
<li>存在$\vec{0}$，$\vec{a}+\vec{0}=\vec{a}$</li>
<li>对于任意向量$\vec{a}$，存在唯一相反向量$-\vec{a}$，使得$\vec{a}+(-\vec{a})=\vec{0}$</li>
<li>$1·\vec{a}=\vec{a}$</li>
<li>$(kl)\vec{a}=k(l\vec{a})$</li>
<li>$k(\vec{a}+\vec{b})=k\vec{a}+k\vec{b}$</li>
<li>$(k+l)\vec{a}=k\vec{a}+l\vec{a}$</li>
</ol>
<p>则称$V$为定义在数域$F$上的向量空间(vector space).</p>
<h1 id="向量的线性组合"><a href="#向量的线性组合" class="headerlink" title="向量的线性组合"></a>向量的线性组合</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>设$\vec{v_1},\cdots,\vec{v_m}$为$m$个$n$维向量，$c_1,\cdots,c_m \in R$，则称$c_1v_1,\cdots,c_mv_m$为向量$\vec{v_1},\cdots,\vec{v_m}$的一个线性组合。</p>
<p>例：给定$\vec{i}=\begin{pmatrix}1 \\0 \\0\end{pmatrix}\vec{j}=\begin{pmatrix}0 \\1 \\0\end{pmatrix},\vec{k}=\begin{pmatrix}0 \\0 \\1\end{pmatrix}$，</p>
<p>则$\vec{u}=\begin{pmatrix}1 \-1 \\1\end{pmatrix}=\vec{i}-\vec{j}+\vec{k}$是向量$\vec{i},\vec{j},\vec{k}$的一个线性组合。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>Q：给定一组向量$\vec{v_1},\cdots,\vec{v_m}$，则$\vec{v_1},\cdots,\vec{v_m}$的全部线性组合是怎样的集合？</p>
<p>例1：向量$\vec{u}=\begin{pmatrix}1 \\1 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}|c\in R\right\}$为以$\vec{u}$为方向的一条直线。</p>
<p>例2：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$和$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$的全部线性组合为$c\vec{u}+d\vec{v}=\begin{pmatrix}c \\c+d \\d\end{pmatrix}$，其中$c,d$为任意实数，这是平面$x-y+z=0$。</p>
<p>例3：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$和$\vec{v}=\begin{pmatrix}\sqrt{2} \\\sqrt{2} \\0\end{pmatrix}$的全部线性组合为$c\vec{u}+d\vec{v}=\begin{pmatrix}c+\sqrt{2}d \\c+\sqrt{2}d\\0\end{pmatrix}$，其中$c,d$为任意实数，这是直线$\left\{\begin{aligned}x = y \\z = 0\end{aligned}\right.$</p>
<p>例4：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$，$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$，$\vec{w}=\begin{pmatrix}1 \\0 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}+d\vec{v}+e\vec{w}|c,d,e \in R\right\}$为整个三维空间.</p>
<p>这是因为，任意三维向量$\begin{pmatrix}x \\y \\z\end{pmatrix}$都可以表示为$\vec{u},\vec{v},\vec{w}$的下列线性组合：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}x \\y \\z\end{pmatrix}=\frac{x+y-z}{2}\vec{u}+\frac{y+z-x}{2}\vec{v}+\frac{z+x-y}{2}\vec{w}.</script><p>例5：向量$\vec{u}=\begin{pmatrix}1 \\1 \\0\end{pmatrix}$，$\vec{v}=\begin{pmatrix}0 \\1 \\1\end{pmatrix}$，$\vec{w}=\begin{pmatrix}1 \\2 \\1\end{pmatrix}$的全部线性组合$\left\{c\vec{u}+d\vec{v}+e\vec{w}=(c+e)\vec{u}+(d+e)\vec{v}|c,d,e \in R\right\}$为向量$\vec{u},\vec{w}$张成的平面$x-y+z=0$，这是因为$\vec{w}=\vec{u}|\vec{v}$在$\vec{u},\vec{v}$所张成的这张平面上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在3维空间中， 一般而言，向量$\vec{u},\vec{u}和\vec{v},或\vec{u}、\vec{v}和\vec{w}$的所有线性组合分别是一条直线、一张平面或整个3维空间。</p>
<h1 id="向量的点积、长度"><a href="#向量的点积、长度" class="headerlink" title="向量的点积、长度"></a>向量的点积、长度</h1><h2 id="向量长度"><a href="#向量长度" class="headerlink" title="向量长度"></a>向量长度</h2><p>向量$\vec{v}$的长度(length)或模(norm)定义为</p>
<script type="math/tex; mode=display">
|\vec{v}|=\sqrt{\vec{v}·\vec{v}}</script><p>若$\vec{v}=(v_1,\cdots,v_n)$，则$|\vec{v}|=\sqrt{v_1^2+\cdots+v_n^2}$。</p>
<p>例：$\vec{v}=(1，2，3)$，则$|\vec{v}|=\sqrt{1+4+9}=\sqrt{14}$。</p>
<h2 id="向量点积"><a href="#向量点积" class="headerlink" title="向量点积"></a>向量点积</h2><p>定义：若$|\vec{v}|=1$，则称$\vec{v}$为单位向量(unit vector)。</p>
<p>单位化：任给一非零向量$\vec{v}$，则$\frac{\vec{v}}{|\vec{v}|}$是沿$\vec{v}$方向的单位向量。</p>
<p>例1：$\vec{v}=(\cos\theta,\sin\theta)$，则$|\vec{v}|=1$。</p>
<p>例2：$\vec{v}=(1，2，3)$，则沿$\vec{v}$方向的单位向量为$\frac{\vec{v}}{|\vec{v}|}=\frac{1}{\sqrt{14}}(1,2,3)$.</p>
<p>向量点积的性质：</p>
<ol>
<li>$\vec{v}\cdot\vec{w}=\vec{w}\cdot\vec{v}$（对称性）</li>
<li>$\vec{u}\cdot(c\vec{v}+d\vec{w})=c\vec{u}\cdot\vec{v}+d\vec{u}\cdot\vec{w}$（线性性）</li>
<li>$\vec{v}\cdot\vec{v}=|\vec{v}|^2\ge0$，且等号成立当且仅当$\vec{v}=0$（正定性）</li>
</ol>
<h1 id="向量的夹角"><a href="#向量的夹角" class="headerlink" title="向量的夹角"></a>向量的夹角</h1><h2 id="向量垂直"><a href="#向量垂直" class="headerlink" title="向量垂直"></a>向量垂直</h2><p>若$\vec{v}\cdot\vec{w}=0$，则称向量$\vec{v}$和$\vec{w}$垂直(perpendicular)(或者称为正交(orthogonal))。记作$\vec{v}\perp\vec{w}$或$\vec{w}\perp\vec{v}$。</p>
<p>在此规定，$\vec{0}$和任意向量垂直。</p>
<p>这样定义的垂直的概念与几何直观是一致的，即</p>
<script type="math/tex; mode=display">
\vec{v}\perp\vec{w}\Longleftrightarrow\vec{v}\cdot\vec{w}=0</script><p>证明：设$\vec{v}\perp\vec{w}$，则$\vec{v},\vec{w},\vec{v}-\vec{w}$构成直角三角形的三条边，如下如所示：</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602144024402.png" alt="image-20200602144024402"></p>
<p>于是由勾股定理可得：$|\vec{v}-\vec{w}|^2=|\vec{v}|^2+|\vec{w}|^2$，将式子左边展开得：</p>
<script type="math/tex; mode=display">
|\vec{v}-\vec{w}|^2=(\vec{v}-\vec{w})\cdot(\vec{v}-\vec{w})=|\vec{v}|^2-\vec{v}\cdot\vec{w}-\vec{w}\cdot\vec{v}+|\vec{w}|^2</script><p>故得 $\vec{v}\cdot\vec{w}=0$，反之亦然。</p>
<h2 id="向量的夹角-1"><a href="#向量的夹角-1" class="headerlink" title="向量的夹角"></a>向量的夹角</h2><p>命题：两非零向量$\vec{v},\vec{w}$的夹角$\theta$满足$\cos\theta=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}$。</p>
<p>证明：一般的，向量$\vec{v},\vec{w},\vec{v}-\vec{w}$构成三角形的三条边，由<strong>余弦定理</strong>得</p>
<script type="math/tex; mode=display">
|\vec{v}-\vec{w}|^2=|\vec{v}|^2+|\vec{w}|^2-2|\vec{v}||\vec{w}|\cos\theta</script><p>故有：</p>
<script type="math/tex; mode=display">
\cos\theta=\frac{|\vec{v}|^2+|\vec{w}|^2-|\vec{v}-\vec{w}|^2}{2|\vec{v}||\vec{w}|}=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}</script><ul>
<li>若$\vec{v}\cdot\vec{w}&gt;0$，则$\cos\theta&gt;0$，取$0\leq\theta\leq\frac{\pi}{2}$</li>
<li>若$\vec{v}\cdot\vec{w}&lt;0$，则$\cos\theta&lt;0$，取$\frac{\pi}{2}\leq\theta\leq\pi$</li>
</ul>
<p>例题：$\vec{v}=(1,1),\vec{w}=(-1,0)$，则$\cos\theta=\frac{\vec{v}\cdot\vec{w}}{|\vec{v}||\vec{w}|}=-\frac{1}{\sqrt{2}}$，则$\vec{v},\vec{w}$夹角$\theta=\frac{3}{4}\pi$</p>
<h1 id="两个不等式"><a href="#两个不等式" class="headerlink" title="两个不等式"></a>两个不等式</h1><h2 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h2><p>Cauchy-Schwarz不等式首先由法国数学家Augustin-LouisCauchy(1789-1857)于1821年发现,再由俄国数学家Viktor YakovychBunyakovsky(1804-1889)于1859年重新发现, 后由德国数学家HermanSchwarz(1843-1921)于1886年再次重新发现.</p>
<p><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/image-20200602151346208.png" alt="image-20200602151346208"></p>
<p>该不等式为：</p>
<script type="math/tex; mode=display">
|\vec{v}\cdot\vec{w}|\leq|\vec{v}||\vec{w}|</script><p>等号成立当且仅当一个向量是另一个向量得倍数。</p>
<h2 id="三角不等式-Triangle-inequality"><a href="#三角不等式-Triangle-inequality" class="headerlink" title="三角不等式(Triangle inequality)"></a>三角不等式(Triangle inequality)</h2><script type="math/tex; mode=display">
|\vec{v}+\vec{w}|\leq|\vec{v}|+|\vec{w}|</script><p>等号成立当且仅当$\vec{v},\vec{w}$之一为另一向量得非负倍数</p>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
|\vec{v}+\vec{w}|&=(\vec{v}+\vec{w})\cdot(\vec{v}+\vec{w})=|\vec{v}|^2+2\vec{v}\cdot\vec{w}+|\vec{w}|^2 \\
&\leq|\vec{v}|^2+|\vec{w}|^2+2|\vec{v}\cdot\vec{w}| \\
&\leq|\vec{v}|^2+|\vec{w}|^2+2|\vec{v}|\cdot|\vec{w}| \\
&=(|\vec{v}|+|\vec{w}|)^2
\end{aligned}</script><p>等号成立当且仅当$\vec{v}\cdot\vec{w}=|\vec{v}|\cdot|\vec{w}|$，这等价于$\vec{v},\vec{w}$之一为另一个向量得非负倍数。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><p>设$\vec{v}=(a,b),\vec{w}=(b,a)$,则由Cauchy-Schwarz不等式得</p>
<script type="math/tex; mode=display">
\vec{v}\cdot\vec{w}=2ab\leq a^2+b^2=|\vec{v}||\vec{w}|</script><p>若令$x=a^2,y=b^2$，则得到<strong>几何平均不大于算术平均</strong>：</p>
<script type="math/tex; mode=display">
\sqrt{xy}\leq\frac{x+y}{2}</script></li>
<li><p>设$|\vec{v}|=5,|\vec{w}=3|$，求$|\vec{v}-\vec{w}|$的最小和最大可能长度</p>
<p>解：首先，$|\vec{v}-\vec{w}|^2=|\vec{v}|^2-2\vec{v}\cdot\vec{w}+|\vec{w}|^2$,由Cauchy-Schwarz不等式得$-|\vec{v}||\vec{w}|\leq\vec{v}\cdot\vec{w}\leq|\vec{v}||\vec{w}|$，</p>
<p>故$(|\vec{v}|-|\vec{w}|)^2\leq|\vec{v}-\vec{w}|^2\leq(|\vec{v}+\vec{w}|)^2$</p>
<p>所以，$2\leq|\vec{v}-\vec{w}|\leq8$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
  </entry>
  <entry>
    <title>计算机浮点数表示</title>
    <url>/2019/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%9B%B8%E5%85%B3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h1><p>想要理解浮点数，首先要考虑小数的二进制表示。首先来考虑十进制的的表示方法，对于任意含有小数部分的十进制，我们都可以用形如：</p>
<script type="math/tex; mode=display">
d_m d_{m-1} ···d_1 d_0  .  d_{-1} d_{-2} ··· d_{-n}</script><p>其中对于任意的$ d_i $的取值范围为$d_i\in[0,9]$,这个表达描述的数值$d$的定义如下：</p>
<script type="math/tex; mode=display">
d=\sum_{i=-n}^m10^i \times d_i \tag{1.1}</script><a id="more"></a>
<p>数字的权的定义与十进制小数点符号$’.’$有关，相当于小数点左边的数字的权是$10$的正幂，得到整数值，小数点右边的数字的权是$10$的负幂，得到小数值。例如，十进制数$12.34$可以表示为：</p>
<script type="math/tex; mode=display">1 \times 10^1+2 \times 10^0 + 3 \times 10^{-1}+4 \times 10^{-2}= 12 \frac{34}{100}</script><p>类似，考虑一个形如</p>
<script type="math/tex; mode=display">
b_m b_{m-1} ···b_1 b_0  .  b_{-1} b_{-2} ··· b_{-n}</script><p>的表示法，其中每个二进制（位）$b_i$的取值范围为$0或1$，这种表示方法表示的数$b$定义如下：</p>
<script type="math/tex; mode=display">
b=\sum_{i=-n}^m2^i \times b_i \tag{1.2}</script><p>此时，数字的权的定义与二进制小数点符号$’.’$有关，小数点左边的数字的权是$2$的正幂，得到整数值，小数点右边的数字的权是$2$的负幂，得到小数值。例如，二进制数$101.11$可以表示为：</p>
<script type="math/tex; mode=display">1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1 \times 2^{-1}+1 \times 2^{-2}=5 \frac{3}{4}</script><p>从$(1.2)$式中可以看出，将二进制小数点向左移动一位相当于除$2$，例如，$101.11$表示数$5 \frac{3}{4}$，而$10.111$表示数$2 \frac{7}{8}$，类似的，向右移动小数点一位相当于乘$2$，例如，$1011.1$表示数$11 \frac{1}{2}$。</p>
<p>注意，形如$(0.11···1)_2$表示的数是刚好小于$1$的数，例如$(0.111111)_2$表示$\frac{63}{64}$,在此将用$1-\epsilon$来表示此类数值。</p>
<p>如果我们仅考虑有限长度的编码，那么十进制符号是不能准确表达像$\frac{1}{3}$和$\frac{1}{5}$这样的无理数的。类似地，小数的二进制表示法只能表示那些能够被写成$x+2^y$的数。其它的值只能够近似地表示。例如，虽然加长的二进制能够提高表示数$\frac{1}{5}$的精度，但是我们并不能准确的把它表示为一个二进制数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制</th>
<th style="text-align:center">值</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">值</th>
<th style="text-align:center">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">0.00110</td>
<td style="text-align:center">$\frac{6}{32}$</td>
<td style="text-align:center">0.1875</td>
</tr>
<tr>
<td style="text-align:center">0.01</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">0.25</td>
<td style="text-align:center">0.001101</td>
<td style="text-align:center">$\frac{13}{64}$</td>
<td style="text-align:center">0.203125</td>
</tr>
<tr>
<td style="text-align:center">0.010</td>
<td style="text-align:center">$\frac{2}{8}$</td>
<td style="text-align:center">0.25</td>
<td style="text-align:center">0.0011010</td>
<td style="text-align:center">$\frac{26}{128}$</td>
<td style="text-align:center">0.203125</td>
</tr>
<tr>
<td style="text-align:center">0.0011</td>
<td style="text-align:center">$\frac{3}{16}$</td>
<td style="text-align:center">0.1875</td>
<td style="text-align:center">0.00110011</td>
<td style="text-align:center">$\frac{51}{256}$</td>
<td style="text-align:center">0.19921875</td>
</tr>
</tbody>
</table>
</div>
<h1 id="IEEE754浮点表示"><a href="#IEEE754浮点表示" class="headerlink" title="IEEE754浮点表示"></a>IEEE754浮点表示</h1><p>像前一节中谈到的位置表示法不能很有效地表示很大地数字。例如。$5 \times 2^{100}$的表示是由$101$后跟$100$的位模式组成。相反的，我们希望通过给定$x$和$y$的值来表示形如$x \times 2^y$的数。<br>IEEE（读作“eye-Triple-ee”）浮点标准用</p>
<p><script type="math/tex">V=(-1)^s \times M \times 2^E \tag{2.1}</script>来表示一个数。对于$(2.1)$式，有如下解释：</p>
<ul>
<li><strong> 符号$s$（sign）决定该数是正数（$s=0$）还是负数（$s=1$），对于数值$0$的符号位解释作为特殊情况处理。 </strong></li>
</ul>
<ul>
<li><strong> 有效数$M$（significand）是一个二进制小数，它的范围在$1 \sim 2-\epsilon$之间，或者在$0\sim 1-\epsilon$之间。 </strong></li>
</ul>
<ul>
<li><strong> 指数$E$（exponent）是$2$的幂（可能为负数），它的作用是对浮点数加权。</strong></li>
</ul>
<p>浮点数的位表示被划分为三个部分，以编码这些值：</p>
<ul>
<li><strong> 一个单独的符号位$s$直接编码符号$s$。 </strong></li>
<li><strong> $k$位的指数部分$exp=e_{k-1}···e_1e_0$编码指数E。 </strong></li>
<li><strong> $n$位的小数部分$frac=f_{n-1}···f_1f_0$编码有效数M，但是被编码的值也依赖于指数部分的值是否等于$0$。 </strong></li>
</ul>
<p>在单精度浮点格式（$C$语言中的$float$）中，$s$、$exp$、$frac$部分分别为$1$位，$k=8$位和$n=23$位，产生一个32位的表示。在双精度浮点格式（$C$语言中的$double$）中，$s$、$exp$、$frac$部分分别为$1$位、$k=11$位和$n=52$位，产生一个64位的表示。如下示意图所示：</p>
<center>32位浮点格式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">s</th>
<th style="text-align:center">exp</th>
<th style="text-align:center">frac</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">$e_7e_6···e_1e_0$</td>
<td style="text-align:center">$ f_{31}f_{30}···f_1f_0 $</td>
</tr>
</tbody>
</table>
</div>
<center>64位浮点格式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">s</th>
<th style="text-align:center">exp</th>
<th style="text-align:center">frac</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">$e_{10}e_9···e_1e_0$</td>
<td style="text-align:center">$f_{51}f_{50}···f_1f_0$</td>
</tr>
</tbody>
</table>
</div>
<p>根据$esp$的值，被编码的值可以划分为三种情况：<br>1.规格化的值<br>2.非规格化的值<br>3.特殊值</p>
<h2 id="规格化值"><a href="#规格化值" class="headerlink" title="规格化值"></a>规格化值</h2><p>这是最为普通的一种情况，当$exp$的值不全为$1$（对应数值0），和不全为$1$（32单精度中为255，64位双精度中为2047）时，都属于规格化的值。<br>在这种时候，阶码字段被解释为以偏置（biased）形式表示的有符号整数，此时阶码$E=e-Bias$，其中$e$为无符号数，表示形式为$exp=e_{k-1}···e_1e_0$，而$Bias$是一个等于$2_{k-1}-1$（单精度下为127，双精度下为1023）的偏置值。由此可以得到指数的取值范围，单精度为$-126 \sim +127$，而双精度为$-1022 \sim +1023$。<br>小数字段$frac$被解释为描述的小数值$f$，其中$0 \leq f&lt;1$，其二进制表示为$0.frac=f_{n-1}···f_1f_0$，尾数定义为$M=1+f$。</p>
<h2 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h2><p>非规格化的值就是当阶码全为$0$时所表示的数。此时，阶码值是$E=1-Bias$，而尾数的值是$M=f$，注意，此时不隐含开头的$1$，仅表示小数字段。<br>非规格化的数有两个用途，一是用来表示数值$0$（在规格化的数中，我们总有$M \geq 1$，因此就不能表示$0$）。当阶码为全$0$且小数字段也全为$0$，就得到了$M=f=0$，如果此时符号位为$0$，则得到值$+0.0$，反之当符号位为$1$，则得到值$-0.0$。在IEEE浮点数中，两个值在某些方面被认为是不同的。<br>另一个功能是表示非常接近$0.0$的值，它们提供了一种称为<strong>逐渐溢出</strong>（gradual underflow）的属性。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>最后一种情况是阶码全为1时出现的，当数小数部分$f$全为0时，得到的值表示无穷，$s=0$表示$+ \infty$，当$s=1$时表示$- \infty$。<br>当我们把两个非常大的数相乘或者除以零时，无穷大能够表示溢出的结果。当小数部分为非零时，结果值称为“NaN”（Not a Number），一些运算的结果不能是实数或无穷，就会返回这样的NaN值。</p>
<h1 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h1><p>下图展示了假定的8位浮点格式的示例，其中$k=4$的阶码位和$n=3的小数位$，偏置量是$2^{4-1}-1=7$。图分为三个区域来来描述三类数字。不同的列给出了阶码字段是如何编码阶码$E$的，小数字段是如何编码尾数$M$的，以及它们是如何形成要表示的值$V=(-1)^s \times M \times 2^E \tag{2.1}$的。<br>从0开始，靠近0的是非规格化数，这种格式的非规格化数的$E=1-7=-6$，得到权$2^E= \frac{1}{64}$。小数f的值的范围是$0, \frac{1}{8},···, \frac{7}{8}$，从而得到数V的范围为$0 \sim \frac{1}{64}  \times \frac{1}{8}= \frac{7}{512}$。</p>
<figure><img src="https://yurui-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/8%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E9%9D%9E%E8%B4%9F%E5%80%BC%E7%A4%BA%E4%BE%8B.png" alt="8位浮点数的非负值示例.png"><figcaption>8位浮点数的非负值示例</figcaption></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]（美）布莱恩特,（美）奥哈拉伦著.深入理解计算机系统  原书第2版.机械工业出版社,2010.Print.</p>
<p>[2]对IEEE 450-1995(ANSI/IEEE)标准的解释:IEEE 450-1995/INT-2001[S].2001.</p>
]]></content>
      <categories>
        <category>计算机组成相关</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
        <tag>IEEE754</tag>
        <tag>IEEE浮点数</tag>
      </tags>
  </entry>
</search>
